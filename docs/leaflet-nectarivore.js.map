{"version":3,"file":"leaflet-nectarivore.js","sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///./node_modules/js-clipper/clipper.js","webpack:///./node_modules/osmose-request/dist/OsmoseRequest.js","webpack:///./node_modules/uuid/lib/bytesToUuid.js","webpack:///./node_modules/uuid/lib/rng-browser.js","webpack:///./node_modules/uuid/v4.js","webpack:///(webpack)/buildin/global.js","webpack:///src/helpers/bounds.js","webpack:///src/helpers/boxes.js","webpack:///src/helpers/marker.js","webpack:///src/helpers/utils.js","webpack:///src/index.js","webpack:///src/services/baseService.js","webpack:///src/services/index.js","webpack:///src/services/osmose.js","webpack:///src/services/overpass.js","webpack:///external {\"commonjs\":\"leaflet\",\"commonjs2\":\"leaflet\",\"root\":\"L\"}"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"leaflet\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"leaflet\")) : factory(root[\"L\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function(__WEBPACK_EXTERNAL_MODULE_leaflet__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","// rev 452\n/********************************************************************************\n*                                                                              *\n* Author    :  Angus Johnson                                                   *\n* Version   :  6.1.3a                                                          *\n* Date      :  22 January 2014                                                 *\n* Website   :  http://www.angusj.com                                           *\n* Copyright :  Angus Johnson 2010-2014                                         *\n*                                                                              *\n* License:                                                                     *\n* Use, modification & distribution is subject to Boost Software License Ver 1. *\n* http://www.boost.org/LICENSE_1_0.txt                                         *\n*                                                                              *\n* Attributions:                                                                *\n* The code in this library is an extension of Bala Vatti's clipping algorithm: *\n* \"A generic solution to polygon clipping\"                                     *\n* Communications of the ACM, Vol 35, Issue 7 (July 1992) pp 56-63.             *\n* http://portal.acm.org/citation.cfm?id=129906                                 *\n*                                                                              *\n* Computer graphics and geometric modeling: implementation and algorithms      *\n* By Max K. Agoston                                                            *\n* Springer; 1 edition (January 4, 2005)                                        *\n* http://books.google.com/books?q=vatti+clipping+agoston                       *\n*                                                                              *\n* See also:                                                                    *\n* \"Polygon Offsetting by Computing Winding Numbers\"                            *\n* Paper no. DETC2005-85513 pp. 565-575                                         *\n* ASME 2005 International Design Engineering Technical Conferences             *\n* and Computers and Information in Engineering Conference (IDETC/CIE2005)      *\n* September 24-28, 2005 , Long Beach, California, USA                          *\n* http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf              *\n*                                                                              *\n*******************************************************************************/\n/*******************************************************************************\n*                                                                              *\n* Author    :  Timo                                                            *\n* Version   :  6.1.3.2                                                         *\n* Date      :  1 February 2014                                                 *\n*                                                                              *\n* This is a translation of the C# Clipper library to Javascript.               *\n* Int128 struct of C# is implemented using JSBN of Tom Wu.                     *\n* Because Javascript lacks support for 64-bit integers, the space              *\n* is a little more restricted than in C# version.                              *\n*                                                                              *\n* C# version has support for coordinate space:                                 *\n* +-4611686018427387903 ( sqrt(2^127 -1)/2 )                                   *\n* while Javascript version has support for space:                              *\n* +-4503599627370495 ( sqrt(2^106 -1)/2 )                                      *\n*                                                                              *\n* Tom Wu's JSBN proved to be the fastest big integer library:                  *\n* http://jsperf.com/big-integer-library-test                                   *\n*                                                                              *\n* This class can be made simpler when (if ever) 64-bit integer support comes.  *\n*                                                                              *\n*******************************************************************************/\n/*******************************************************************************\n*                                                                              *\n* Basic JavaScript BN library - subset useful for RSA encryption.              *\n* http://www-cs-students.stanford.edu/~tjw/jsbn/                               *\n* Copyright (c) 2005  Tom Wu                                                   *\n* All Rights Reserved.                                                         *\n* See \"LICENSE\" for details:                                                   *\n* http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE                        *\n*                                                                              *\n*******************************************************************************/\n\n\"use strict\";\n//use_int32: When enabled 32bit ints are used instead of 64bit ints. This\n//improve performance but coordinate values are limited to the range +/- 46340\nvar use_int32 = false;\n//use_xyz: adds a Z member to IntPoint. Adds a minor cost to performance.\nvar use_xyz = false;\n//UseLines: Enables line clipping. Adds a very minor cost to performance.\nvar use_lines = true;\n//use_deprecated: Enables support for the obsolete OffsetPaths() function\n//which has been replace with the ClipperOffset class.\nvar use_deprecated = false;\n\nvar ClipperLib = {};\nvar isNode = false;\nif (typeof module !== 'undefined' && module.exports)\n{\n  module.exports = ClipperLib;\n  isNode = true;\n}\nelse\n{\n  if (typeof (document) !== \"undefined\") window.ClipperLib = ClipperLib;\n  else self['ClipperLib'] = ClipperLib;\n}\nvar navigator_appName;\nif (!isNode)\n{\n  var nav = navigator.userAgent.toString().toLowerCase();\n  navigator_appName = navigator.appName;\n}\nelse\n{\n  var nav = \"chrome\"; // Node.js uses Chrome's V8 engine\n  navigator_appName = \"Netscape\"; // Firefox, Chrome and Safari returns \"Netscape\", so Node.js should also\n}\n// Browser test to speedup performance critical functions\nvar browser = {};\nif (nav.indexOf(\"chrome\") != -1 && nav.indexOf(\"chromium\") == -1) browser.chrome = 1;\nelse browser.chrome = 0;\nif (nav.indexOf(\"chromium\") != -1) browser.chromium = 1;\nelse browser.chromium = 0;\nif (nav.indexOf(\"safari\") != -1 && nav.indexOf(\"chrome\") == -1 && nav.indexOf(\"chromium\") == -1) browser.safari = 1;\nelse browser.safari = 0;\nif (nav.indexOf(\"firefox\") != -1) browser.firefox = 1;\nelse browser.firefox = 0;\nif (nav.indexOf(\"firefox/17\") != -1) browser.firefox17 = 1;\nelse browser.firefox17 = 0;\nif (nav.indexOf(\"firefox/15\") != -1) browser.firefox15 = 1;\nelse browser.firefox15 = 0;\nif (nav.indexOf(\"firefox/3\") != -1) browser.firefox3 = 1;\nelse browser.firefox3 = 0;\nif (nav.indexOf(\"opera\") != -1) browser.opera = 1;\nelse browser.opera = 0;\nif (nav.indexOf(\"msie 10\") != -1) browser.msie10 = 1;\nelse browser.msie10 = 0;\nif (nav.indexOf(\"msie 9\") != -1) browser.msie9 = 1;\nelse browser.msie9 = 0;\nif (nav.indexOf(\"msie 8\") != -1) browser.msie8 = 1;\nelse browser.msie8 = 0;\nif (nav.indexOf(\"msie 7\") != -1) browser.msie7 = 1;\nelse browser.msie7 = 0;\nif (nav.indexOf(\"msie \") != -1) browser.msie = 1;\nelse browser.msie = 0;\nClipperLib.biginteger_used = null;\n// Copyright (c) 2005  Tom Wu\n// All Rights Reserved.\n// See \"LICENSE\" for details.\n// Basic JavaScript BN library - subset useful for RSA encryption.\n// Bits per digit\nvar dbits;\n// JavaScript engine analysis\nvar canary = 0xdeadbeefcafe;\nvar j_lm = ((canary & 0xffffff) == 0xefcafe);\n// (public) Constructor\nfunction BigInteger(a, b, c)\n{\n  // This test variable can be removed,\n  // but at least for performance tests it is useful piece of knowledge\n  // This is the only ClipperLib related variable in BigInteger library\n  ClipperLib.biginteger_used = 1;\n  if (a != null)\n    if (\"number\" == typeof a && \"undefined\" == typeof (b)) this.fromInt(a); // faster conversion\n    else if (\"number\" == typeof a) this.fromNumber(a, b, c);\n  else if (b == null && \"string\" != typeof a) this.fromString(a, 256);\n  else this.fromString(a, b);\n}\n// return new, unset BigInteger\nfunction nbi()\n{\n  return new BigInteger(null);\n}\n// am: Compute w_j += (x*this_i), propagate carries,\n// c is initial carry, returns final carry.\n// c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n// We need to select the fastest one that works in this environment.\n// am1: use a single mult and divide to get the high bits,\n// max digit bits should be 26 because\n// max internal value = 2*dvalue^2-2*dvalue (< 2^53)\nfunction am1(i, x, w, j, c, n)\n{\n  while (--n >= 0)\n  {\n    var v = x * this[i++] + w[j] + c;\n    c = Math.floor(v / 0x4000000);\n    w[j++] = v & 0x3ffffff;\n  }\n  return c;\n}\n// am2 avoids a big mult-and-extract completely.\n// Max digit bits should be <= 30 because we do bitwise ops\n// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\nfunction am2(i, x, w, j, c, n)\n{\n  var xl = x & 0x7fff,\n    xh = x >> 15;\n  while (--n >= 0)\n  {\n    var l = this[i] & 0x7fff;\n    var h = this[i++] >> 15;\n    var m = xh * l + h * xl;\n    l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);\n    c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);\n    w[j++] = l & 0x3fffffff;\n  }\n  return c;\n}\n// Alternately, set max digit bits to 28 since some\n// browsers slow down when dealing with 32-bit numbers.\nfunction am3(i, x, w, j, c, n)\n{\n  var xl = x & 0x3fff,\n    xh = x >> 14;\n  while (--n >= 0)\n  {\n    var l = this[i] & 0x3fff;\n    var h = this[i++] >> 14;\n    var m = xh * l + h * xl;\n    l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;\n    c = (l >> 28) + (m >> 14) + xh * h;\n    w[j++] = l & 0xfffffff;\n  }\n  return c;\n}\nif (j_lm && (navigator_appName == \"Microsoft Internet Explorer\"))\n{\n  BigInteger.prototype.am = am2;\n  dbits = 30;\n}\nelse if (j_lm && (navigator_appName != \"Netscape\"))\n{\n  BigInteger.prototype.am = am1;\n  dbits = 26;\n}\nelse\n{ // Mozilla/Netscape seems to prefer am3\n  BigInteger.prototype.am = am3;\n  dbits = 28;\n}\nBigInteger.prototype.DB = dbits;\nBigInteger.prototype.DM = ((1 << dbits) - 1);\nBigInteger.prototype.DV = (1 << dbits);\nvar BI_FP = 52;\nBigInteger.prototype.FV = Math.pow(2, BI_FP);\nBigInteger.prototype.F1 = BI_FP - dbits;\nBigInteger.prototype.F2 = 2 * dbits - BI_FP;\n// Digit conversions\nvar BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\nvar BI_RC = new Array();\nvar rr, vv;\nrr = \"0\".charCodeAt(0);\nfor (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\nrr = \"a\".charCodeAt(0);\nfor (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\nrr = \"A\".charCodeAt(0);\nfor (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\nfunction int2char(n)\n{\n  return BI_RM.charAt(n);\n}\n\nfunction intAt(s, i)\n{\n  var c = BI_RC[s.charCodeAt(i)];\n  return (c == null) ? -1 : c;\n}\n// (protected) copy this to r\nfunction bnpCopyTo(r)\n{\n  for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];\n  r.t = this.t;\n  r.s = this.s;\n}\n// (protected) set from integer value x, -DV <= x < DV\nfunction bnpFromInt(x)\n{\n  this.t = 1;\n  this.s = (x < 0) ? -1 : 0;\n  if (x > 0) this[0] = x;\n  else if (x < -1) this[0] = x + this.DV;\n  else this.t = 0;\n}\n// return bigint initialized to value\nfunction nbv(i)\n{\n  var r = nbi();\n  r.fromInt(i);\n  return r;\n}\n// (protected) set from string and radix\nfunction bnpFromString(s, b)\n{\n  var k;\n  if (b == 16) k = 4;\n  else if (b == 8) k = 3;\n  else if (b == 256) k = 8; // byte array\n  else if (b == 2) k = 1;\n  else if (b == 32) k = 5;\n  else if (b == 4) k = 2;\n  else\n  {\n    this.fromRadix(s, b);\n    return;\n  }\n  this.t = 0;\n  this.s = 0;\n  var i = s.length,\n    mi = false,\n    sh = 0;\n  while (--i >= 0)\n  {\n    var x = (k == 8) ? s[i] & 0xff : intAt(s, i);\n    if (x < 0)\n    {\n      if (s.charAt(i) == \"-\") mi = true;\n      continue;\n    }\n    mi = false;\n    if (sh == 0)\n      this[this.t++] = x;\n    else if (sh + k > this.DB)\n    {\n      this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;\n      this[this.t++] = (x >> (this.DB - sh));\n    }\n    else\n      this[this.t - 1] |= x << sh;\n    sh += k;\n    if (sh >= this.DB) sh -= this.DB;\n  }\n  if (k == 8 && (s[0] & 0x80) != 0)\n  {\n    this.s = -1;\n    if (sh > 0) this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;\n  }\n  this.clamp();\n  if (mi) BigInteger.ZERO.subTo(this, this);\n}\n// (protected) clamp off excess high words\nfunction bnpClamp()\n{\n  var c = this.s & this.DM;\n  while (this.t > 0 && this[this.t - 1] == c)--this.t;\n}\n// (public) return string representation in given radix\nfunction bnToString(b)\n{\n  if (this.s < 0) return \"-\" + this.negate().toString(b);\n  var k;\n  if (b == 16) k = 4;\n  else if (b == 8) k = 3;\n  else if (b == 2) k = 1;\n  else if (b == 32) k = 5;\n  else if (b == 4) k = 2;\n  else return this.toRadix(b);\n  var km = (1 << k) - 1,\n    d, m = false,\n    r = \"\",\n    i = this.t;\n  var p = this.DB - (i * this.DB) % k;\n  if (i-- > 0)\n  {\n    if (p < this.DB && (d = this[i] >> p) > 0)\n    {\n      m = true;\n      r = int2char(d);\n    }\n    while (i >= 0)\n    {\n      if (p < k)\n      {\n        d = (this[i] & ((1 << p) - 1)) << (k - p);\n        d |= this[--i] >> (p += this.DB - k);\n      }\n      else\n      {\n        d = (this[i] >> (p -= k)) & km;\n        if (p <= 0)\n        {\n          p += this.DB;\n          --i;\n        }\n      }\n      if (d > 0) m = true;\n      if (m) r += int2char(d);\n    }\n  }\n  return m ? r : \"0\";\n}\n// (public) -this\nfunction bnNegate()\n{\n  var r = nbi();\n  BigInteger.ZERO.subTo(this, r);\n  return r;\n}\n// (public) |this|\nfunction bnAbs()\n{\n  return (this.s < 0) ? this.negate() : this;\n}\n// (public) return + if this > a, - if this < a, 0 if equal\nfunction bnCompareTo(a)\n{\n  var r = this.s - a.s;\n  if (r != 0) return r;\n  var i = this.t;\n  r = i - a.t;\n  if (r != 0) return (this.s < 0) ? -r : r;\n  while (--i >= 0)\n    if ((r = this[i] - a[i]) != 0) return r;\n  return 0;\n}\n// returns bit length of the integer x\nfunction nbits(x)\n{\n  var r = 1,\n    t;\n  if ((t = x >>> 16) != 0)\n  {\n    x = t;\n    r += 16;\n  }\n  if ((t = x >> 8) != 0)\n  {\n    x = t;\n    r += 8;\n  }\n  if ((t = x >> 4) != 0)\n  {\n    x = t;\n    r += 4;\n  }\n  if ((t = x >> 2) != 0)\n  {\n    x = t;\n    r += 2;\n  }\n  if ((t = x >> 1) != 0)\n  {\n    x = t;\n    r += 1;\n  }\n  return r;\n}\n// (public) return the number of bits in \"this\"\nfunction bnBitLength()\n{\n  if (this.t <= 0) return 0;\n  return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));\n}\n// (protected) r = this << n*DB\nfunction bnpDLShiftTo(n, r)\n{\n  var i;\n  for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];\n  for (i = n - 1; i >= 0; --i) r[i] = 0;\n  r.t = this.t + n;\n  r.s = this.s;\n}\n// (protected) r = this >> n*DB\nfunction bnpDRShiftTo(n, r)\n{\n  for (var i = n; i < this.t; ++i) r[i - n] = this[i];\n  r.t = Math.max(this.t - n, 0);\n  r.s = this.s;\n}\n// (protected) r = this << n\nfunction bnpLShiftTo(n, r)\n{\n  var bs = n % this.DB;\n  var cbs = this.DB - bs;\n  var bm = (1 << cbs) - 1;\n  var ds = Math.floor(n / this.DB),\n    c = (this.s << bs) & this.DM,\n    i;\n  for (i = this.t - 1; i >= 0; --i)\n  {\n    r[i + ds + 1] = (this[i] >> cbs) | c;\n    c = (this[i] & bm) << bs;\n  }\n  for (i = ds - 1; i >= 0; --i) r[i] = 0;\n  r[ds] = c;\n  r.t = this.t + ds + 1;\n  r.s = this.s;\n  r.clamp();\n}\n// (protected) r = this >> n\nfunction bnpRShiftTo(n, r)\n{\n  r.s = this.s;\n  var ds = Math.floor(n / this.DB);\n  if (ds >= this.t)\n  {\n    r.t = 0;\n    return;\n  }\n  var bs = n % this.DB;\n  var cbs = this.DB - bs;\n  var bm = (1 << bs) - 1;\n  r[0] = this[ds] >> bs;\n  for (var i = ds + 1; i < this.t; ++i)\n  {\n    r[i - ds - 1] |= (this[i] & bm) << cbs;\n    r[i - ds] = this[i] >> bs;\n  }\n  if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;\n  r.t = this.t - ds;\n  r.clamp();\n}\n// (protected) r = this - a\nfunction bnpSubTo(a, r)\n{\n  var i = 0,\n    c = 0,\n    m = Math.min(a.t, this.t);\n  while (i < m)\n  {\n    c += this[i] - a[i];\n    r[i++] = c & this.DM;\n    c >>= this.DB;\n  }\n  if (a.t < this.t)\n  {\n    c -= a.s;\n    while (i < this.t)\n    {\n      c += this[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n    c += this.s;\n  }\n  else\n  {\n    c += this.s;\n    while (i < a.t)\n    {\n      c -= a[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n    c -= a.s;\n  }\n  r.s = (c < 0) ? -1 : 0;\n  if (c < -1) r[i++] = this.DV + c;\n  else if (c > 0) r[i++] = c;\n  r.t = i;\n  r.clamp();\n}\n// (protected) r = this * a, r != this,a (HAC 14.12)\n// \"this\" should be the larger one if appropriate.\nfunction bnpMultiplyTo(a, r)\n{\n  var x = this.abs(),\n    y = a.abs();\n  var i = x.t;\n  r.t = i + y.t;\n  while (--i >= 0) r[i] = 0;\n  for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);\n  r.s = 0;\n  r.clamp();\n  if (this.s != a.s) BigInteger.ZERO.subTo(r, r);\n}\n// (protected) r = this^2, r != this (HAC 14.16)\nfunction bnpSquareTo(r)\n{\n  var x = this.abs();\n  var i = r.t = 2 * x.t;\n  while (--i >= 0) r[i] = 0;\n  for (i = 0; i < x.t - 1; ++i)\n  {\n    var c = x.am(i, x[i], r, 2 * i, 0, 1);\n    if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV)\n    {\n      r[i + x.t] -= x.DV;\n      r[i + x.t + 1] = 1;\n    }\n  }\n  if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);\n  r.s = 0;\n  r.clamp();\n}\n// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n// r != q, this != m.  q or r may be null.\nfunction bnpDivRemTo(m, q, r)\n{\n  var pm = m.abs();\n  if (pm.t <= 0) return;\n  var pt = this.abs();\n  if (pt.t < pm.t)\n  {\n    if (q != null) q.fromInt(0);\n    if (r != null) this.copyTo(r);\n    return;\n  }\n  if (r == null) r = nbi();\n  var y = nbi(),\n    ts = this.s,\n    ms = m.s;\n  var nsh = this.DB - nbits(pm[pm.t - 1]); // normalize modulus\n  if (nsh > 0)\n  {\n    pm.lShiftTo(nsh, y);\n    pt.lShiftTo(nsh, r);\n  }\n  else\n  {\n    pm.copyTo(y);\n    pt.copyTo(r);\n  }\n  var ys = y.t;\n  var y0 = y[ys - 1];\n  if (y0 == 0) return;\n  var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);\n  var d1 = this.FV / yt,\n    d2 = (1 << this.F1) / yt,\n    e = 1 << this.F2;\n  var i = r.t,\n    j = i - ys,\n    t = (q == null) ? nbi() : q;\n  y.dlShiftTo(j, t);\n  if (r.compareTo(t) >= 0)\n  {\n    r[r.t++] = 1;\n    r.subTo(t, r);\n  }\n  BigInteger.ONE.dlShiftTo(ys, t);\n  t.subTo(y, y); // \"negative\" y so we can replace sub with am later\n  while (y.t < ys) y[y.t++] = 0;\n  while (--j >= 0)\n  {\n    // Estimate quotient digit\n    var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);\n    if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd)\n    { // Try it out\n      y.dlShiftTo(j, t);\n      r.subTo(t, r);\n      while (r[i] < --qd) r.subTo(t, r);\n    }\n  }\n  if (q != null)\n  {\n    r.drShiftTo(ys, q);\n    if (ts != ms) BigInteger.ZERO.subTo(q, q);\n  }\n  r.t = ys;\n  r.clamp();\n  if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder\n  if (ts < 0) BigInteger.ZERO.subTo(r, r);\n}\n// (public) this mod a\nfunction bnMod(a)\n{\n  var r = nbi();\n  this.abs().divRemTo(a, null, r);\n  if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);\n  return r;\n}\n// Modular reduction using \"classic\" algorithm\nfunction Classic(m)\n{\n  this.m = m;\n}\n\nfunction cConvert(x)\n{\n  if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n  else return x;\n}\n\nfunction cRevert(x)\n{\n  return x;\n}\n\nfunction cReduce(x)\n{\n  x.divRemTo(this.m, null, x);\n}\n\nfunction cMulTo(x, y, r)\n{\n  x.multiplyTo(y, r);\n  this.reduce(r);\n}\n\nfunction cSqrTo(x, r)\n{\n  x.squareTo(r);\n  this.reduce(r);\n}\nClassic.prototype.convert = cConvert;\nClassic.prototype.revert = cRevert;\nClassic.prototype.reduce = cReduce;\nClassic.prototype.mulTo = cMulTo;\nClassic.prototype.sqrTo = cSqrTo;\n// (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n// justification:\n//         xy == 1 (mod m)\n//         xy =  1+km\n//   xy(2-xy) = (1+km)(1-km)\n// x[y(2-xy)] = 1-k^2m^2\n// x[y(2-xy)] == 1 (mod m^2)\n// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n// JS multiply \"overflows\" differently from C/C++, so care is needed here.\nfunction bnpInvDigit()\n{\n  if (this.t < 1) return 0;\n  var x = this[0];\n  if ((x & 1) == 0) return 0;\n  var y = x & 3; // y == 1/x mod 2^2\n  y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4\n  y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8\n  y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16\n  // last step - calculate inverse mod DV directly;\n  // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n  y = (y * (2 - x * y % this.DV)) % this.DV; // y == 1/x mod 2^dbits\n  // we really want the negative inverse, and -DV < y < DV\n  return (y > 0) ? this.DV - y : -y;\n}\n// Montgomery reduction\nfunction Montgomery(m)\n{\n  this.m = m;\n  this.mp = m.invDigit();\n  this.mpl = this.mp & 0x7fff;\n  this.mph = this.mp >> 15;\n  this.um = (1 << (m.DB - 15)) - 1;\n  this.mt2 = 2 * m.t;\n}\n// xR mod m\nfunction montConvert(x)\n{\n  var r = nbi();\n  x.abs().dlShiftTo(this.m.t, r);\n  r.divRemTo(this.m, null, r);\n  if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);\n  return r;\n}\n// x/R mod m\nfunction montRevert(x)\n{\n  var r = nbi();\n  x.copyTo(r);\n  this.reduce(r);\n  return r;\n}\n// x = x/R mod m (HAC 14.32)\nfunction montReduce(x)\n{\n  while (x.t <= this.mt2) // pad x so am has enough room later\n    x[x.t++] = 0;\n  for (var i = 0; i < this.m.t; ++i)\n  {\n    // faster way of calculating u0 = x[i]*mp mod DV\n    var j = x[i] & 0x7fff;\n    var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;\n    // use am to combine the multiply-shift-add into one call\n    j = i + this.m.t;\n    x[j] += this.m.am(0, u0, x, i, 0, this.m.t);\n    // propagate carry\n    while (x[j] >= x.DV)\n    {\n      x[j] -= x.DV;\n      x[++j]++;\n    }\n  }\n  x.clamp();\n  x.drShiftTo(this.m.t, x);\n  if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n}\n// r = \"x^2/R mod m\"; x != r\nfunction montSqrTo(x, r)\n{\n  x.squareTo(r);\n  this.reduce(r);\n}\n// r = \"xy/R mod m\"; x,y != r\nfunction montMulTo(x, y, r)\n{\n  x.multiplyTo(y, r);\n  this.reduce(r);\n}\nMontgomery.prototype.convert = montConvert;\nMontgomery.prototype.revert = montRevert;\nMontgomery.prototype.reduce = montReduce;\nMontgomery.prototype.mulTo = montMulTo;\nMontgomery.prototype.sqrTo = montSqrTo;\n// (protected) true iff this is even\nfunction bnpIsEven()\n{\n  return ((this.t > 0) ? (this[0] & 1) : this.s) == 0;\n}\n// (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\nfunction bnpExp(e, z)\n{\n  if (e > 0xffffffff || e < 1) return BigInteger.ONE;\n  var r = nbi(),\n    r2 = nbi(),\n    g = z.convert(this),\n    i = nbits(e) - 1;\n  g.copyTo(r);\n  while (--i >= 0)\n  {\n    z.sqrTo(r, r2);\n    if ((e & (1 << i)) > 0) z.mulTo(r2, g, r);\n    else\n    {\n      var t = r;\n      r = r2;\n      r2 = t;\n    }\n  }\n  return z.revert(r);\n}\n// (public) this^e % m, 0 <= e < 2^32\nfunction bnModPowInt(e, m)\n{\n  var z;\n  if (e < 256 || m.isEven()) z = new Classic(m);\n  else z = new Montgomery(m);\n  return this.exp(e, z);\n}\n// protected\nBigInteger.prototype.copyTo = bnpCopyTo;\nBigInteger.prototype.fromInt = bnpFromInt;\nBigInteger.prototype.fromString = bnpFromString;\nBigInteger.prototype.clamp = bnpClamp;\nBigInteger.prototype.dlShiftTo = bnpDLShiftTo;\nBigInteger.prototype.drShiftTo = bnpDRShiftTo;\nBigInteger.prototype.lShiftTo = bnpLShiftTo;\nBigInteger.prototype.rShiftTo = bnpRShiftTo;\nBigInteger.prototype.subTo = bnpSubTo;\nBigInteger.prototype.multiplyTo = bnpMultiplyTo;\nBigInteger.prototype.squareTo = bnpSquareTo;\nBigInteger.prototype.divRemTo = bnpDivRemTo;\nBigInteger.prototype.invDigit = bnpInvDigit;\nBigInteger.prototype.isEven = bnpIsEven;\nBigInteger.prototype.exp = bnpExp;\n// public\nBigInteger.prototype.toString = bnToString;\nBigInteger.prototype.negate = bnNegate;\nBigInteger.prototype.abs = bnAbs;\nBigInteger.prototype.compareTo = bnCompareTo;\nBigInteger.prototype.bitLength = bnBitLength;\nBigInteger.prototype.mod = bnMod;\nBigInteger.prototype.modPowInt = bnModPowInt;\n// \"constants\"\nBigInteger.ZERO = nbv(0);\nBigInteger.ONE = nbv(1);\n// Copyright (c) 2005-2009  Tom Wu\n// All Rights Reserved.\n// See \"LICENSE\" for details.\n// Extended JavaScript BN functions, required for RSA private ops.\n// Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\n// Version 1.2: square() API, isProbablePrime fix\n// (public)\nfunction bnClone()\n{\n  var r = nbi();\n  this.copyTo(r);\n  return r;\n}\n// (public) return value as integer\nfunction bnIntValue()\n{\n  if (this.s < 0)\n  {\n    if (this.t == 1) return this[0] - this.DV;\n    else if (this.t == 0) return -1;\n  }\n  else if (this.t == 1) return this[0];\n  else if (this.t == 0) return 0;\n  // assumes 16 < DB < 32\n  return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];\n}\n// (public) return value as byte\nfunction bnByteValue()\n{\n  return (this.t == 0) ? this.s : (this[0] << 24) >> 24;\n}\n// (public) return value as short (assumes DB>=16)\nfunction bnShortValue()\n{\n  return (this.t == 0) ? this.s : (this[0] << 16) >> 16;\n}\n// (protected) return x s.t. r^x < DV\nfunction bnpChunkSize(r)\n{\n  return Math.floor(Math.LN2 * this.DB / Math.log(r));\n}\n// (public) 0 if this == 0, 1 if this > 0\nfunction bnSigNum()\n{\n  if (this.s < 0) return -1;\n  else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\n  else return 1;\n}\n// (protected) convert to radix string\nfunction bnpToRadix(b)\n{\n  if (b == null) b = 10;\n  if (this.signum() == 0 || b < 2 || b > 36) return \"0\";\n  var cs = this.chunkSize(b);\n  var a = Math.pow(b, cs);\n  var d = nbv(a),\n    y = nbi(),\n    z = nbi(),\n    r = \"\";\n  this.divRemTo(d, y, z);\n  while (y.signum() > 0)\n  {\n    r = (a + z.intValue()).toString(b).substr(1) + r;\n    y.divRemTo(d, y, z);\n  }\n  return z.intValue().toString(b) + r;\n}\n// (protected) convert from radix string\nfunction bnpFromRadix(s, b)\n{\n  this.fromInt(0);\n  if (b == null) b = 10;\n  var cs = this.chunkSize(b);\n  var d = Math.pow(b, cs),\n    mi = false,\n    j = 0,\n    w = 0;\n  for (var i = 0; i < s.length; ++i)\n  {\n    var x = intAt(s, i);\n    if (x < 0)\n    {\n      if (s.charAt(i) == \"-\" && this.signum() == 0) mi = true;\n      continue;\n    }\n    w = b * w + x;\n    if (++j >= cs)\n    {\n      this.dMultiply(d);\n      this.dAddOffset(w, 0);\n      j = 0;\n      w = 0;\n    }\n  }\n  if (j > 0)\n  {\n    this.dMultiply(Math.pow(b, j));\n    this.dAddOffset(w, 0);\n  }\n  if (mi) BigInteger.ZERO.subTo(this, this);\n}\n// (protected) alternate constructor\nfunction bnpFromNumber(a, b, c)\n{\n  if (\"number\" == typeof b)\n  {\n    // new BigInteger(int,int,RNG)\n    if (a < 2) this.fromInt(1);\n    else\n    {\n      this.fromNumber(a, c);\n      if (!this.testBit(a - 1)) // force MSB set\n        this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);\n      if (this.isEven()) this.dAddOffset(1, 0); // force odd\n      while (!this.isProbablePrime(b))\n      {\n        this.dAddOffset(2, 0);\n        if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);\n      }\n    }\n  }\n  else\n  {\n    // new BigInteger(int,RNG)\n    var x = new Array(),\n      t = a & 7;\n    x.length = (a >> 3) + 1;\n    b.nextBytes(x);\n    if (t > 0) x[0] &= ((1 << t) - 1);\n    else x[0] = 0;\n    this.fromString(x, 256);\n  }\n}\n// (public) convert to bigendian byte array\nfunction bnToByteArray()\n{\n  var i = this.t,\n    r = new Array();\n  r[0] = this.s;\n  var p = this.DB - (i * this.DB) % 8,\n    d, k = 0;\n  if (i-- > 0)\n  {\n    if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)\n      r[k++] = d | (this.s << (this.DB - p));\n    while (i >= 0)\n    {\n      if (p < 8)\n      {\n        d = (this[i] & ((1 << p) - 1)) << (8 - p);\n        d |= this[--i] >> (p += this.DB - 8);\n      }\n      else\n      {\n        d = (this[i] >> (p -= 8)) & 0xff;\n        if (p <= 0)\n        {\n          p += this.DB;\n          --i;\n        }\n      }\n      if ((d & 0x80) != 0) d |= -256;\n      if (k == 0 && (this.s & 0x80) != (d & 0x80))++k;\n      if (k > 0 || d != this.s) r[k++] = d;\n    }\n  }\n  return r;\n}\n\nfunction bnEquals(a)\n{\n  return (this.compareTo(a) == 0);\n}\n\nfunction bnMin(a)\n{\n  return (this.compareTo(a) < 0) ? this : a;\n}\n\nfunction bnMax(a)\n{\n  return (this.compareTo(a) > 0) ? this : a;\n}\n// (protected) r = this op a (bitwise)\nfunction bnpBitwiseTo(a, op, r)\n{\n  var i, f, m = Math.min(a.t, this.t);\n  for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);\n  if (a.t < this.t)\n  {\n    f = a.s & this.DM;\n    for (i = m; i < this.t; ++i) r[i] = op(this[i], f);\n    r.t = this.t;\n  }\n  else\n  {\n    f = this.s & this.DM;\n    for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);\n    r.t = a.t;\n  }\n  r.s = op(this.s, a.s);\n  r.clamp();\n}\n// (public) this & a\nfunction op_and(x, y)\n{\n  return x & y;\n}\n\nfunction bnAnd(a)\n{\n  var r = nbi();\n  this.bitwiseTo(a, op_and, r);\n  return r;\n}\n// (public) this | a\nfunction op_or(x, y)\n{\n  return x | y;\n}\n\nfunction bnOr(a)\n{\n  var r = nbi();\n  this.bitwiseTo(a, op_or, r);\n  return r;\n}\n// (public) this ^ a\nfunction op_xor(x, y)\n{\n  return x ^ y;\n}\n\nfunction bnXor(a)\n{\n  var r = nbi();\n  this.bitwiseTo(a, op_xor, r);\n  return r;\n}\n// (public) this & ~a\nfunction op_andnot(x, y)\n{\n  return x & ~y;\n}\n\nfunction bnAndNot(a)\n{\n  var r = nbi();\n  this.bitwiseTo(a, op_andnot, r);\n  return r;\n}\n// (public) ~this\nfunction bnNot()\n{\n  var r = nbi();\n  for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];\n  r.t = this.t;\n  r.s = ~this.s;\n  return r;\n}\n// (public) this << n\nfunction bnShiftLeft(n)\n{\n  var r = nbi();\n  if (n < 0) this.rShiftTo(-n, r);\n  else this.lShiftTo(n, r);\n  return r;\n}\n// (public) this >> n\nfunction bnShiftRight(n)\n{\n  var r = nbi();\n  if (n < 0) this.lShiftTo(-n, r);\n  else this.rShiftTo(n, r);\n  return r;\n}\n// return index of lowest 1-bit in x, x < 2^31\nfunction lbit(x)\n{\n  if (x == 0) return -1;\n  var r = 0;\n  if ((x & 0xffff) == 0)\n  {\n    x >>= 16;\n    r += 16;\n  }\n  if ((x & 0xff) == 0)\n  {\n    x >>= 8;\n    r += 8;\n  }\n  if ((x & 0xf) == 0)\n  {\n    x >>= 4;\n    r += 4;\n  }\n  if ((x & 3) == 0)\n  {\n    x >>= 2;\n    r += 2;\n  }\n  if ((x & 1) == 0)++r;\n  return r;\n}\n// (public) returns index of lowest 1-bit (or -1 if none)\nfunction bnGetLowestSetBit()\n{\n  for (var i = 0; i < this.t; ++i)\n    if (this[i] != 0) return i * this.DB + lbit(this[i]);\n  if (this.s < 0) return this.t * this.DB;\n  return -1;\n}\n// return number of 1 bits in x\nfunction cbit(x)\n{\n  var r = 0;\n  while (x != 0)\n  {\n    x &= x - 1;\n    ++r;\n  }\n  return r;\n}\n// (public) return number of set bits\nfunction bnBitCount()\n{\n  var r = 0,\n    x = this.s & this.DM;\n  for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);\n  return r;\n}\n// (public) true iff nth bit is set\nfunction bnTestBit(n)\n{\n  var j = Math.floor(n / this.DB);\n  if (j >= this.t) return (this.s != 0);\n  return ((this[j] & (1 << (n % this.DB))) != 0);\n}\n// (protected) this op (1<<n)\nfunction bnpChangeBit(n, op)\n{\n  var r = BigInteger.ONE.shiftLeft(n);\n  this.bitwiseTo(r, op, r);\n  return r;\n}\n// (public) this | (1<<n)\nfunction bnSetBit(n)\n{\n  return this.changeBit(n, op_or);\n}\n// (public) this & ~(1<<n)\nfunction bnClearBit(n)\n{\n  return this.changeBit(n, op_andnot);\n}\n// (public) this ^ (1<<n)\nfunction bnFlipBit(n)\n{\n  return this.changeBit(n, op_xor);\n}\n// (protected) r = this + a\nfunction bnpAddTo(a, r)\n{\n  var i = 0,\n    c = 0,\n    m = Math.min(a.t, this.t);\n  while (i < m)\n  {\n    c += this[i] + a[i];\n    r[i++] = c & this.DM;\n    c >>= this.DB;\n  }\n  if (a.t < this.t)\n  {\n    c += a.s;\n    while (i < this.t)\n    {\n      c += this[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n    c += this.s;\n  }\n  else\n  {\n    c += this.s;\n    while (i < a.t)\n    {\n      c += a[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n    c += a.s;\n  }\n  r.s = (c < 0) ? -1 : 0;\n  if (c > 0) r[i++] = c;\n  else if (c < -1) r[i++] = this.DV + c;\n  r.t = i;\n  r.clamp();\n}\n// (public) this + a\nfunction bnAdd(a)\n{\n  var r = nbi();\n  this.addTo(a, r);\n  return r;\n}\n// (public) this - a\nfunction bnSubtract(a)\n{\n  var r = nbi();\n  this.subTo(a, r);\n  return r;\n}\n// (public) this * a\nfunction bnMultiply(a)\n{\n  var r = nbi();\n  this.multiplyTo(a, r);\n  return r;\n}\n// (public) this^2\nfunction bnSquare()\n{\n  var r = nbi();\n  this.squareTo(r);\n  return r;\n}\n// (public) this / a\nfunction bnDivide(a)\n{\n  var r = nbi();\n  this.divRemTo(a, r, null);\n  return r;\n}\n// (public) this % a\nfunction bnRemainder(a)\n{\n  var r = nbi();\n  this.divRemTo(a, null, r);\n  return r;\n}\n// (public) [this/a,this%a]\nfunction bnDivideAndRemainder(a)\n{\n  var q = nbi(),\n    r = nbi();\n  this.divRemTo(a, q, r);\n  return new Array(q, r);\n}\n// (protected) this *= n, this >= 0, 1 < n < DV\nfunction bnpDMultiply(n)\n{\n  this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);\n  ++this.t;\n  this.clamp();\n}\n// (protected) this += n << w words, this >= 0\nfunction bnpDAddOffset(n, w)\n{\n  if (n == 0) return;\n  while (this.t <= w) this[this.t++] = 0;\n  this[w] += n;\n  while (this[w] >= this.DV)\n  {\n    this[w] -= this.DV;\n    if (++w >= this.t) this[this.t++] = 0;\n    ++this[w];\n  }\n}\n// A \"null\" reducer\nfunction NullExp()\n{}\n\nfunction nNop(x)\n{\n  return x;\n}\n\nfunction nMulTo(x, y, r)\n{\n  x.multiplyTo(y, r);\n}\n\nfunction nSqrTo(x, r)\n{\n  x.squareTo(r);\n}\nNullExp.prototype.convert = nNop;\nNullExp.prototype.revert = nNop;\nNullExp.prototype.mulTo = nMulTo;\nNullExp.prototype.sqrTo = nSqrTo;\n// (public) this^e\nfunction bnPow(e)\n{\n  return this.exp(e, new NullExp());\n}\n// (protected) r = lower n words of \"this * a\", a.t <= n\n// \"this\" should be the larger one if appropriate.\nfunction bnpMultiplyLowerTo(a, n, r)\n{\n  var i = Math.min(this.t + a.t, n);\n  r.s = 0; // assumes a,this >= 0\n  r.t = i;\n  while (i > 0) r[--i] = 0;\n  var j;\n  for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);\n  for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);\n  r.clamp();\n}\n// (protected) r = \"this * a\" without lower n words, n > 0\n// \"this\" should be the larger one if appropriate.\nfunction bnpMultiplyUpperTo(a, n, r)\n{\n  --n;\n  var i = r.t = this.t + a.t - n;\n  r.s = 0; // assumes a,this >= 0\n  while (--i >= 0) r[i] = 0;\n  for (i = Math.max(n - this.t, 0); i < a.t; ++i)\n    r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);\n  r.clamp();\n  r.drShiftTo(1, r);\n}\n// Barrett modular reduction\nfunction Barrett(m)\n{\n  // setup Barrett\n  this.r2 = nbi();\n  this.q3 = nbi();\n  BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);\n  this.mu = this.r2.divide(m);\n  this.m = m;\n}\n\nfunction barrettConvert(x)\n{\n  if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);\n  else if (x.compareTo(this.m) < 0) return x;\n  else\n  {\n    var r = nbi();\n    x.copyTo(r);\n    this.reduce(r);\n    return r;\n  }\n}\n\nfunction barrettRevert(x)\n{\n  return x;\n}\n// x = x mod m (HAC 14.42)\nfunction barrettReduce(x)\n{\n  x.drShiftTo(this.m.t - 1, this.r2);\n  if (x.t > this.m.t + 1)\n  {\n    x.t = this.m.t + 1;\n    x.clamp();\n  }\n  this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);\n  this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);\n  while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);\n  x.subTo(this.r2, x);\n  while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n}\n// r = x^2 mod m; x != r\nfunction barrettSqrTo(x, r)\n{\n  x.squareTo(r);\n  this.reduce(r);\n}\n// r = x*y mod m; x,y != r\nfunction barrettMulTo(x, y, r)\n{\n  x.multiplyTo(y, r);\n  this.reduce(r);\n}\nBarrett.prototype.convert = barrettConvert;\nBarrett.prototype.revert = barrettRevert;\nBarrett.prototype.reduce = barrettReduce;\nBarrett.prototype.mulTo = barrettMulTo;\nBarrett.prototype.sqrTo = barrettSqrTo;\n// (public) this^e % m (HAC 14.85)\nfunction bnModPow(e, m)\n{\n  var i = e.bitLength(),\n    k, r = nbv(1),\n    z;\n  if (i <= 0) return r;\n  else if (i < 18) k = 1;\n  else if (i < 48) k = 3;\n  else if (i < 144) k = 4;\n  else if (i < 768) k = 5;\n  else k = 6;\n  if (i < 8)\n    z = new Classic(m);\n  else if (m.isEven())\n    z = new Barrett(m);\n  else\n    z = new Montgomery(m);\n  // precomputation\n  var g = new Array(),\n    n = 3,\n    k1 = k - 1,\n    km = (1 << k) - 1;\n  g[1] = z.convert(this);\n  if (k > 1)\n  {\n    var g2 = nbi();\n    z.sqrTo(g[1], g2);\n    while (n <= km)\n    {\n      g[n] = nbi();\n      z.mulTo(g2, g[n - 2], g[n]);\n      n += 2;\n    }\n  }\n  var j = e.t - 1,\n    w, is1 = true,\n    r2 = nbi(),\n    t;\n  i = nbits(e[j]) - 1;\n  while (j >= 0)\n  {\n    if (i >= k1) w = (e[j] >> (i - k1)) & km;\n    else\n    {\n      w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);\n      if (j > 0) w |= e[j - 1] >> (this.DB + i - k1);\n    }\n    n = k;\n    while ((w & 1) == 0)\n    {\n      w >>= 1;\n      --n;\n    }\n    if ((i -= n) < 0)\n    {\n      i += this.DB;\n      --j;\n    }\n    if (is1)\n    { // ret == 1, don't bother squaring or multiplying it\n      g[w].copyTo(r);\n      is1 = false;\n    }\n    else\n    {\n      while (n > 1)\n      {\n        z.sqrTo(r, r2);\n        z.sqrTo(r2, r);\n        n -= 2;\n      }\n      if (n > 0) z.sqrTo(r, r2);\n      else\n      {\n        t = r;\n        r = r2;\n        r2 = t;\n      }\n      z.mulTo(r2, g[w], r);\n    }\n    while (j >= 0 && (e[j] & (1 << i)) == 0)\n    {\n      z.sqrTo(r, r2);\n      t = r;\n      r = r2;\n      r2 = t;\n      if (--i < 0)\n      {\n        i = this.DB - 1;\n        --j;\n      }\n    }\n  }\n  return z.revert(r);\n}\n// (public) gcd(this,a) (HAC 14.54)\nfunction bnGCD(a)\n{\n  var x = (this.s < 0) ? this.negate() : this.clone();\n  var y = (a.s < 0) ? a.negate() : a.clone();\n  if (x.compareTo(y) < 0)\n  {\n    var t = x;\n    x = y;\n    y = t;\n  }\n  var i = x.getLowestSetBit(),\n    g = y.getLowestSetBit();\n  if (g < 0) return x;\n  if (i < g) g = i;\n  if (g > 0)\n  {\n    x.rShiftTo(g, x);\n    y.rShiftTo(g, y);\n  }\n  while (x.signum() > 0)\n  {\n    if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);\n    if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);\n    if (x.compareTo(y) >= 0)\n    {\n      x.subTo(y, x);\n      x.rShiftTo(1, x);\n    }\n    else\n    {\n      y.subTo(x, y);\n      y.rShiftTo(1, y);\n    }\n  }\n  if (g > 0) y.lShiftTo(g, y);\n  return y;\n}\n// (protected) this % n, n < 2^26\nfunction bnpModInt(n)\n{\n  if (n <= 0) return 0;\n  var d = this.DV % n,\n    r = (this.s < 0) ? n - 1 : 0;\n  if (this.t > 0)\n    if (d == 0) r = this[0] % n;\n    else\n      for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;\n  return r;\n}\n// (public) 1/this % m (HAC 14.61)\nfunction bnModInverse(m)\n{\n  var ac = m.isEven();\n  if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n  var u = m.clone(),\n    v = this.clone();\n  var a = nbv(1),\n    b = nbv(0),\n    c = nbv(0),\n    d = nbv(1);\n  while (u.signum() != 0)\n  {\n    while (u.isEven())\n    {\n      u.rShiftTo(1, u);\n      if (ac)\n      {\n        if (!a.isEven() || !b.isEven())\n        {\n          a.addTo(this, a);\n          b.subTo(m, b);\n        }\n        a.rShiftTo(1, a);\n      }\n      else if (!b.isEven()) b.subTo(m, b);\n      b.rShiftTo(1, b);\n    }\n    while (v.isEven())\n    {\n      v.rShiftTo(1, v);\n      if (ac)\n      {\n        if (!c.isEven() || !d.isEven())\n        {\n          c.addTo(this, c);\n          d.subTo(m, d);\n        }\n        c.rShiftTo(1, c);\n      }\n      else if (!d.isEven()) d.subTo(m, d);\n      d.rShiftTo(1, d);\n    }\n    if (u.compareTo(v) >= 0)\n    {\n      u.subTo(v, u);\n      if (ac) a.subTo(c, a);\n      b.subTo(d, b);\n    }\n    else\n    {\n      v.subTo(u, v);\n      if (ac) c.subTo(a, c);\n      d.subTo(b, d);\n    }\n  }\n  if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n  if (d.compareTo(m) >= 0) return d.subtract(m);\n  if (d.signum() < 0) d.addTo(m, d);\n  else return d;\n  if (d.signum() < 0) return d.add(m);\n  else return d;\n}\nvar lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];\nvar lplim = (1 << 26) / lowprimes[lowprimes.length - 1];\n// (public) test primality with certainty >= 1-.5^t\nfunction bnIsProbablePrime(t)\n{\n  var i, x = this.abs();\n  if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1])\n  {\n    for (i = 0; i < lowprimes.length; ++i)\n      if (x[0] == lowprimes[i]) return true;\n    return false;\n  }\n  if (x.isEven()) return false;\n  i = 1;\n  while (i < lowprimes.length)\n  {\n    var m = lowprimes[i],\n      j = i + 1;\n    while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n    m = x.modInt(m);\n    while (i < j)\n      if (m % lowprimes[i++] == 0) return false;\n  }\n  return x.millerRabin(t);\n}\n// (protected) true if probably prime (HAC 4.24, Miller-Rabin)\nfunction bnpMillerRabin(t)\n{\n  var n1 = this.subtract(BigInteger.ONE);\n  var k = n1.getLowestSetBit();\n  if (k <= 0) return false;\n  var r = n1.shiftRight(k);\n  t = (t + 1) >> 1;\n  if (t > lowprimes.length) t = lowprimes.length;\n  var a = nbi();\n  for (var i = 0; i < t; ++i)\n  {\n    //Pick bases at random, instead of starting at 2\n    a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);\n    var y = a.modPow(r, this);\n    if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0)\n    {\n      var j = 1;\n      while (j++ < k && y.compareTo(n1) != 0)\n      {\n        y = y.modPowInt(2, this);\n        if (y.compareTo(BigInteger.ONE) == 0) return false;\n      }\n      if (y.compareTo(n1) != 0) return false;\n    }\n  }\n  return true;\n}\n// protected\nBigInteger.prototype.chunkSize = bnpChunkSize;\nBigInteger.prototype.toRadix = bnpToRadix;\nBigInteger.prototype.fromRadix = bnpFromRadix;\nBigInteger.prototype.fromNumber = bnpFromNumber;\nBigInteger.prototype.bitwiseTo = bnpBitwiseTo;\nBigInteger.prototype.changeBit = bnpChangeBit;\nBigInteger.prototype.addTo = bnpAddTo;\nBigInteger.prototype.dMultiply = bnpDMultiply;\nBigInteger.prototype.dAddOffset = bnpDAddOffset;\nBigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\nBigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\nBigInteger.prototype.modInt = bnpModInt;\nBigInteger.prototype.millerRabin = bnpMillerRabin;\n// public\nBigInteger.prototype.clone = bnClone;\nBigInteger.prototype.intValue = bnIntValue;\nBigInteger.prototype.byteValue = bnByteValue;\nBigInteger.prototype.shortValue = bnShortValue;\nBigInteger.prototype.signum = bnSigNum;\nBigInteger.prototype.toByteArray = bnToByteArray;\nBigInteger.prototype.equals = bnEquals;\nBigInteger.prototype.min = bnMin;\nBigInteger.prototype.max = bnMax;\nBigInteger.prototype.and = bnAnd;\nBigInteger.prototype.or = bnOr;\nBigInteger.prototype.xor = bnXor;\nBigInteger.prototype.andNot = bnAndNot;\nBigInteger.prototype.not = bnNot;\nBigInteger.prototype.shiftLeft = bnShiftLeft;\nBigInteger.prototype.shiftRight = bnShiftRight;\nBigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\nBigInteger.prototype.bitCount = bnBitCount;\nBigInteger.prototype.testBit = bnTestBit;\nBigInteger.prototype.setBit = bnSetBit;\nBigInteger.prototype.clearBit = bnClearBit;\nBigInteger.prototype.flipBit = bnFlipBit;\nBigInteger.prototype.add = bnAdd;\nBigInteger.prototype.subtract = bnSubtract;\nBigInteger.prototype.multiply = bnMultiply;\nBigInteger.prototype.divide = bnDivide;\nBigInteger.prototype.remainder = bnRemainder;\nBigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\nBigInteger.prototype.modPow = bnModPow;\nBigInteger.prototype.modInverse = bnModInverse;\nBigInteger.prototype.pow = bnPow;\nBigInteger.prototype.gcd = bnGCD;\nBigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n// JSBN-specific extension\nBigInteger.prototype.square = bnSquare;\nvar Int128 = BigInteger;\n// BigInteger interfaces not implemented in jsbn:\n// BigInteger(int signum, byte[] magnitude)\n// double doubleValue()\n// float floatValue()\n// int hashCode()\n// long longValue()\n// static BigInteger valueOf(long val)\n// Helper functions to make BigInteger functions callable with two parameters\n// as in original C# Clipper\nInt128.prototype.IsNegative = function ()\n{\n  if (this.compareTo(Int128.ZERO) == -1) return true;\n  else return false;\n};\nInt128.op_Equality = function (val1, val2)\n{\n  if (val1.compareTo(val2) == 0) return true;\n  else return false;\n};\nInt128.op_Inequality = function (val1, val2)\n{\n  if (val1.compareTo(val2) != 0) return true;\n  else return false;\n};\nInt128.op_GreaterThan = function (val1, val2)\n{\n  if (val1.compareTo(val2) > 0) return true;\n  else return false;\n};\nInt128.op_LessThan = function (val1, val2)\n{\n  if (val1.compareTo(val2) < 0) return true;\n  else return false;\n};\nInt128.op_Addition = function (lhs, rhs)\n{\n  return new Int128(lhs).add(new Int128(rhs));\n};\nInt128.op_Subtraction = function (lhs, rhs)\n{\n  return new Int128(lhs).subtract(new Int128(rhs));\n};\nInt128.Int128Mul = function (lhs, rhs)\n{\n  return new Int128(lhs).multiply(new Int128(rhs));\n};\nInt128.op_Division = function (lhs, rhs)\n{\n  return lhs.divide(rhs);\n};\nInt128.prototype.ToDouble = function ()\n{\n  return parseFloat(this.toString()); // This could be something faster\n};\n// end of Int128 section\n/*\n// Uncomment the following two lines if you want to use Int128 outside ClipperLib\nif (typeof(document) !== \"undefined\") window.Int128 = Int128;\nelse self.Int128 = Int128;\n*/\n// ---------------------------------------------  \n// Here starts the actual Clipper library:\n// Helper function to support Inheritance in Javascript\nif (typeof (Inherit) == 'undefined')\n{\n  var Inherit = function (ce, ce2)\n  {\n    var p;\n    if (typeof (Object.getOwnPropertyNames) == 'undefined')\n    {\n      for (p in ce2.prototype)\n        if (typeof (ce.prototype[p]) == 'undefined' || ce.prototype[p] == Object.prototype[p]) ce.prototype[p] = ce2.prototype[p];\n      for (p in ce2)\n        if (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];\n      ce.$baseCtor = ce2;\n    }\n    else\n    {\n      var props = Object.getOwnPropertyNames(ce2.prototype);\n      for (var i = 0; i < props.length; i++)\n        if (typeof (Object.getOwnPropertyDescriptor(ce.prototype, props[i])) == 'undefined') Object.defineProperty(ce.prototype, props[i], Object.getOwnPropertyDescriptor(ce2.prototype, props[i]));\n      for (p in ce2)\n        if (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];\n      ce.$baseCtor = ce2;\n    }\n  };\n}\nClipperLib.Path = function ()\n{\n  return [];\n};\nClipperLib.Paths = function ()\n{\n  return []; // Was previously [[]], but caused problems when pushed\n};\n// Preserves the calling way of original C# Clipper\n// Is essential due to compatibility, because DoublePoint is public class in original C# version\nClipperLib.DoublePoint = function ()\n{\n  var a = arguments;\n  this.X = 0;\n  this.Y = 0;\n  // public DoublePoint(DoublePoint dp)\n  // public DoublePoint(IntPoint ip)\n  if (a.length == 1)\n  {\n    this.X = a[0].X;\n    this.Y = a[0].Y;\n  }\n  else if (a.length == 2)\n  {\n    this.X = a[0];\n    this.Y = a[1];\n  }\n}; // This is internal faster function when called without arguments\nClipperLib.DoublePoint0 = function ()\n{\n  this.X = 0;\n  this.Y = 0;\n};\n// This is internal faster function when called with 1 argument (dp or ip)\nClipperLib.DoublePoint1 = function (dp)\n{\n  this.X = dp.X;\n  this.Y = dp.Y;\n};\n// This is internal faster function when called with 2 arguments (x and y)\nClipperLib.DoublePoint2 = function (x, y)\n{\n  this.X = x;\n  this.Y = y;\n};\n// PolyTree & PolyNode start\n// -------------------------------\nClipperLib.PolyNode = function ()\n{\n  this.m_Parent = null;\n  this.m_polygon = new ClipperLib.Path();\n  this.m_Index = 0;\n  this.m_jointype = 0;\n  this.m_endtype = 0;\n  this.m_Childs = [];\n  this.IsOpen = false;\n};\nClipperLib.PolyNode.prototype.IsHoleNode = function ()\n{\n  var result = true;\n  var node = this.m_Parent;\n  while (node !== null)\n  {\n    result = !result;\n    node = node.m_Parent;\n  }\n  return result;\n};\nClipperLib.PolyNode.prototype.ChildCount = function ()\n{\n  return this.m_Childs.length;\n};\nClipperLib.PolyNode.prototype.Contour = function ()\n{\n  return this.m_polygon;\n};\nClipperLib.PolyNode.prototype.AddChild = function (Child)\n{\n  var cnt = this.m_Childs.length;\n  this.m_Childs.push(Child);\n  Child.m_Parent = this;\n  Child.m_Index = cnt;\n};\nClipperLib.PolyNode.prototype.GetNext = function ()\n{\n  if (this.m_Childs.length > 0)\n    return this.m_Childs[0];\n  else\n    return this.GetNextSiblingUp();\n};\nClipperLib.PolyNode.prototype.GetNextSiblingUp = function ()\n{\n  if (this.m_Parent === null)\n    return null;\n  else if (this.m_Index == this.m_Parent.m_Childs.length - 1)\n    return this.m_Parent.GetNextSiblingUp();\n  else\n    return this.m_Parent.m_Childs[this.m_Index + 1];\n};\nClipperLib.PolyNode.prototype.Childs = function ()\n{\n  return this.m_Childs;\n};\nClipperLib.PolyNode.prototype.Parent = function ()\n{\n  return this.m_Parent;\n};\nClipperLib.PolyNode.prototype.IsHole = function ()\n{\n  return this.IsHoleNode();\n};\n// PolyTree : PolyNode\nClipperLib.PolyTree = function ()\n{\n  this.m_AllPolys = [];\n  ClipperLib.PolyNode.call(this);\n};\nClipperLib.PolyTree.prototype.Clear = function ()\n{\n  for (var i = 0, ilen = this.m_AllPolys.length; i < ilen; i++)\n    this.m_AllPolys[i] = null;\n  this.m_AllPolys.length = 0;\n  this.m_Childs.length = 0;\n};\nClipperLib.PolyTree.prototype.GetFirst = function ()\n{\n  if (this.m_Childs.length > 0)\n    return this.m_Childs[0];\n  else\n    return null;\n};\nClipperLib.PolyTree.prototype.Total = function ()\n{\n  return this.m_AllPolys.length;\n};\nInherit(ClipperLib.PolyTree, ClipperLib.PolyNode);\n// -------------------------------\n// PolyTree & PolyNode end\nClipperLib.Math_Abs_Int64 = ClipperLib.Math_Abs_Int32 = ClipperLib.Math_Abs_Double = function (a)\n{\n  return Math.abs(a);\n};\nClipperLib.Math_Max_Int32_Int32 = function (a, b)\n{\n  return Math.max(a, b);\n};\n/*\n-----------------------------------\ncast_32 speedtest: http://jsperf.com/truncate-float-to-integer/2\n-----------------------------------\n*/\nif (browser.msie || browser.opera || browser.safari) ClipperLib.Cast_Int32 = function (a)\n{\n  return a | 0;\n};\nelse ClipperLib.Cast_Int32 = function (a)\n{ // eg. browser.chrome || browser.chromium || browser.firefox\n  return~~ a;\n};\n/*\n--------------------------\ncast_64 speedtests: http://jsperf.com/truncate-float-to-integer\nChrome: bitwise_not_floor\nFirefox17: toInteger (typeof test)\nIE9: bitwise_or_floor\nIE7 and IE8: to_parseint\nChromium: to_floor_or_ceil\nFirefox3: to_floor_or_ceil\nFirefox15: to_floor_or_ceil\nOpera: to_floor_or_ceil\nSafari: to_floor_or_ceil\n--------------------------\n*/\nif (browser.chrome) ClipperLib.Cast_Int64 = function (a)\n{\n  if (a < -2147483648 || a > 2147483647)\n    return a < 0 ? Math.ceil(a) : Math.floor(a);\n  else return~~ a;\n};\nelse if (browser.firefox && typeof (Number.toInteger) == \"function\") ClipperLib.Cast_Int64 = function (a)\n{\n  return Number.toInteger(a);\n};\nelse if (browser.msie7 || browser.msie8) ClipperLib.Cast_Int64 = function (a)\n{\n  return parseInt(a, 10);\n};\nelse if (browser.msie) ClipperLib.Cast_Int64 = function (a)\n{\n  if (a < -2147483648 || a > 2147483647)\n    return a < 0 ? Math.ceil(a) : Math.floor(a);\n  return a | 0;\n};\n// eg. browser.chromium || browser.firefox || browser.opera || browser.safari\nelse ClipperLib.Cast_Int64 = function (a)\n{\n  return a < 0 ? Math.ceil(a) : Math.floor(a);\n};\nClipperLib.Clear = function (a)\n{\n  a.length = 0;\n};\n//ClipperLib.MaxSteps = 64; // How many steps at maximum in arc in BuildArc() function\nClipperLib.PI = 3.141592653589793;\nClipperLib.PI2 = 2 * 3.141592653589793;\nClipperLib.IntPoint = function ()\n{\n  var a = arguments,\n    alen = a.length;\n  this.X = 0;\n  this.Y = 0;\n  if (use_xyz)\n  {\n    this.Z = 0;\n    if (alen == 3) // public IntPoint(cInt x, cInt y, cInt z = 0)\n    {\n      this.X = a[0];\n      this.Y = a[1];\n      this.Z = a[2];\n    }\n    else if (alen == 2) // public IntPoint(cInt x, cInt y)\n    {\n      this.X = a[0];\n      this.Y = a[1];\n      this.Z = 0;\n    }\n    else if (alen == 1)\n    {\n      if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n      {\n        var dp = a[0];\n        this.X = ClipperLib.Clipper.Round(dp.X);\n        this.Y = ClipperLib.Clipper.Round(dp.Y);\n        this.Z = 0;\n      }\n      else // public IntPoint(IntPoint pt)\n      {\n        var pt = a[0];\n        if (typeof (pt.Z) == \"undefined\") pt.Z = 0;\n        this.X = pt.X;\n        this.Y = pt.Y;\n        this.Z = pt.Z;\n      }\n    }\n    else // public IntPoint()\n    {\n      this.X = 0;\n      this.Y = 0;\n      this.Z = 0;\n    }\n  }\n  else // if (!use_xyz)\n  {\n    if (alen == 2) // public IntPoint(cInt X, cInt Y)\n    {\n      this.X = a[0];\n      this.Y = a[1];\n    }\n    else if (alen == 1)\n    {\n      if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n      {\n        var dp = a[0];\n        this.X = ClipperLib.Clipper.Round(dp.X);\n        this.Y = ClipperLib.Clipper.Round(dp.Y);\n      }\n      else // public IntPoint(IntPoint pt)\n      {\n        var pt = a[0];\n        this.X = pt.X;\n        this.Y = pt.Y;\n      }\n    }\n    else // public IntPoint(IntPoint pt)\n    {\n      this.X = 0;\n      this.Y = 0;\n    }\n  }\n};\nClipperLib.IntPoint.op_Equality = function (a, b)\n{\n  //return a == b;\n  return a.X == b.X && a.Y == b.Y;\n};\nClipperLib.IntPoint.op_Inequality = function (a, b)\n{\n  //return a != b;\n  return a.X != b.X || a.Y != b.Y;\n};\n/*\nClipperLib.IntPoint.prototype.Equals = function (obj)\n{\n  if (obj === null)\n      return false;\n  if (obj instanceof ClipperLib.IntPoint)\n  {\n      var a = Cast(obj, ClipperLib.IntPoint);\n      return (this.X == a.X) && (this.Y == a.Y);\n  }\n  else\n      return false;\n};\n*/\nif (use_xyz)\n{\n  ClipperLib.IntPoint0 = function ()\n  {\n    this.X = 0;\n    this.Y = 0;\n    this.Z = 0;\n  };\n  ClipperLib.IntPoint1 = function (pt)\n  {\n    this.X = pt.X;\n    this.Y = pt.Y;\n    this.Z = pt.Z;\n  };\n  ClipperLib.IntPoint1dp = function (dp)\n  {\n    this.X = ClipperLib.Clipper.Round(dp.X);\n    this.Y = ClipperLib.Clipper.Round(dp.Y);\n    this.Z = 0;\n  };\n  ClipperLib.IntPoint2 = function (x, y)\n  {\n    this.X = x;\n    this.Y = y;\n    this.Z = 0;\n  };\n  ClipperLib.IntPoint3 = function (x, y, z)\n  {\n    this.X = x;\n    this.Y = y;\n    this.Z = z;\n  };\n}\nelse // if (!use_xyz)\n{\n  ClipperLib.IntPoint0 = function ()\n  {\n    this.X = 0;\n    this.Y = 0;\n  };\n  ClipperLib.IntPoint1 = function (pt)\n  {\n    this.X = pt.X;\n    this.Y = pt.Y;\n  };\n  ClipperLib.IntPoint1dp = function (dp)\n  {\n    this.X = ClipperLib.Clipper.Round(dp.X);\n    this.Y = ClipperLib.Clipper.Round(dp.Y);\n  };\n  ClipperLib.IntPoint2 = function (x, y)\n  {\n    this.X = x;\n    this.Y = y;\n  };\n}\nClipperLib.IntRect = function ()\n{\n  var a = arguments,\n    alen = a.length;\n  if (alen == 4) // function (l, t, r, b)\n  {\n    this.left = a[0];\n    this.top = a[1];\n    this.right = a[2];\n    this.bottom = a[3];\n  }\n  else if (alen == 1) // function (ir)\n  {\n    this.left = ir.left;\n    this.top = ir.top;\n    this.right = ir.right;\n    this.bottom = ir.bottom;\n  }\n  else // function ()\n  {\n    this.left = 0;\n    this.top = 0;\n    this.right = 0;\n    this.bottom = 0;\n  }\n};\nClipperLib.IntRect0 = function ()\n{\n  this.left = 0;\n  this.top = 0;\n  this.right = 0;\n  this.bottom = 0;\n};\nClipperLib.IntRect1 = function (ir)\n{\n  this.left = ir.left;\n  this.top = ir.top;\n  this.right = ir.right;\n  this.bottom = ir.bottom;\n};\nClipperLib.IntRect4 = function (l, t, r, b)\n{\n  this.left = l;\n  this.top = t;\n  this.right = r;\n  this.bottom = b;\n};\nClipperLib.ClipType = {\n  ctIntersection: 0,\n  ctUnion: 1,\n  ctDifference: 2,\n  ctXor: 3\n};\nClipperLib.PolyType = {\n  ptSubject: 0,\n  ptClip: 1\n};\nClipperLib.PolyFillType = {\n  pftEvenOdd: 0,\n  pftNonZero: 1,\n  pftPositive: 2,\n  pftNegative: 3\n};\nClipperLib.JoinType = {\n  jtSquare: 0,\n  jtRound: 1,\n  jtMiter: 2\n};\nClipperLib.EndType = {\n  etOpenSquare: 0,\n  etOpenRound: 1,\n  etOpenButt: 2,\n  etClosedLine: 3,\n  etClosedPolygon: 4\n};\nif (use_deprecated)\n  ClipperLib.EndType_ = {\n    etSquare: 0,\n    etRound: 1,\n    etButt: 2,\n    etClosed: 3\n  };\nClipperLib.EdgeSide = {\n  esLeft: 0,\n  esRight: 1\n};\nClipperLib.Direction = {\n  dRightToLeft: 0,\n  dLeftToRight: 1\n};\nClipperLib.TEdge = function ()\n{\n  this.Bot = new ClipperLib.IntPoint();\n  this.Curr = new ClipperLib.IntPoint();\n  this.Top = new ClipperLib.IntPoint();\n  this.Delta = new ClipperLib.IntPoint();\n  this.Dx = 0;\n  this.PolyTyp = ClipperLib.PolyType.ptSubject;\n  this.Side = ClipperLib.EdgeSide.esLeft;\n  this.WindDelta = 0;\n  this.WindCnt = 0;\n  this.WindCnt2 = 0;\n  this.OutIdx = 0;\n  this.Next = null;\n  this.Prev = null;\n  this.NextInLML = null;\n  this.NextInAEL = null;\n  this.PrevInAEL = null;\n  this.NextInSEL = null;\n  this.PrevInSEL = null;\n};\nClipperLib.IntersectNode = function ()\n{\n  this.Edge1 = null;\n  this.Edge2 = null;\n  this.Pt = new ClipperLib.IntPoint();\n};\nClipperLib.MyIntersectNodeSort = function () {};\nClipperLib.MyIntersectNodeSort.Compare = function (node1, node2)\n{\n  return (node2.Pt.Y - node1.Pt.Y);\n};\nClipperLib.LocalMinima = function ()\n{\n  this.Y = 0;\n  this.LeftBound = null;\n  this.RightBound = null;\n  this.Next = null;\n};\nClipperLib.Scanbeam = function ()\n{\n  this.Y = 0;\n  this.Next = null;\n};\nClipperLib.OutRec = function ()\n{\n  this.Idx = 0;\n  this.IsHole = false;\n  this.IsOpen = false;\n  this.FirstLeft = null;\n  this.Pts = null;\n  this.BottomPt = null;\n  this.PolyNode = null;\n};\nClipperLib.OutPt = function ()\n{\n  this.Idx = 0;\n  this.Pt = new ClipperLib.IntPoint();\n  this.Next = null;\n  this.Prev = null;\n};\nClipperLib.Join = function ()\n{\n  this.OutPt1 = null;\n  this.OutPt2 = null;\n  this.OffPt = new ClipperLib.IntPoint();\n};\nClipperLib.ClipperBase = function ()\n{\n  this.m_MinimaList = null;\n  this.m_CurrentLM = null;\n  this.m_edges = new Array();\n  this.m_UseFullRange = false;\n  this.m_HasOpenPaths = false;\n  this.PreserveCollinear = false;\n  this.m_MinimaList = null;\n  this.m_CurrentLM = null;\n  this.m_UseFullRange = false;\n  this.m_HasOpenPaths = false;\n};\n// Ranges are in original C# too high for Javascript (in current state 2013 september):\n// protected const double horizontal = -3.4E+38;\n// internal const cInt loRange = 0x3FFFFFFF; // = 1073741823 = sqrt(2^63 -1)/2\n// internal const cInt hiRange = 0x3FFFFFFFFFFFFFFFL; // = 4611686018427387903 = sqrt(2^127 -1)/2\n// So had to adjust them to more suitable for Javascript.\n// If JS some day supports truly 64-bit integers, then these ranges can be as in C#\n// and biginteger library can be more simpler (as then 128bit can be represented as two 64bit numbers)\nClipperLib.ClipperBase.horizontal = -9007199254740992; //-2^53\nClipperLib.ClipperBase.Skip = -2;\nClipperLib.ClipperBase.Unassigned = -1;\nClipperLib.ClipperBase.tolerance = 1E-20;\nif (use_int32)\n{\n  ClipperLib.ClipperBase.loRange = 46340;\n  ClipperLib.ClipperBase.hiRange = 46340;\n}\nelse\n{\n  ClipperLib.ClipperBase.loRange = 47453132; // sqrt(2^53 -1)/2\n  ClipperLib.ClipperBase.hiRange = 4503599627370495; // sqrt(2^106 -1)/2\n}\nClipperLib.ClipperBase.near_zero = function (val)\n{\n  return (val > -ClipperLib.ClipperBase.tolerance) && (val < ClipperLib.ClipperBase.tolerance);\n};\nClipperLib.ClipperBase.IsHorizontal = function (e)\n{\n  return e.Delta.Y === 0;\n};\nClipperLib.ClipperBase.prototype.PointIsVertex = function (pt, pp)\n{\n  var pp2 = pp;\n  do {\n    if (ClipperLib.IntPoint.op_Equality(pp2.Pt, pt))\n      return true;\n    pp2 = pp2.Next;\n  }\n  while (pp2 != pp)\n  return false;\n};\nClipperLib.ClipperBase.prototype.PointOnLineSegment = function (pt, linePt1, linePt2, UseFullRange)\n{\n  if (UseFullRange)\n    return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) ||\n      ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) ||\n      (((pt.X > linePt1.X) == (pt.X < linePt2.X)) &&\n      ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) &&\n      (Int128.op_Equality(Int128.Int128Mul((pt.X - linePt1.X), (linePt2.Y - linePt1.Y)),\n        Int128.Int128Mul((linePt2.X - linePt1.X), (pt.Y - linePt1.Y)))));\n  else\n    return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) || ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) || (((pt.X > linePt1.X) == (pt.X < linePt2.X)) && ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) && ((pt.X - linePt1.X) * (linePt2.Y - linePt1.Y) == (linePt2.X - linePt1.X) * (pt.Y - linePt1.Y)));\n};\nClipperLib.ClipperBase.prototype.PointOnPolygon = function (pt, pp, UseFullRange)\n{\n  var pp2 = pp;\n  while (true)\n  {\n    if (this.PointOnLineSegment(pt, pp2.Pt, pp2.Next.Pt, UseFullRange))\n      return true;\n    pp2 = pp2.Next;\n    if (pp2 == pp)\n      break;\n  }\n  return false;\n};\nClipperLib.ClipperBase.prototype.SlopesEqual = ClipperLib.ClipperBase.SlopesEqual = function ()\n{\n  var a = arguments,\n    alen = a.length;\n  var e1, e2, pt1, pt2, pt3, pt4, UseFullRange;\n  if (alen == 3) // function (e1, e2, UseFullRange)\n  {\n    e1 = a[0];\n    e2 = a[1];\n    UseFullRange = a[2];\n    if (UseFullRange)\n      return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n    else\n      return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n  }\n  else if (alen == 4) // function (pt1, pt2, pt3, UseFullRange)\n  {\n    pt1 = a[0];\n    pt2 = a[1];\n    pt3 = a[2];\n    UseFullRange = a[3];\n    if (UseFullRange)\n      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n    else\n      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n  }\n  else // function (pt1, pt2, pt3, pt4, UseFullRange)\n  {\n    pt1 = a[0];\n    pt2 = a[1];\n    pt3 = a[2];\n    pt4 = a[3];\n    UseFullRange = a[4];\n    if (UseFullRange)\n      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n    else\n      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n  }\n};\nClipperLib.ClipperBase.SlopesEqual3 = function (e1, e2, UseFullRange)\n{\n  if (UseFullRange)\n    return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n  else\n    return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n};\nClipperLib.ClipperBase.SlopesEqual4 = function (pt1, pt2, pt3, UseFullRange)\n{\n  if (UseFullRange)\n    return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n  else\n    return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n};\nClipperLib.ClipperBase.SlopesEqual5 = function (pt1, pt2, pt3, pt4, UseFullRange)\n{\n  if (UseFullRange)\n    return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n  else\n    return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n};\nClipperLib.ClipperBase.prototype.Clear = function ()\n{\n  this.DisposeLocalMinimaList();\n  for (var i = 0, ilen = this.m_edges.length; i < ilen; ++i)\n  {\n    for (var j = 0, jlen = this.m_edges[i].length; j < jlen; ++j)\n      this.m_edges[i][j] = null;\n    ClipperLib.Clear(this.m_edges[i]);\n  }\n  ClipperLib.Clear(this.m_edges);\n  this.m_UseFullRange = false;\n  this.m_HasOpenPaths = false;\n};\nClipperLib.ClipperBase.prototype.DisposeLocalMinimaList = function ()\n{\n  while (this.m_MinimaList !== null)\n  {\n    var tmpLm = this.m_MinimaList.Next;\n    this.m_MinimaList = null;\n    this.m_MinimaList = tmpLm;\n  }\n  this.m_CurrentLM = null;\n};\nClipperLib.ClipperBase.prototype.RangeTest = function (Pt, useFullRange)\n{\n  if (useFullRange.Value)\n  {\n    if (Pt.X > ClipperLib.ClipperBase.hiRange || Pt.Y > ClipperLib.ClipperBase.hiRange || -Pt.X > ClipperLib.ClipperBase.hiRange || -Pt.Y > ClipperLib.ClipperBase.hiRange)\n      ClipperLib.Error(\"Coordinate outside allowed range in RangeTest().\");\n  }\n  else if (Pt.X > ClipperLib.ClipperBase.loRange || Pt.Y > ClipperLib.ClipperBase.loRange || -Pt.X > ClipperLib.ClipperBase.loRange || -Pt.Y > ClipperLib.ClipperBase.loRange)\n  {\n    useFullRange.Value = true;\n    this.RangeTest(Pt, useFullRange);\n  }\n};\nClipperLib.ClipperBase.prototype.InitEdge = function (e, eNext, ePrev, pt)\n{\n  e.Next = eNext;\n  e.Prev = ePrev;\n  //e.Curr = pt;\n  e.Curr.X = pt.X;\n  e.Curr.Y = pt.Y;\n  e.OutIdx = -1;\n};\nClipperLib.ClipperBase.prototype.InitEdge2 = function (e, polyType)\n{\n  if (e.Curr.Y >= e.Next.Curr.Y)\n  {\n    //e.Bot = e.Curr;\n    e.Bot.X = e.Curr.X;\n    e.Bot.Y = e.Curr.Y;\n    //e.Top = e.Next.Curr;\n    e.Top.X = e.Next.Curr.X;\n    e.Top.Y = e.Next.Curr.Y;\n  }\n  else\n  {\n    //e.Top = e.Curr;\n    e.Top.X = e.Curr.X;\n    e.Top.Y = e.Curr.Y;\n    //e.Bot = e.Next.Curr;\n    e.Bot.X = e.Next.Curr.X;\n    e.Bot.Y = e.Next.Curr.Y;\n  }\n  this.SetDx(e);\n  e.PolyTyp = polyType;\n};\nClipperLib.ClipperBase.prototype.FindNextLocMin = function (E)\n{\n  var E2;\n  for (;;)\n  {\n    while (ClipperLib.IntPoint.op_Inequality(E.Bot, E.Prev.Bot) || ClipperLib.IntPoint.op_Equality(E.Curr, E.Top))\n      E = E.Next;\n    if (E.Dx != ClipperLib.ClipperBase.horizontal && E.Prev.Dx != ClipperLib.ClipperBase.horizontal)\n      break;\n    while (E.Prev.Dx == ClipperLib.ClipperBase.horizontal)\n      E = E.Prev;\n    E2 = E;\n    while (E.Dx == ClipperLib.ClipperBase.horizontal)\n      E = E.Next;\n    if (E.Top.Y == E.Prev.Bot.Y)\n      continue;\n    //ie just an intermediate horz.\n    if (E2.Prev.Bot.X < E.Bot.X)\n      E = E2;\n    break;\n  }\n  return E;\n};\nClipperLib.ClipperBase.prototype.ProcessBound = function (E, IsClockwise)\n{\n  var EStart = E,\n    Result = E;\n  var Horz;\n  var StartX;\n  if (E.Dx == ClipperLib.ClipperBase.horizontal)\n  {\n    //it's possible for adjacent overlapping horz edges to start heading left\n    //before finishing right, so ...\n    if (IsClockwise)\n      StartX = E.Prev.Bot.X;\n    else\n      StartX = E.Next.Bot.X;\n    if (E.Bot.X != StartX)\n      this.ReverseHorizontal(E);\n  }\n  if (Result.OutIdx != ClipperLib.ClipperBase.Skip)\n  {\n    if (IsClockwise)\n    {\n      while (Result.Top.Y == Result.Next.Bot.Y && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n        Result = Result.Next;\n      if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n      {\n        //nb: at the top of a bound, horizontals are added to the bound\n        //only when the preceding edge attaches to the horizontal's left vertex\n        //unless a Skip edge is encountered when that becomes the top divide\n        Horz = Result;\n        while (Horz.Prev.Dx == ClipperLib.ClipperBase.horizontal)\n          Horz = Horz.Prev;\n        if (Horz.Prev.Top.X == Result.Next.Top.X)\n        {\n          if (!IsClockwise)\n            Result = Horz.Prev;\n        }\n        else if (Horz.Prev.Top.X > Result.Next.Top.X)\n          Result = Horz.Prev;\n      }\n      while (E != Result)\n      {\n        E.NextInLML = E.Next;\n        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)\n          this.ReverseHorizontal(E);\n        E = E.Next;\n      }\n      if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)\n        this.ReverseHorizontal(E);\n      Result = Result.Next;\n      //move to the edge just beyond current bound\n    }\n    else\n    {\n      while (Result.Top.Y == Result.Prev.Bot.Y && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)\n        Result = Result.Prev;\n      if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)\n      {\n        Horz = Result;\n        while (Horz.Next.Dx == ClipperLib.ClipperBase.horizontal)\n          Horz = Horz.Next;\n        if (Horz.Next.Top.X == Result.Prev.Top.X)\n        {\n          if (!IsClockwise)\n            Result = Horz.Next;\n        }\n        else if (Horz.Next.Top.X > Result.Prev.Top.X)\n          Result = Horz.Next;\n      }\n      while (E != Result)\n      {\n        E.NextInLML = E.Prev;\n        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)\n          this.ReverseHorizontal(E);\n        E = E.Prev;\n      }\n      if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)\n        this.ReverseHorizontal(E);\n      Result = Result.Prev;\n      //move to the edge just beyond current bound\n    }\n  }\n  if (Result.OutIdx == ClipperLib.ClipperBase.Skip)\n  {\n    //if edges still remain in the current bound beyond the skip edge then\n    //create another LocMin and call ProcessBound once more\n    E = Result;\n    if (IsClockwise)\n    {\n      while (E.Top.Y == E.Next.Bot.Y)\n        E = E.Next;\n      //don't include top horizontals when parsing a bound a second time,\n      //they will be contained in the opposite bound ...\n      while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal)\n        E = E.Prev;\n    }\n    else\n    {\n      while (E.Top.Y == E.Prev.Bot.Y)\n        E = E.Prev;\n      while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal)\n        E = E.Next;\n    }\n    if (E == Result)\n    {\n      if (IsClockwise)\n        Result = E.Next;\n      else\n        Result = E.Prev;\n    }\n    else\n    {\n      //there are more edges in the bound beyond result starting with E\n      if (IsClockwise)\n        E = Result.Next;\n      else\n        E = Result.Prev;\n      var locMin = new ClipperLib.LocalMinima();\n      locMin.Next = null;\n      locMin.Y = E.Bot.Y;\n      locMin.LeftBound = null;\n      locMin.RightBound = E;\n      locMin.RightBound.WindDelta = 0;\n      Result = this.ProcessBound(locMin.RightBound, IsClockwise);\n      this.InsertLocalMinima(locMin);\n    }\n  }\n  return Result;\n};\nClipperLib.ClipperBase.prototype.AddPath = function (pg, polyType, Closed)\n{\n  if (use_lines)\n  {\n    if (!Closed && polyType == ClipperLib.PolyType.ptClip)\n      ClipperLib.Error(\"AddPath: Open paths must be subject.\");\n  }\n  else\n  {\n    if (!Closed)\n      ClipperLib.Error(\"AddPath: Open paths have been disabled.\");\n  }\n  var highI = pg.length - 1;\n  if (Closed)\n    while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[0])))\n  --highI;\n  while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[highI - 1])))\n  --highI;\n  if ((Closed && highI < 2) || (!Closed && highI < 1))\n    return false;\n  //create a new edge array ...\n  var edges = new Array();\n  for (var i = 0; i <= highI; i++)\n    edges.push(new ClipperLib.TEdge());\n  var IsFlat = true;\n  //1. Basic (first) edge initialization ...\n\n  //edges[1].Curr = pg[1];\n  edges[1].Curr.X = pg[1].X;\n  edges[1].Curr.Y = pg[1].Y;\n\n  var $1 = {Value: this.m_UseFullRange};\n  this.RangeTest(pg[0], $1);\n  this.m_UseFullRange = $1.Value;\n\n  $1.Value = this.m_UseFullRange;\n  this.RangeTest(pg[highI], $1);\n  this.m_UseFullRange = $1.Value;\n\n  this.InitEdge(edges[0], edges[1], edges[highI], pg[0]);\n  this.InitEdge(edges[highI], edges[0], edges[highI - 1], pg[highI]);\n  for (var i = highI - 1; i >= 1; --i)\n  {\n    $1.Value = this.m_UseFullRange;\n    this.RangeTest(pg[i], $1);\n    this.m_UseFullRange = $1.Value;\n\n    this.InitEdge(edges[i], edges[i + 1], edges[i - 1], pg[i]);\n  }\n\n  var eStart = edges[0];\n  //2. Remove duplicate vertices, and (when closed) collinear edges ...\n  var E = eStart,\n    eLoopStop = eStart;\n  for (;;)\n  {\n    if (ClipperLib.IntPoint.op_Equality(E.Curr, E.Next.Curr))\n    {\n      if (E == E.Next)\n        break;\n      if (E == eStart)\n        eStart = E.Next;\n      E = this.RemoveEdge(E);\n      eLoopStop = E;\n      continue;\n    }\n    if (E.Prev == E.Next)\n      break;\n    else if (Closed && ClipperLib.ClipperBase.SlopesEqual(E.Prev.Curr, E.Curr, E.Next.Curr, this.m_UseFullRange) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(E.Prev.Curr, E.Curr, E.Next.Curr)))\n    {\n      //Collinear edges are allowed for open paths but in closed paths\n      //the default is to merge adjacent collinear edges into a single edge.\n      //However, if the PreserveCollinear property is enabled, only overlapping\n      //collinear edges (ie spikes) will be removed from closed paths.\n      if (E == eStart)\n        eStart = E.Next;\n      E = this.RemoveEdge(E);\n      E = E.Prev;\n      eLoopStop = E;\n      continue;\n    }\n    E = E.Next;\n    if (E == eLoopStop)\n      break;\n  }\n  if ((!Closed && (E == E.Next)) || (Closed && (E.Prev == E.Next)))\n    return false;\n  if (!Closed)\n  {\n    this.m_HasOpenPaths = true;\n    eStart.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n  }\n  //3. Do second stage of edge initialization ...\n  var eHighest = eStart;\n  E = eStart;\n  do {\n    this.InitEdge2(E, polyType);\n    E = E.Next;\n    if (IsFlat && E.Curr.Y != eStart.Curr.Y)\n      IsFlat = false;\n  }\n  while (E != eStart)\n  //4. Finally, add edge bounds to LocalMinima list ...\n  //Totally flat paths must be handled differently when adding them\n  //to LocalMinima list to avoid endless loops etc ...\n  if (IsFlat)\n  {\n    if (Closed)\n      return false;\n    E.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n    if (E.Prev.Bot.X < E.Prev.Top.X)\n      this.ReverseHorizontal(E.Prev);\n    var locMin = new ClipperLib.LocalMinima();\n    locMin.Next = null;\n    locMin.Y = E.Bot.Y;\n    locMin.LeftBound = null;\n    locMin.RightBound = E;\n    locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n    locMin.RightBound.WindDelta = 0;\n    while (E.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n    {\n      E.NextInLML = E.Next;\n      if (E.Bot.X != E.Prev.Top.X)\n        this.ReverseHorizontal(E);\n      E = E.Next;\n    }\n    this.InsertLocalMinima(locMin);\n    this.m_edges.push(edges);\n    return true;\n  }\n  this.m_edges.push(edges);\n  var clockwise;\n  var EMin = null;\n  for (;;)\n  {\n    E = this.FindNextLocMin(E);\n    if (E == EMin)\n      break;\n    else if (EMin == null)\n      EMin = E;\n    //E and E.Prev now share a local minima (left aligned if horizontal).\n    //Compare their slopes to find which starts which bound ...\n    var locMin = new ClipperLib.LocalMinima();\n    locMin.Next = null;\n    locMin.Y = E.Bot.Y;\n    if (E.Dx < E.Prev.Dx)\n    {\n      locMin.LeftBound = E.Prev;\n      locMin.RightBound = E;\n      clockwise = false;\n      //Q.nextInLML = Q.prev\n    }\n    else\n    {\n      locMin.LeftBound = E;\n      locMin.RightBound = E.Prev;\n      clockwise = true;\n      //Q.nextInLML = Q.next\n    }\n    locMin.LeftBound.Side = ClipperLib.EdgeSide.esLeft;\n    locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n    if (!Closed)\n      locMin.LeftBound.WindDelta = 0;\n    else if (locMin.LeftBound.Next == locMin.RightBound)\n      locMin.LeftBound.WindDelta = -1;\n    else\n      locMin.LeftBound.WindDelta = 1;\n    locMin.RightBound.WindDelta = -locMin.LeftBound.WindDelta;\n    E = this.ProcessBound(locMin.LeftBound, clockwise);\n    var E2 = this.ProcessBound(locMin.RightBound, !clockwise);\n    if (locMin.LeftBound.OutIdx == ClipperLib.ClipperBase.Skip)\n      locMin.LeftBound = null;\n    else if (locMin.RightBound.OutIdx == ClipperLib.ClipperBase.Skip)\n      locMin.RightBound = null;\n    this.InsertLocalMinima(locMin);\n    if (!clockwise)\n      E = E2;\n  }\n  return true;\n};\nClipperLib.ClipperBase.prototype.AddPaths = function (ppg, polyType, closed)\n{\n  //  console.log(\"-------------------------------------------\");\n  //  console.log(JSON.stringify(ppg));\n  var result = false;\n  for (var i = 0, ilen = ppg.length; i < ilen; ++i)\n    if (this.AddPath(ppg[i], polyType, closed))\n      result = true;\n  return result;\n};\n//------------------------------------------------------------------------------\nClipperLib.ClipperBase.prototype.Pt2IsBetweenPt1AndPt3 = function (pt1, pt2, pt3)\n{\n  if ((ClipperLib.IntPoint.op_Equality(pt1, pt3)) || (ClipperLib.IntPoint.op_Equality(pt1, pt2)) ||\n    (ClipperLib.IntPoint.op_Equality(pt3, pt2)))\n    return false;\n  else if (pt1.X != pt3.X)\n    return (pt2.X > pt1.X) == (pt2.X < pt3.X);\n  else\n    return (pt2.Y > pt1.Y) == (pt2.Y < pt3.Y);\n};\nClipperLib.ClipperBase.prototype.RemoveEdge = function (e)\n{\n  //removes e from double_linked_list (but without removing from memory)\n  e.Prev.Next = e.Next;\n  e.Next.Prev = e.Prev;\n  var result = e.Next;\n  e.Prev = null; //flag as removed (see ClipperBase.Clear)\n  return result;\n};\nClipperLib.ClipperBase.prototype.SetDx = function (e)\n{\n  e.Delta.X = (e.Top.X - e.Bot.X);\n  e.Delta.Y = (e.Top.Y - e.Bot.Y);\n  if (e.Delta.Y === 0) e.Dx = ClipperLib.ClipperBase.horizontal;\n  else e.Dx = (e.Delta.X) / (e.Delta.Y);\n};\nClipperLib.ClipperBase.prototype.InsertLocalMinima = function (newLm)\n{\n  if (this.m_MinimaList === null)\n  {\n    this.m_MinimaList = newLm;\n  }\n  else if (newLm.Y >= this.m_MinimaList.Y)\n  {\n    newLm.Next = this.m_MinimaList;\n    this.m_MinimaList = newLm;\n  }\n  else\n  {\n    var tmpLm = this.m_MinimaList;\n    while (tmpLm.Next !== null && (newLm.Y < tmpLm.Next.Y))\n      tmpLm = tmpLm.Next;\n    newLm.Next = tmpLm.Next;\n    tmpLm.Next = newLm;\n  }\n};\nClipperLib.ClipperBase.prototype.PopLocalMinima = function ()\n{\n  if (this.m_CurrentLM === null)\n    return;\n  this.m_CurrentLM = this.m_CurrentLM.Next;\n};\nClipperLib.ClipperBase.prototype.ReverseHorizontal = function (e)\n{\n  //swap horizontal edges' top and bottom x's so they follow the natural\n  //progression of the bounds - ie so their xbots will align with the\n  //adjoining lower edge. [Helpful in the ProcessHorizontal() method.]\n  var tmp = e.Top.X;\n  e.Top.X = e.Bot.X;\n  e.Bot.X = tmp;\n  if (use_xyz)\n  {\n    tmp = e.Top.Z;\n    e.Top.Z = e.Bot.Z;\n    e.Bot.Z = tmp;\n  }\n};\nClipperLib.ClipperBase.prototype.Reset = function ()\n{\n  this.m_CurrentLM = this.m_MinimaList;\n  if (this.m_CurrentLM == null)\n    return;\n  //ie nothing to process\n  //reset all edges ...\n  var lm = this.m_MinimaList;\n  while (lm != null)\n  {\n    var e = lm.LeftBound;\n    if (e != null)\n    {\n      //e.Curr = e.Bot;\n      e.Curr.X = e.Bot.X;\n      e.Curr.Y = e.Bot.Y;\n      e.Side = ClipperLib.EdgeSide.esLeft;\n      e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n    }\n    e = lm.RightBound;\n    if (e != null)\n    {\n      //e.Curr = e.Bot;\n      e.Curr.X = e.Bot.X;\n      e.Curr.Y = e.Bot.Y;\n      e.Side = ClipperLib.EdgeSide.esRight;\n      e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n    }\n    lm = lm.Next;\n  }\n};\nClipperLib.Clipper = function (InitOptions) // public Clipper(int InitOptions = 0)\n{\n  if (typeof (InitOptions) == \"undefined\") InitOptions = 0;\n  this.m_PolyOuts = null;\n  this.m_ClipType = ClipperLib.ClipType.ctIntersection;\n  this.m_Scanbeam = null;\n  this.m_ActiveEdges = null;\n  this.m_SortedEdges = null;\n  this.m_IntersectList = null;\n  this.m_IntersectNodeComparer = null;\n  this.m_ExecuteLocked = false;\n  this.m_ClipFillType = ClipperLib.PolyFillType.pftEvenOdd;\n  this.m_SubjFillType = ClipperLib.PolyFillType.pftEvenOdd;\n  this.m_Joins = null;\n  this.m_GhostJoins = null;\n  this.m_UsingPolyTree = false;\n  this.ReverseSolution = false;\n  this.StrictlySimple = false;\n  ClipperLib.ClipperBase.call(this);\n  this.m_Scanbeam = null;\n  this.m_ActiveEdges = null;\n  this.m_SortedEdges = null;\n  this.m_IntersectList = new Array();\n  this.m_IntersectNodeComparer = ClipperLib.MyIntersectNodeSort.Compare;\n  this.m_ExecuteLocked = false;\n  this.m_UsingPolyTree = false;\n  this.m_PolyOuts = new Array();\n  this.m_Joins = new Array();\n  this.m_GhostJoins = new Array();\n  this.ReverseSolution = (1 & InitOptions) !== 0;\n  this.StrictlySimple = (2 & InitOptions) !== 0;\n  this.PreserveCollinear = (4 & InitOptions) !== 0;\n  if (use_xyz)\n  {\n    this.ZFillFunction = null; // function (IntPoint vert1, IntPoint vert2, ref IntPoint intersectPt);\n  }\n};\nClipperLib.Clipper.ioReverseSolution = 1;\nClipperLib.Clipper.ioStrictlySimple = 2;\nClipperLib.Clipper.ioPreserveCollinear = 4;\n\nClipperLib.Clipper.prototype.Clear = function ()\n{\n  if (this.m_edges.length === 0)\n    return;\n  //avoids problems with ClipperBase destructor\n  this.DisposeAllPolyPts();\n  ClipperLib.ClipperBase.prototype.Clear.call(this);\n};\n\nClipperLib.Clipper.prototype.DisposeScanbeamList = function ()\n{\n  while (this.m_Scanbeam !== null)\n  {\n    var sb2 = this.m_Scanbeam.Next;\n    this.m_Scanbeam = null;\n    this.m_Scanbeam = sb2;\n  }\n};\nClipperLib.Clipper.prototype.Reset = function ()\n{\n  ClipperLib.ClipperBase.prototype.Reset.call(this);\n  this.m_Scanbeam = null;\n  this.m_ActiveEdges = null;\n  this.m_SortedEdges = null;\n\n  var lm = this.m_MinimaList;\n  while (lm !== null)\n  {\n    this.InsertScanbeam(lm.Y);\n    lm = lm.Next;\n  }\n};\nClipperLib.Clipper.prototype.InsertScanbeam = function (Y)\n{\n  if (this.m_Scanbeam === null)\n  {\n    this.m_Scanbeam = new ClipperLib.Scanbeam();\n    this.m_Scanbeam.Next = null;\n    this.m_Scanbeam.Y = Y;\n  }\n  else if (Y > this.m_Scanbeam.Y)\n  {\n    var newSb = new ClipperLib.Scanbeam();\n    newSb.Y = Y;\n    newSb.Next = this.m_Scanbeam;\n    this.m_Scanbeam = newSb;\n  }\n  else\n  {\n    var sb2 = this.m_Scanbeam;\n    while (sb2.Next !== null && (Y <= sb2.Next.Y))\n      sb2 = sb2.Next;\n    if (Y == sb2.Y)\n      return;\n    //ie ignores duplicates\n    var newSb = new ClipperLib.Scanbeam();\n    newSb.Y = Y;\n    newSb.Next = sb2.Next;\n    sb2.Next = newSb;\n  }\n};\n// ************************************\nClipperLib.Clipper.prototype.Execute = function ()\n{\n  var a = arguments,\n    alen = a.length,\n    ispolytree = a[1] instanceof ClipperLib.PolyTree;\n  if (alen == 4 && !ispolytree) // function (clipType, solution, subjFillType, clipFillType)\n  {\n    var clipType = a[0],\n      solution = a[1],\n      subjFillType = a[2],\n      clipFillType = a[3];\n    if (this.m_ExecuteLocked)\n      return false;\n    if (this.m_HasOpenPaths)\n      ClipperLib.Error(\"Error: PolyTree struct is need for open path clipping.\");\n    this.m_ExecuteLocked = true;\n    ClipperLib.Clear(solution);\n    this.m_SubjFillType = subjFillType;\n    this.m_ClipFillType = clipFillType;\n    this.m_ClipType = clipType;\n    this.m_UsingPolyTree = false;\n    try\n    {\n      var succeeded = this.ExecuteInternal();\n      //build the return polygons ...\n      if (succeeded) this.BuildResult(solution);\n    }\n    finally\n    {\n      this.DisposeAllPolyPts();\n      this.m_ExecuteLocked = false;\n    }\n    return succeeded;\n  }\n  else if (alen == 4 && ispolytree) // function (clipType, polytree, subjFillType, clipFillType)\n  {\n    var clipType = a[0],\n      polytree = a[1],\n      subjFillType = a[2],\n      clipFillType = a[3];\n    if (this.m_ExecuteLocked)\n      return false;\n    this.m_ExecuteLocked = true;\n    this.m_SubjFillType = subjFillType;\n    this.m_ClipFillType = clipFillType;\n    this.m_ClipType = clipType;\n    this.m_UsingPolyTree = true;\n    try\n    {\n      var succeeded = this.ExecuteInternal();\n      //build the return polygons ...\n      if (succeeded) this.BuildResult2(polytree);\n    }\n    finally\n    {\n      this.DisposeAllPolyPts();\n      this.m_ExecuteLocked = false;\n    }\n    return succeeded;\n  }\n  else if (alen == 2 && !ispolytree) // function (clipType, solution)\n  {\n    var clipType = a[0],\n      solution = a[1];\n    return this.Execute(clipType, solution, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n  }\n  else if (alen == 2 && ispolytree) // function (clipType, polytree)\n  {\n    var clipType = a[0],\n      polytree = a[1];\n    return this.Execute(clipType, polytree, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n  }\n};\nClipperLib.Clipper.prototype.FixHoleLinkage = function (outRec)\n{\n  //skip if an outermost polygon or\n  //already already points to the correct FirstLeft ...\n  if (outRec.FirstLeft === null || (outRec.IsHole != outRec.FirstLeft.IsHole && outRec.FirstLeft.Pts !== null))\n    return;\n  var orfl = outRec.FirstLeft;\n  while (orfl !== null && ((orfl.IsHole == outRec.IsHole) || orfl.Pts === null))\n    orfl = orfl.FirstLeft;\n  outRec.FirstLeft = orfl;\n};\nClipperLib.Clipper.prototype.ExecuteInternal = function ()\n{\n  try\n  {\n    this.Reset();\n    if (this.m_CurrentLM === null)\n      return false;\n    var botY = this.PopScanbeam();\n    do {\n      this.InsertLocalMinimaIntoAEL(botY);\n      ClipperLib.Clear(this.m_GhostJoins);\n      this.ProcessHorizontals(false);\n      if (this.m_Scanbeam === null)\n        break;\n      var topY = this.PopScanbeam();\n      //console.log(\"botY:\" + botY + \", topY:\" + topY);\n      if (!this.ProcessIntersections(botY, topY))\n        return false;\n      this.ProcessEdgesAtTopOfScanbeam(topY);\n      botY = topY;\n    }\n    while (this.m_Scanbeam !== null || this.m_CurrentLM !== null)\n    //fix orientations ...\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n      var outRec = this.m_PolyOuts[i];\n      if (outRec.Pts === null || outRec.IsOpen)\n        continue;\n      if ((outRec.IsHole ^ this.ReverseSolution) == (this.Area(outRec) > 0))\n        this.ReversePolyPtLinks(outRec.Pts);\n    }\n    this.JoinCommonEdges();\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n      var outRec = this.m_PolyOuts[i];\n      if (outRec.Pts !== null && !outRec.IsOpen)\n        this.FixupOutPolygon(outRec);\n    }\n    if (this.StrictlySimple)\n      this.DoSimplePolygons();\n    return true;\n  }\n  finally\n  {\n    ClipperLib.Clear(this.m_Joins);\n    ClipperLib.Clear(this.m_GhostJoins);\n  }\n};\nClipperLib.Clipper.prototype.PopScanbeam = function ()\n{\n  var Y = this.m_Scanbeam.Y;\n  var sb2 = this.m_Scanbeam;\n  this.m_Scanbeam = this.m_Scanbeam.Next;\n  sb2 = null;\n  return Y;\n};\nClipperLib.Clipper.prototype.DisposeAllPolyPts = function ()\n{\n  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; ++i)\n    this.DisposeOutRec(i);\n  ClipperLib.Clear(this.m_PolyOuts);\n};\nClipperLib.Clipper.prototype.DisposeOutRec = function (index)\n{\n  var outRec = this.m_PolyOuts[index];\n  if (outRec.Pts !== null)\n    this.DisposeOutPts(outRec.Pts);\n  outRec = null;\n  this.m_PolyOuts[index] = null;\n};\nClipperLib.Clipper.prototype.DisposeOutPts = function (pp)\n{\n  if (pp === null)\n    return;\n  var tmpPp = null;\n  pp.Prev.Next = null;\n  while (pp !== null)\n  {\n    tmpPp = pp;\n    pp = pp.Next;\n    tmpPp = null;\n  }\n};\nClipperLib.Clipper.prototype.AddJoin = function (Op1, Op2, OffPt)\n{\n  var j = new ClipperLib.Join();\n  j.OutPt1 = Op1;\n  j.OutPt2 = Op2;\n  //j.OffPt = OffPt;\n  j.OffPt.X = OffPt.X;\n  j.OffPt.Y = OffPt.Y;\n  this.m_Joins.push(j);\n};\nClipperLib.Clipper.prototype.AddGhostJoin = function (Op, OffPt)\n{\n  var j = new ClipperLib.Join();\n  j.OutPt1 = Op;\n  //j.OffPt = OffPt;\n  j.OffPt.X = OffPt.X;\n  j.OffPt.Y = OffPt.Y;\n  this.m_GhostJoins.push(j);\n};\nif (use_xyz)\n{\n  ClipperLib.Clipper.prototype.SetZ = function (pt, e)\n  {\n    pt.Z = 0;\n    if (this.ZFillFunction !== null)\n    {\n      //put the 'preferred' point as first parameter ...\n      if (e.OutIdx < 0)\n        this.ZFillFunction(e.Bot, e.Top, pt); //outside a path so presume entering\n      else\n        this.ZFillFunction(e.Top, e.Bot, pt); //inside a path so presume exiting\n    }\n  };\n  //------------------------------------------------------------------------------\n}\nClipperLib.Clipper.prototype.InsertLocalMinimaIntoAEL = function (botY)\n{\n  while (this.m_CurrentLM !== null && (this.m_CurrentLM.Y == botY))\n  {\n    var lb = this.m_CurrentLM.LeftBound;\n    var rb = this.m_CurrentLM.RightBound;\n    this.PopLocalMinima();\n    var Op1 = null;\n    if (lb === null)\n    {\n      this.InsertEdgeIntoAEL(rb, null);\n      this.SetWindingCount(rb);\n      if (this.IsContributing(rb))\n        Op1 = this.AddOutPt(rb, rb.Bot);\n    }\n    else if (rb == null)\n    {\n      this.InsertEdgeIntoAEL(lb, null);\n      this.SetWindingCount(lb);\n      if (this.IsContributing(lb))\n        Op1 = this.AddOutPt(lb, lb.Bot);\n      this.InsertScanbeam(lb.Top.Y);\n    }\n    else\n    {\n      this.InsertEdgeIntoAEL(lb, null);\n      this.InsertEdgeIntoAEL(rb, lb);\n      this.SetWindingCount(lb);\n      rb.WindCnt = lb.WindCnt;\n      rb.WindCnt2 = lb.WindCnt2;\n      if (this.IsContributing(lb))\n        Op1 = this.AddLocalMinPoly(lb, rb, lb.Bot);\n      this.InsertScanbeam(lb.Top.Y);\n    }\n    if (rb != null)\n    {\n      if (ClipperLib.ClipperBase.IsHorizontal(rb))\n        this.AddEdgeToSEL(rb);\n      else\n        this.InsertScanbeam(rb.Top.Y);\n    }\n    if (lb == null || rb == null) continue;\n    //if output polygons share an Edge with a horizontal rb, they'll need joining later ...\n    if (Op1 !== null && ClipperLib.ClipperBase.IsHorizontal(rb) && this.m_GhostJoins.length > 0 && rb.WindDelta !== 0)\n    {\n      for (var i = 0, ilen = this.m_GhostJoins.length; i < ilen; i++)\n      {\n        //if the horizontal Rb and a 'ghost' horizontal overlap, then convert\n        //the 'ghost' join to a real join ready for later ...\n        var j = this.m_GhostJoins[i];\n        if (this.HorzSegmentsOverlap(j.OutPt1.Pt, j.OffPt, rb.Bot, rb.Top))\n          this.AddJoin(j.OutPt1, Op1, j.OffPt);\n      }\n    }\n    if (lb.OutIdx >= 0 && lb.PrevInAEL !== null &&\n      lb.PrevInAEL.Curr.X == lb.Bot.X &&\n      lb.PrevInAEL.OutIdx >= 0 &&\n      ClipperLib.ClipperBase.SlopesEqual(lb.PrevInAEL, lb, this.m_UseFullRange) &&\n      lb.WindDelta !== 0 && lb.PrevInAEL.WindDelta !== 0)\n    {\n      var Op2 = this.AddOutPt(lb.PrevInAEL, lb.Bot);\n      this.AddJoin(Op1, Op2, lb.Top);\n    }\n    if (lb.NextInAEL != rb)\n    {\n      if (rb.OutIdx >= 0 && rb.PrevInAEL.OutIdx >= 0 &&\n        ClipperLib.ClipperBase.SlopesEqual(rb.PrevInAEL, rb, this.m_UseFullRange) &&\n        rb.WindDelta !== 0 && rb.PrevInAEL.WindDelta !== 0)\n      {\n        var Op2 = this.AddOutPt(rb.PrevInAEL, rb.Bot);\n        this.AddJoin(Op1, Op2, rb.Top);\n      }\n      var e = lb.NextInAEL;\n      if (e !== null)\n        while (e != rb)\n        {\n          //nb: For calculating winding counts etc, IntersectEdges() assumes\n          //that param1 will be to the right of param2 ABOVE the intersection ...\n          this.IntersectEdges(rb, e, lb.Curr, false);\n          //order important here\n          e = e.NextInAEL;\n        }\n    }\n  }\n};\nClipperLib.Clipper.prototype.InsertEdgeIntoAEL = function (edge, startEdge)\n{\n  if (this.m_ActiveEdges === null)\n  {\n    edge.PrevInAEL = null;\n    edge.NextInAEL = null;\n    this.m_ActiveEdges = edge;\n  }\n  else if (startEdge === null && this.E2InsertsBeforeE1(this.m_ActiveEdges, edge))\n  {\n    edge.PrevInAEL = null;\n    edge.NextInAEL = this.m_ActiveEdges;\n    this.m_ActiveEdges.PrevInAEL = edge;\n    this.m_ActiveEdges = edge;\n  }\n  else\n  {\n    if (startEdge === null)\n      startEdge = this.m_ActiveEdges;\n    while (startEdge.NextInAEL !== null && !this.E2InsertsBeforeE1(startEdge.NextInAEL, edge))\n      startEdge = startEdge.NextInAEL;\n    edge.NextInAEL = startEdge.NextInAEL;\n    if (startEdge.NextInAEL !== null)\n      startEdge.NextInAEL.PrevInAEL = edge;\n    edge.PrevInAEL = startEdge;\n    startEdge.NextInAEL = edge;\n  }\n};\nClipperLib.Clipper.prototype.E2InsertsBeforeE1 = function (e1, e2)\n{\n  if (e2.Curr.X == e1.Curr.X)\n  {\n    if (e2.Top.Y > e1.Top.Y)\n      return e2.Top.X < ClipperLib.Clipper.TopX(e1, e2.Top.Y);\n    else\n      return e1.Top.X > ClipperLib.Clipper.TopX(e2, e1.Top.Y);\n  }\n  else\n    return e2.Curr.X < e1.Curr.X;\n};\nClipperLib.Clipper.prototype.IsEvenOddFillType = function (edge)\n{\n  if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n    return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n  else\n    return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n};\nClipperLib.Clipper.prototype.IsEvenOddAltFillType = function (edge)\n{\n  if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n    return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n  else\n    return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n};\nClipperLib.Clipper.prototype.IsContributing = function (edge)\n{\n  var pft, pft2;\n  if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n  {\n    pft = this.m_SubjFillType;\n    pft2 = this.m_ClipFillType;\n  }\n  else\n  {\n    pft = this.m_ClipFillType;\n    pft2 = this.m_SubjFillType;\n  }\n  switch (pft)\n  {\n  case ClipperLib.PolyFillType.pftEvenOdd:\n    if (edge.WindDelta === 0 && edge.WindCnt != 1)\n      return false;\n    break;\n  case ClipperLib.PolyFillType.pftNonZero:\n    if (Math.abs(edge.WindCnt) != 1)\n      return false;\n    break;\n  case ClipperLib.PolyFillType.pftPositive:\n    if (edge.WindCnt != 1)\n      return false;\n    break;\n  default:\n    if (edge.WindCnt != -1)\n      return false;\n    break;\n  }\n  switch (this.m_ClipType)\n  {\n  case ClipperLib.ClipType.ctIntersection:\n    switch (pft2)\n    {\n    case ClipperLib.PolyFillType.pftEvenOdd:\n    case ClipperLib.PolyFillType.pftNonZero:\n      return (edge.WindCnt2 !== 0);\n    case ClipperLib.PolyFillType.pftPositive:\n      return (edge.WindCnt2 > 0);\n    default:\n      return (edge.WindCnt2 < 0);\n    }\n  case ClipperLib.ClipType.ctUnion:\n    switch (pft2)\n    {\n    case ClipperLib.PolyFillType.pftEvenOdd:\n    case ClipperLib.PolyFillType.pftNonZero:\n      return (edge.WindCnt2 === 0);\n    case ClipperLib.PolyFillType.pftPositive:\n      return (edge.WindCnt2 <= 0);\n    default:\n      return (edge.WindCnt2 >= 0);\n    }\n  case ClipperLib.ClipType.ctDifference:\n    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n      switch (pft2)\n      {\n      case ClipperLib.PolyFillType.pftEvenOdd:\n      case ClipperLib.PolyFillType.pftNonZero:\n        return (edge.WindCnt2 === 0);\n      case ClipperLib.PolyFillType.pftPositive:\n        return (edge.WindCnt2 <= 0);\n      default:\n        return (edge.WindCnt2 >= 0);\n      }\n    else\n      switch (pft2)\n      {\n      case ClipperLib.PolyFillType.pftEvenOdd:\n      case ClipperLib.PolyFillType.pftNonZero:\n        return (edge.WindCnt2 !== 0);\n      case ClipperLib.PolyFillType.pftPositive:\n        return (edge.WindCnt2 > 0);\n      default:\n        return (edge.WindCnt2 < 0);\n      }\n  case ClipperLib.ClipType.ctXor:\n    if (edge.WindDelta === 0)\n      switch (pft2)\n      {\n      case ClipperLib.PolyFillType.pftEvenOdd:\n      case ClipperLib.PolyFillType.pftNonZero:\n        return (edge.WindCnt2 === 0);\n      case ClipperLib.PolyFillType.pftPositive:\n        return (edge.WindCnt2 <= 0);\n      default:\n        return (edge.WindCnt2 >= 0);\n      }\n    else\n      return true;\n  }\n  return true;\n};\nClipperLib.Clipper.prototype.SetWindingCount = function (edge)\n{\n  var e = edge.PrevInAEL;\n  //find the edge of the same polytype that immediately preceeds 'edge' in AEL\n  while (e !== null && ((e.PolyTyp != edge.PolyTyp) || (e.WindDelta === 0)))\n    e = e.PrevInAEL;\n  if (e === null)\n  {\n    edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n    edge.WindCnt2 = 0;\n    e = this.m_ActiveEdges;\n    //ie get ready to calc WindCnt2\n  }\n  else if (edge.WindDelta === 0 && this.m_ClipType != ClipperLib.ClipType.ctUnion)\n  {\n    edge.WindCnt = 1;\n    edge.WindCnt2 = e.WindCnt2;\n    e = e.NextInAEL;\n    //ie get ready to calc WindCnt2\n  }\n  else if (this.IsEvenOddFillType(edge))\n  {\n    //EvenOdd filling ...\n    if (edge.WindDelta === 0)\n    {\n      //are we inside a subj polygon ...\n      var Inside = true;\n      var e2 = e.PrevInAEL;\n      while (e2 !== null)\n      {\n        if (e2.PolyTyp == e.PolyTyp && e2.WindDelta !== 0)\n          Inside = !Inside;\n        e2 = e2.PrevInAEL;\n      }\n      edge.WindCnt = (Inside ? 0 : 1);\n    }\n    else\n    {\n      edge.WindCnt = edge.WindDelta;\n    }\n    edge.WindCnt2 = e.WindCnt2;\n    e = e.NextInAEL;\n    //ie get ready to calc WindCnt2\n  }\n  else\n  {\n    //nonZero, Positive or Negative filling ...\n    if (e.WindCnt * e.WindDelta < 0)\n    {\n      //prev edge is 'decreasing' WindCount (WC) toward zero\n      //so we're outside the previous polygon ...\n      if (Math.abs(e.WindCnt) > 1)\n      {\n        //outside prev poly but still inside another.\n        //when reversing direction of prev poly use the same WC \n        if (e.WindDelta * edge.WindDelta < 0)\n          edge.WindCnt = e.WindCnt;\n        else\n          edge.WindCnt = e.WindCnt + edge.WindDelta;\n      }\n      else\n        edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n    }\n    else\n    {\n      //prev edge is 'increasing' WindCount (WC) away from zero\n      //so we're inside the previous polygon ...\n      if (edge.WindDelta === 0)\n        edge.WindCnt = (e.WindCnt < 0 ? e.WindCnt - 1 : e.WindCnt + 1);\n      else if (e.WindDelta * edge.WindDelta < 0)\n        edge.WindCnt = e.WindCnt;\n      else\n        edge.WindCnt = e.WindCnt + edge.WindDelta;\n    }\n    edge.WindCnt2 = e.WindCnt2;\n    e = e.NextInAEL;\n    //ie get ready to calc WindCnt2\n  }\n  //update WindCnt2 ...\n  if (this.IsEvenOddAltFillType(edge))\n  {\n    //EvenOdd filling ...\n    while (e != edge)\n    {\n      if (e.WindDelta !== 0)\n        edge.WindCnt2 = (edge.WindCnt2 === 0 ? 1 : 0);\n      e = e.NextInAEL;\n    }\n  }\n  else\n  {\n    //nonZero, Positive or Negative filling ...\n    while (e != edge)\n    {\n      edge.WindCnt2 += e.WindDelta;\n      e = e.NextInAEL;\n    }\n  }\n};\nClipperLib.Clipper.prototype.AddEdgeToSEL = function (edge)\n{\n  //SEL pointers in PEdge are reused to build a list of horizontal edges.\n  //However, we don't need to worry about order with horizontal edge processing.\n  if (this.m_SortedEdges === null)\n  {\n    this.m_SortedEdges = edge;\n    edge.PrevInSEL = null;\n    edge.NextInSEL = null;\n  }\n  else\n  {\n    edge.NextInSEL = this.m_SortedEdges;\n    edge.PrevInSEL = null;\n    this.m_SortedEdges.PrevInSEL = edge;\n    this.m_SortedEdges = edge;\n  }\n};\nClipperLib.Clipper.prototype.CopyAELToSEL = function ()\n{\n  var e = this.m_ActiveEdges;\n  this.m_SortedEdges = e;\n  while (e !== null)\n  {\n    e.PrevInSEL = e.PrevInAEL;\n    e.NextInSEL = e.NextInAEL;\n    e = e.NextInAEL;\n  }\n};\nClipperLib.Clipper.prototype.SwapPositionsInAEL = function (edge1, edge2)\n{\n  //check that one or other edge hasn't already been removed from AEL ...\n  if (edge1.NextInAEL == edge1.PrevInAEL || edge2.NextInAEL == edge2.PrevInAEL)\n    return;\n  if (edge1.NextInAEL == edge2)\n  {\n    var next = edge2.NextInAEL;\n    if (next !== null)\n      next.PrevInAEL = edge1;\n    var prev = edge1.PrevInAEL;\n    if (prev !== null)\n      prev.NextInAEL = edge2;\n    edge2.PrevInAEL = prev;\n    edge2.NextInAEL = edge1;\n    edge1.PrevInAEL = edge2;\n    edge1.NextInAEL = next;\n  }\n  else if (edge2.NextInAEL == edge1)\n  {\n    var next = edge1.NextInAEL;\n    if (next !== null)\n      next.PrevInAEL = edge2;\n    var prev = edge2.PrevInAEL;\n    if (prev !== null)\n      prev.NextInAEL = edge1;\n    edge1.PrevInAEL = prev;\n    edge1.NextInAEL = edge2;\n    edge2.PrevInAEL = edge1;\n    edge2.NextInAEL = next;\n  }\n  else\n  {\n    var next = edge1.NextInAEL;\n    var prev = edge1.PrevInAEL;\n    edge1.NextInAEL = edge2.NextInAEL;\n    if (edge1.NextInAEL !== null)\n      edge1.NextInAEL.PrevInAEL = edge1;\n    edge1.PrevInAEL = edge2.PrevInAEL;\n    if (edge1.PrevInAEL !== null)\n      edge1.PrevInAEL.NextInAEL = edge1;\n    edge2.NextInAEL = next;\n    if (edge2.NextInAEL !== null)\n      edge2.NextInAEL.PrevInAEL = edge2;\n    edge2.PrevInAEL = prev;\n    if (edge2.PrevInAEL !== null)\n      edge2.PrevInAEL.NextInAEL = edge2;\n  }\n  if (edge1.PrevInAEL === null)\n    this.m_ActiveEdges = edge1;\n  else if (edge2.PrevInAEL === null)\n    this.m_ActiveEdges = edge2;\n};\nClipperLib.Clipper.prototype.SwapPositionsInSEL = function (edge1, edge2)\n{\n  if (edge1.NextInSEL === null && edge1.PrevInSEL === null)\n    return;\n  if (edge2.NextInSEL === null && edge2.PrevInSEL === null)\n    return;\n  if (edge1.NextInSEL == edge2)\n  {\n    var next = edge2.NextInSEL;\n    if (next !== null)\n      next.PrevInSEL = edge1;\n    var prev = edge1.PrevInSEL;\n    if (prev !== null)\n      prev.NextInSEL = edge2;\n    edge2.PrevInSEL = prev;\n    edge2.NextInSEL = edge1;\n    edge1.PrevInSEL = edge2;\n    edge1.NextInSEL = next;\n  }\n  else if (edge2.NextInSEL == edge1)\n  {\n    var next = edge1.NextInSEL;\n    if (next !== null)\n      next.PrevInSEL = edge2;\n    var prev = edge2.PrevInSEL;\n    if (prev !== null)\n      prev.NextInSEL = edge1;\n    edge1.PrevInSEL = prev;\n    edge1.NextInSEL = edge2;\n    edge2.PrevInSEL = edge1;\n    edge2.NextInSEL = next;\n  }\n  else\n  {\n    var next = edge1.NextInSEL;\n    var prev = edge1.PrevInSEL;\n    edge1.NextInSEL = edge2.NextInSEL;\n    if (edge1.NextInSEL !== null)\n      edge1.NextInSEL.PrevInSEL = edge1;\n    edge1.PrevInSEL = edge2.PrevInSEL;\n    if (edge1.PrevInSEL !== null)\n      edge1.PrevInSEL.NextInSEL = edge1;\n    edge2.NextInSEL = next;\n    if (edge2.NextInSEL !== null)\n      edge2.NextInSEL.PrevInSEL = edge2;\n    edge2.PrevInSEL = prev;\n    if (edge2.PrevInSEL !== null)\n      edge2.PrevInSEL.NextInSEL = edge2;\n  }\n  if (edge1.PrevInSEL === null)\n    this.m_SortedEdges = edge1;\n  else if (edge2.PrevInSEL === null)\n    this.m_SortedEdges = edge2;\n};\nClipperLib.Clipper.prototype.AddLocalMaxPoly = function (e1, e2, pt)\n{\n  this.AddOutPt(e1, pt);\n  if (e2.WindDelta == 0) this.AddOutPt(e2, pt);\n  if (e1.OutIdx == e2.OutIdx)\n  {\n    e1.OutIdx = -1;\n    e2.OutIdx = -1;\n  }\n  else if (e1.OutIdx < e2.OutIdx)\n    this.AppendPolygon(e1, e2);\n  else\n    this.AppendPolygon(e2, e1);\n};\nClipperLib.Clipper.prototype.AddLocalMinPoly = function (e1, e2, pt)\n{\n  var result;\n  var e, prevE;\n  if (ClipperLib.ClipperBase.IsHorizontal(e2) || (e1.Dx > e2.Dx))\n  {\n    result = this.AddOutPt(e1, pt);\n    e2.OutIdx = e1.OutIdx;\n    e1.Side = ClipperLib.EdgeSide.esLeft;\n    e2.Side = ClipperLib.EdgeSide.esRight;\n    e = e1;\n    if (e.PrevInAEL == e2)\n      prevE = e2.PrevInAEL;\n    else\n      prevE = e.PrevInAEL;\n  }\n  else\n  {\n    result = this.AddOutPt(e2, pt);\n    e1.OutIdx = e2.OutIdx;\n    e1.Side = ClipperLib.EdgeSide.esRight;\n    e2.Side = ClipperLib.EdgeSide.esLeft;\n    e = e2;\n    if (e.PrevInAEL == e1)\n      prevE = e1.PrevInAEL;\n    else\n      prevE = e.PrevInAEL;\n  }\n  if (prevE !== null && prevE.OutIdx >= 0 && (ClipperLib.Clipper.TopX(prevE, pt.Y) == ClipperLib.Clipper.TopX(e, pt.Y)) && ClipperLib.ClipperBase.SlopesEqual(e, prevE, this.m_UseFullRange) && (e.WindDelta !== 0) && (prevE.WindDelta !== 0))\n  {\n    var outPt = this.AddOutPt(prevE, pt);\n    this.AddJoin(result, outPt, e.Top);\n  }\n  return result;\n};\nClipperLib.Clipper.prototype.CreateOutRec = function ()\n{\n  var result = new ClipperLib.OutRec();\n  result.Idx = -1;\n  result.IsHole = false;\n  result.IsOpen = false;\n  result.FirstLeft = null;\n  result.Pts = null;\n  result.BottomPt = null;\n  result.PolyNode = null;\n  this.m_PolyOuts.push(result);\n  result.Idx = this.m_PolyOuts.length - 1;\n  return result;\n};\nClipperLib.Clipper.prototype.AddOutPt = function (e, pt)\n{\n  var ToFront = (e.Side == ClipperLib.EdgeSide.esLeft);\n  if (e.OutIdx < 0)\n  {\n    var outRec = this.CreateOutRec();\n    outRec.IsOpen = (e.WindDelta === 0);\n    var newOp = new ClipperLib.OutPt();\n    outRec.Pts = newOp;\n    newOp.Idx = outRec.Idx;\n    //newOp.Pt = pt;\n    newOp.Pt.X = pt.X;\n    newOp.Pt.Y = pt.Y;\n    newOp.Next = newOp;\n    newOp.Prev = newOp;\n    if (!outRec.IsOpen)\n      this.SetHoleState(e, outRec);\n    if (use_xyz)\n    {\n      if (ClipperLib.IntPoint.op_Equality(pt, e.Bot))\n      {\n        //newOp.Pt = e.Bot;\n        newOp.Pt.X = e.Bot.X;\n        newOp.Pt.Y = e.Bot.Y;\n        newOp.Pt.Z = e.Bot.Z;\n      }\n      else if (ClipperLib.IntPoint.op_Equality(pt, e.Top))\n      {\n        //newOp.Pt = e.Top;\n        newOp.Pt.X = e.Top.X;\n        newOp.Pt.Y = e.Top.Y;\n        newOp.Pt.Z = e.Top.Z;\n      }\n      else\n        this.SetZ(newOp.Pt, e);\n    }\n    e.OutIdx = outRec.Idx;\n    //nb: do this after SetZ !\n    return newOp;\n  }\n  else\n  {\n    var outRec = this.m_PolyOuts[e.OutIdx];\n    //OutRec.Pts is the 'Left-most' point & OutRec.Pts.Prev is the 'Right-most'\n    var op = outRec.Pts;\n    if (ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Pt))\n      return op;\n    else if (!ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Prev.Pt))\n      return op.Prev;\n    var newOp = new ClipperLib.OutPt();\n    newOp.Idx = outRec.Idx;\n    //newOp.Pt = pt;\n    newOp.Pt.X = pt.X;\n    newOp.Pt.Y = pt.Y;\n    newOp.Next = op;\n    newOp.Prev = op.Prev;\n    newOp.Prev.Next = newOp;\n    op.Prev = newOp;\n    if (ToFront)\n      outRec.Pts = newOp;\n    if (use_xyz)\n    {\n      if (ClipperLib.IntPoint.op_Equality(pt, e.Bot))\n      {\n        //newOp.Pt = e.Bot;\n        newOp.Pt.X = e.Bot.X;\n        newOp.Pt.Y = e.Bot.Y;\n        newOp.Pt.Z = e.Bot.Z;\n      }\n      else if (ClipperLib.IntPoint.op_Equality(pt, e.Top))\n      {\n        //newOp.Pt = e.Top;\n        newOp.Pt.X = e.Top.X;\n        newOp.Pt.Y = e.Top.Y;\n        newOp.Pt.Z = e.Top.Z;\n      }\n      else\n        this.SetZ(newOp.Pt, e);\n    }\n    return newOp;\n  }\n};\nClipperLib.Clipper.prototype.SwapPoints = function (pt1, pt2)\n{\n  var tmp = new ClipperLib.IntPoint(pt1.Value);\n  //pt1.Value = pt2.Value;\n  pt1.Value.X = pt2.Value.X;\n  pt1.Value.Y = pt2.Value.Y;\n  //pt2.Value = tmp;\n  pt2.Value.X = tmp.X;\n  pt2.Value.Y = tmp.Y;\n};\nClipperLib.Clipper.prototype.HorzSegmentsOverlap = function (Pt1a, Pt1b, Pt2a, Pt2b)\n{\n  //precondition: both segments are horizontal\n  if ((Pt1a.X > Pt2a.X) == (Pt1a.X < Pt2b.X))\n    return true;\n  else if ((Pt1b.X > Pt2a.X) == (Pt1b.X < Pt2b.X))\n    return true;\n  else if ((Pt2a.X > Pt1a.X) == (Pt2a.X < Pt1b.X))\n    return true;\n  else if ((Pt2b.X > Pt1a.X) == (Pt2b.X < Pt1b.X))\n    return true;\n  else if ((Pt1a.X == Pt2a.X) && (Pt1b.X == Pt2b.X))\n    return true;\n  else if ((Pt1a.X == Pt2b.X) && (Pt1b.X == Pt2a.X))\n    return true;\n  else\n    return false;\n};\nClipperLib.Clipper.prototype.InsertPolyPtBetween = function (p1, p2, pt)\n{\n  var result = new ClipperLib.OutPt();\n  //result.Pt = pt;\n  result.Pt.X = pt.X;\n  result.Pt.Y = pt.Y;\n  if (p2 == p1.Next)\n  {\n    p1.Next = result;\n    p2.Prev = result;\n    result.Next = p2;\n    result.Prev = p1;\n  }\n  else\n  {\n    p2.Next = result;\n    p1.Prev = result;\n    result.Next = p1;\n    result.Prev = p2;\n  }\n  return result;\n};\nClipperLib.Clipper.prototype.SetHoleState = function (e, outRec)\n{\n  var isHole = false;\n  var e2 = e.PrevInAEL;\n  while (e2 !== null)\n  {\n    if (e2.OutIdx >= 0 && e2.WindDelta != 0)\n    {\n      isHole = !isHole;\n      if (outRec.FirstLeft === null)\n        outRec.FirstLeft = this.m_PolyOuts[e2.OutIdx];\n    }\n    e2 = e2.PrevInAEL;\n  }\n  if (isHole)\n    outRec.IsHole = true;\n};\nClipperLib.Clipper.prototype.GetDx = function (pt1, pt2)\n{\n  if (pt1.Y == pt2.Y)\n    return ClipperLib.ClipperBase.horizontal;\n  else\n    return (pt2.X - pt1.X) / (pt2.Y - pt1.Y);\n};\nClipperLib.Clipper.prototype.FirstIsBottomPt = function (btmPt1, btmPt2)\n{\n  var p = btmPt1.Prev;\n  while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))\n    p = p.Prev;\n  var dx1p = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n  p = btmPt1.Next;\n  while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))\n    p = p.Next;\n  var dx1n = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n  p = btmPt2.Prev;\n  while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))\n    p = p.Prev;\n  var dx2p = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n  p = btmPt2.Next;\n  while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))\n    p = p.Next;\n  var dx2n = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n  return (dx1p >= dx2p && dx1p >= dx2n) || (dx1n >= dx2p && dx1n >= dx2n);\n};\nClipperLib.Clipper.prototype.GetBottomPt = function (pp)\n{\n  var dups = null;\n  var p = pp.Next;\n  while (p != pp)\n  {\n    if (p.Pt.Y > pp.Pt.Y)\n    {\n      pp = p;\n      dups = null;\n    }\n    else if (p.Pt.Y == pp.Pt.Y && p.Pt.X <= pp.Pt.X)\n    {\n      if (p.Pt.X < pp.Pt.X)\n      {\n        dups = null;\n        pp = p;\n      }\n      else\n      {\n        if (p.Next != pp && p.Prev != pp)\n          dups = p;\n      }\n    }\n    p = p.Next;\n  }\n  if (dups !== null)\n  {\n    //there appears to be at least 2 vertices at bottomPt so ...\n    while (dups != p)\n    {\n      if (!this.FirstIsBottomPt(p, dups))\n        pp = dups;\n      dups = dups.Next;\n      while (ClipperLib.IntPoint.op_Inequality(dups.Pt, pp.Pt))\n        dups = dups.Next;\n    }\n  }\n  return pp;\n};\nClipperLib.Clipper.prototype.GetLowermostRec = function (outRec1, outRec2)\n{\n  //work out which polygon fragment has the correct hole state ...\n  if (outRec1.BottomPt === null)\n    outRec1.BottomPt = this.GetBottomPt(outRec1.Pts);\n  if (outRec2.BottomPt === null)\n    outRec2.BottomPt = this.GetBottomPt(outRec2.Pts);\n  var bPt1 = outRec1.BottomPt;\n  var bPt2 = outRec2.BottomPt;\n  if (bPt1.Pt.Y > bPt2.Pt.Y)\n    return outRec1;\n  else if (bPt1.Pt.Y < bPt2.Pt.Y)\n    return outRec2;\n  else if (bPt1.Pt.X < bPt2.Pt.X)\n    return outRec1;\n  else if (bPt1.Pt.X > bPt2.Pt.X)\n    return outRec2;\n  else if (bPt1.Next == bPt1)\n    return outRec2;\n  else if (bPt2.Next == bPt2)\n    return outRec1;\n  else if (this.FirstIsBottomPt(bPt1, bPt2))\n    return outRec1;\n  else\n    return outRec2;\n};\nClipperLib.Clipper.prototype.Param1RightOfParam2 = function (outRec1, outRec2)\n{\n  do {\n    outRec1 = outRec1.FirstLeft;\n    if (outRec1 == outRec2)\n      return true;\n  }\n  while (outRec1 !== null)\n  return false;\n};\nClipperLib.Clipper.prototype.GetOutRec = function (idx)\n{\n  var outrec = this.m_PolyOuts[idx];\n  while (outrec != this.m_PolyOuts[outrec.Idx])\n    outrec = this.m_PolyOuts[outrec.Idx];\n  return outrec;\n};\nClipperLib.Clipper.prototype.AppendPolygon = function (e1, e2)\n{\n  //get the start and ends of both output polygons ...\n  var outRec1 = this.m_PolyOuts[e1.OutIdx];\n  var outRec2 = this.m_PolyOuts[e2.OutIdx];\n  var holeStateRec;\n  if (this.Param1RightOfParam2(outRec1, outRec2))\n    holeStateRec = outRec2;\n  else if (this.Param1RightOfParam2(outRec2, outRec1))\n    holeStateRec = outRec1;\n  else\n    holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n  var p1_lft = outRec1.Pts;\n  var p1_rt = p1_lft.Prev;\n  var p2_lft = outRec2.Pts;\n  var p2_rt = p2_lft.Prev;\n  var side;\n  //join e2 poly onto e1 poly and delete pointers to e2 ...\n  if (e1.Side == ClipperLib.EdgeSide.esLeft)\n  {\n    if (e2.Side == ClipperLib.EdgeSide.esLeft)\n    {\n      //z y x a b c\n      this.ReversePolyPtLinks(p2_lft);\n      p2_lft.Next = p1_lft;\n      p1_lft.Prev = p2_lft;\n      p1_rt.Next = p2_rt;\n      p2_rt.Prev = p1_rt;\n      outRec1.Pts = p2_rt;\n    }\n    else\n    {\n      //x y z a b c\n      p2_rt.Next = p1_lft;\n      p1_lft.Prev = p2_rt;\n      p2_lft.Prev = p1_rt;\n      p1_rt.Next = p2_lft;\n      outRec1.Pts = p2_lft;\n    }\n    side = ClipperLib.EdgeSide.esLeft;\n  }\n  else\n  {\n    if (e2.Side == ClipperLib.EdgeSide.esRight)\n    {\n      //a b c z y x\n      this.ReversePolyPtLinks(p2_lft);\n      p1_rt.Next = p2_rt;\n      p2_rt.Prev = p1_rt;\n      p2_lft.Next = p1_lft;\n      p1_lft.Prev = p2_lft;\n    }\n    else\n    {\n      //a b c x y z\n      p1_rt.Next = p2_lft;\n      p2_lft.Prev = p1_rt;\n      p1_lft.Prev = p2_rt;\n      p2_rt.Next = p1_lft;\n    }\n    side = ClipperLib.EdgeSide.esRight;\n  }\n  outRec1.BottomPt = null;\n  if (holeStateRec == outRec2)\n  {\n    if (outRec2.FirstLeft != outRec1)\n      outRec1.FirstLeft = outRec2.FirstLeft;\n    outRec1.IsHole = outRec2.IsHole;\n  }\n  outRec2.Pts = null;\n  outRec2.BottomPt = null;\n  outRec2.FirstLeft = outRec1;\n  var OKIdx = e1.OutIdx;\n  var ObsoleteIdx = e2.OutIdx;\n  e1.OutIdx = -1;\n  //nb: safe because we only get here via AddLocalMaxPoly\n  e2.OutIdx = -1;\n  var e = this.m_ActiveEdges;\n  while (e !== null)\n  {\n    if (e.OutIdx == ObsoleteIdx)\n    {\n      e.OutIdx = OKIdx;\n      e.Side = side;\n      break;\n    }\n    e = e.NextInAEL;\n  }\n  outRec2.Idx = outRec1.Idx;\n};\nClipperLib.Clipper.prototype.ReversePolyPtLinks = function (pp)\n{\n  if (pp === null)\n    return;\n  var pp1;\n  var pp2;\n  pp1 = pp;\n  do {\n    pp2 = pp1.Next;\n    pp1.Next = pp1.Prev;\n    pp1.Prev = pp2;\n    pp1 = pp2;\n  }\n  while (pp1 != pp)\n};\nClipperLib.Clipper.SwapSides = function (edge1, edge2)\n{\n  var side = edge1.Side;\n  edge1.Side = edge2.Side;\n  edge2.Side = side;\n};\nClipperLib.Clipper.SwapPolyIndexes = function (edge1, edge2)\n{\n  var outIdx = edge1.OutIdx;\n  edge1.OutIdx = edge2.OutIdx;\n  edge2.OutIdx = outIdx;\n};\nClipperLib.Clipper.prototype.IntersectEdges = function (e1, e2, pt, protect)\n{\n  //e1 will be to the left of e2 BELOW the intersection. Therefore e1 is before\n  //e2 in AEL except when e1 is being inserted at the intersection point ...\n  var e1stops = !protect && e1.NextInLML === null &&\n    e1.Top.X == pt.X && e1.Top.Y == pt.Y;\n  var e2stops = !protect && e2.NextInLML === null &&\n    e2.Top.X == pt.X && e2.Top.Y == pt.Y;\n  var e1Contributing = (e1.OutIdx >= 0);\n  var e2Contributing = (e2.OutIdx >= 0);\n  if (use_lines)\n  {\n    //if either edge is on an OPEN path ...\n    if (e1.WindDelta === 0 || e2.WindDelta === 0)\n    {\n      //ignore subject-subject open path intersections UNLESS they\n      //are both open paths, AND they are both 'contributing maximas' ...\n      if (e1.WindDelta === 0 && e2.WindDelta === 0)\n      {\n        if ((e1stops || e2stops) && e1Contributing && e2Contributing)\n          this.AddLocalMaxPoly(e1, e2, pt);\n      }\n      //if intersecting a subj line with a subj poly ...\n      else if (e1.PolyTyp == e2.PolyTyp &&\n        e1.WindDelta != e2.WindDelta && this.m_ClipType == ClipperLib.ClipType.ctUnion)\n      {\n        if (e1.WindDelta === 0)\n        {\n          if (e2Contributing)\n          {\n            this.AddOutPt(e1, pt);\n            if (e1Contributing)\n              e1.OutIdx = -1;\n          }\n        }\n        else\n        {\n          if (e1Contributing)\n          {\n            this.AddOutPt(e2, pt);\n            if (e2Contributing)\n              e2.OutIdx = -1;\n          }\n        }\n      }\n      else if (e1.PolyTyp != e2.PolyTyp)\n      {\n        if ((e1.WindDelta === 0) && Math.abs(e2.WindCnt) == 1 &&\n          (this.m_ClipType != ClipperLib.ClipType.ctUnion || e2.WindCnt2 === 0))\n        {\n          this.AddOutPt(e1, pt);\n          if (e1Contributing)\n            e1.OutIdx = -1;\n        }\n        else if ((e2.WindDelta === 0) && (Math.abs(e1.WindCnt) == 1) &&\n          (this.m_ClipType != ClipperLib.ClipType.ctUnion || e1.WindCnt2 === 0))\n        {\n          this.AddOutPt(e2, pt);\n          if (e2Contributing)\n            e2.OutIdx = -1;\n        }\n      }\n      if (e1stops)\n        if (e1.OutIdx < 0)\n          this.DeleteFromAEL(e1);\n        else\n          ClipperLib.Error(\"Error intersecting polylines\");\n      if (e2stops)\n        if (e2.OutIdx < 0)\n          this.DeleteFromAEL(e2);\n        else\n          ClipperLib.Error(\"Error intersecting polylines\");\n      return;\n    }\n  }\n  //update winding counts...\n  //assumes that e1 will be to the Right of e2 ABOVE the intersection\n  if (e1.PolyTyp == e2.PolyTyp)\n  {\n    if (this.IsEvenOddFillType(e1))\n    {\n      var oldE1WindCnt = e1.WindCnt;\n      e1.WindCnt = e2.WindCnt;\n      e2.WindCnt = oldE1WindCnt;\n    }\n    else\n    {\n      if (e1.WindCnt + e2.WindDelta === 0)\n        e1.WindCnt = -e1.WindCnt;\n      else\n        e1.WindCnt += e2.WindDelta;\n      if (e2.WindCnt - e1.WindDelta === 0)\n        e2.WindCnt = -e2.WindCnt;\n      else\n        e2.WindCnt -= e1.WindDelta;\n    }\n  }\n  else\n  {\n    if (!this.IsEvenOddFillType(e2))\n      e1.WindCnt2 += e2.WindDelta;\n    else\n      e1.WindCnt2 = (e1.WindCnt2 === 0) ? 1 : 0;\n    if (!this.IsEvenOddFillType(e1))\n      e2.WindCnt2 -= e1.WindDelta;\n    else\n      e2.WindCnt2 = (e2.WindCnt2 === 0) ? 1 : 0;\n  }\n  var e1FillType, e2FillType, e1FillType2, e2FillType2;\n  if (e1.PolyTyp == ClipperLib.PolyType.ptSubject)\n  {\n    e1FillType = this.m_SubjFillType;\n    e1FillType2 = this.m_ClipFillType;\n  }\n  else\n  {\n    e1FillType = this.m_ClipFillType;\n    e1FillType2 = this.m_SubjFillType;\n  }\n  if (e2.PolyTyp == ClipperLib.PolyType.ptSubject)\n  {\n    e2FillType = this.m_SubjFillType;\n    e2FillType2 = this.m_ClipFillType;\n  }\n  else\n  {\n    e2FillType = this.m_ClipFillType;\n    e2FillType2 = this.m_SubjFillType;\n  }\n  var e1Wc, e2Wc;\n  switch (e1FillType)\n  {\n  case ClipperLib.PolyFillType.pftPositive:\n    e1Wc = e1.WindCnt;\n    break;\n  case ClipperLib.PolyFillType.pftNegative:\n    e1Wc = -e1.WindCnt;\n    break;\n  default:\n    e1Wc = Math.abs(e1.WindCnt);\n    break;\n  }\n  switch (e2FillType)\n  {\n  case ClipperLib.PolyFillType.pftPositive:\n    e2Wc = e2.WindCnt;\n    break;\n  case ClipperLib.PolyFillType.pftNegative:\n    e2Wc = -e2.WindCnt;\n    break;\n  default:\n    e2Wc = Math.abs(e2.WindCnt);\n    break;\n  }\n  if (e1Contributing && e2Contributing)\n  {\n    if (e1stops || e2stops || (e1Wc !== 0 && e1Wc != 1) || (e2Wc !== 0 && e2Wc != 1) ||\n      (e1.PolyTyp != e2.PolyTyp && this.m_ClipType != ClipperLib.ClipType.ctXor))\n      this.AddLocalMaxPoly(e1, e2, pt);\n    else\n    {\n      this.AddOutPt(e1, pt);\n      this.AddOutPt(e2, pt);\n      ClipperLib.Clipper.SwapSides(e1, e2);\n      ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n    }\n  }\n  else if (e1Contributing)\n  {\n    if (e2Wc === 0 || e2Wc == 1)\n    {\n      this.AddOutPt(e1, pt);\n      ClipperLib.Clipper.SwapSides(e1, e2);\n      ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n    }\n  }\n  else if (e2Contributing)\n  {\n    if (e1Wc === 0 || e1Wc == 1)\n    {\n      this.AddOutPt(e2, pt);\n      ClipperLib.Clipper.SwapSides(e1, e2);\n      ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n    }\n  }\n  else if ((e1Wc === 0 || e1Wc == 1) &&\n    (e2Wc === 0 || e2Wc == 1) && !e1stops && !e2stops)\n  {\n    //neither edge is currently contributing ...\n    var e1Wc2, e2Wc2;\n    switch (e1FillType2)\n    {\n    case ClipperLib.PolyFillType.pftPositive:\n      e1Wc2 = e1.WindCnt2;\n      break;\n    case ClipperLib.PolyFillType.pftNegative:\n      e1Wc2 = -e1.WindCnt2;\n      break;\n    default:\n      e1Wc2 = Math.abs(e1.WindCnt2);\n      break;\n    }\n    switch (e2FillType2)\n    {\n    case ClipperLib.PolyFillType.pftPositive:\n      e2Wc2 = e2.WindCnt2;\n      break;\n    case ClipperLib.PolyFillType.pftNegative:\n      e2Wc2 = -e2.WindCnt2;\n      break;\n    default:\n      e2Wc2 = Math.abs(e2.WindCnt2);\n      break;\n    }\n    if (e1.PolyTyp != e2.PolyTyp)\n      this.AddLocalMinPoly(e1, e2, pt);\n    else if (e1Wc == 1 && e2Wc == 1)\n      switch (this.m_ClipType)\n      {\n      case ClipperLib.ClipType.ctIntersection:\n        if (e1Wc2 > 0 && e2Wc2 > 0)\n          this.AddLocalMinPoly(e1, e2, pt);\n        break;\n      case ClipperLib.ClipType.ctUnion:\n        if (e1Wc2 <= 0 && e2Wc2 <= 0)\n          this.AddLocalMinPoly(e1, e2, pt);\n        break;\n      case ClipperLib.ClipType.ctDifference:\n        if (((e1.PolyTyp == ClipperLib.PolyType.ptClip) && (e1Wc2 > 0) && (e2Wc2 > 0)) ||\n          ((e1.PolyTyp == ClipperLib.PolyType.ptSubject) && (e1Wc2 <= 0) && (e2Wc2 <= 0)))\n          this.AddLocalMinPoly(e1, e2, pt);\n        break;\n      case ClipperLib.ClipType.ctXor:\n        this.AddLocalMinPoly(e1, e2, pt);\n        break;\n      }\n    else\n      ClipperLib.Clipper.SwapSides(e1, e2);\n  }\n  if ((e1stops != e2stops) &&\n    ((e1stops && (e1.OutIdx >= 0)) || (e2stops && (e2.OutIdx >= 0))))\n  {\n    ClipperLib.Clipper.SwapSides(e1, e2);\n    ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n  }\n  //finally, delete any non-contributing maxima edges  ...\n  if (e1stops)\n    this.DeleteFromAEL(e1);\n  if (e2stops)\n    this.DeleteFromAEL(e2);\n};\nClipperLib.Clipper.prototype.DeleteFromAEL = function (e)\n{\n  var AelPrev = e.PrevInAEL;\n  var AelNext = e.NextInAEL;\n  if (AelPrev === null && AelNext === null && (e != this.m_ActiveEdges))\n    return;\n  //already deleted\n  if (AelPrev !== null)\n    AelPrev.NextInAEL = AelNext;\n  else\n    this.m_ActiveEdges = AelNext;\n  if (AelNext !== null)\n    AelNext.PrevInAEL = AelPrev;\n  e.NextInAEL = null;\n  e.PrevInAEL = null;\n};\nClipperLib.Clipper.prototype.DeleteFromSEL = function (e)\n{\n  var SelPrev = e.PrevInSEL;\n  var SelNext = e.NextInSEL;\n  if (SelPrev === null && SelNext === null && (e != this.m_SortedEdges))\n    return;\n  //already deleted\n  if (SelPrev !== null)\n    SelPrev.NextInSEL = SelNext;\n  else\n    this.m_SortedEdges = SelNext;\n  if (SelNext !== null)\n    SelNext.PrevInSEL = SelPrev;\n  e.NextInSEL = null;\n  e.PrevInSEL = null;\n};\nClipperLib.Clipper.prototype.UpdateEdgeIntoAEL = function (e)\n{\n  if (e.NextInLML === null)\n    ClipperLib.Error(\"UpdateEdgeIntoAEL: invalid call\");\n  var AelPrev = e.PrevInAEL;\n  var AelNext = e.NextInAEL;\n  e.NextInLML.OutIdx = e.OutIdx;\n  if (AelPrev !== null)\n    AelPrev.NextInAEL = e.NextInLML;\n  else\n    this.m_ActiveEdges = e.NextInLML;\n  if (AelNext !== null)\n    AelNext.PrevInAEL = e.NextInLML;\n  e.NextInLML.Side = e.Side;\n  e.NextInLML.WindDelta = e.WindDelta;\n  e.NextInLML.WindCnt = e.WindCnt;\n  e.NextInLML.WindCnt2 = e.WindCnt2;\n  e = e.NextInLML;\n  //    e.Curr = e.Bot;\n  e.Curr.X = e.Bot.X;\n  e.Curr.Y = e.Bot.Y;\n  e.PrevInAEL = AelPrev;\n  e.NextInAEL = AelNext;\n  if (!ClipperLib.ClipperBase.IsHorizontal(e))\n    this.InsertScanbeam(e.Top.Y);\n  return e;\n};\nClipperLib.Clipper.prototype.ProcessHorizontals = function (isTopOfScanbeam)\n{\n  var horzEdge = this.m_SortedEdges;\n  while (horzEdge !== null)\n  {\n    this.DeleteFromSEL(horzEdge);\n    this.ProcessHorizontal(horzEdge, isTopOfScanbeam);\n    horzEdge = this.m_SortedEdges;\n  }\n};\nClipperLib.Clipper.prototype.GetHorzDirection = function (HorzEdge, $var)\n{\n  if (HorzEdge.Bot.X < HorzEdge.Top.X)\n  {\n      $var.Left = HorzEdge.Bot.X;\n      $var.Right = HorzEdge.Top.X;\n      $var.Dir = ClipperLib.Direction.dLeftToRight;\n  }\n  else\n  {\n      $var.Left = HorzEdge.Top.X;\n      $var.Right = HorzEdge.Bot.X;\n      $var.Dir = ClipperLib.Direction.dRightToLeft;\n  }\n};\nClipperLib.Clipper.prototype.PrepareHorzJoins = function (horzEdge, isTopOfScanbeam)\n{\n  //get the last Op for this horizontal edge\n  //the point may be anywhere along the horizontal ...\n  var outPt = this.m_PolyOuts[horzEdge.OutIdx].Pts;\n  if (horzEdge.Side != ClipperLib.EdgeSide.esLeft)\n    outPt = outPt.Prev;\n  //First, match up overlapping horizontal edges (eg when one polygon's\n  //intermediate horz edge overlaps an intermediate horz edge of another, or\n  //when one polygon sits on top of another) ...\n  //for (var i = 0, ilen = this.m_GhostJoins.length; i < ilen; ++i) {\n  //  var j = this.m_GhostJoins[i];\n  //  if (this.HorzSegmentsOverlap(j.OutPt1.Pt, j.OffPt, horzEdge.Bot, horzEdge.Top))\n  //    this.AddJoin(j.OutPt1, outPt, j.OffPt);\n  //}\n\n  //Also, since horizontal edges at the top of one SB are often removed from\n  //the AEL before we process the horizontal edges at the bottom of the next,\n  //we need to create 'ghost' Join records of 'contrubuting' horizontals that\n  //we can compare with horizontals at the bottom of the next SB.\n  if (isTopOfScanbeam)\n    if (ClipperLib.IntPoint.op_Equality(outPt.Pt, horzEdge.Top))\n      this.AddGhostJoin(outPt, horzEdge.Bot);\n    else\n      this.AddGhostJoin(outPt, horzEdge.Top);\n};\nClipperLib.Clipper.prototype.ProcessHorizontal = function (horzEdge, isTopOfScanbeam)\n{\n  var $var = {Dir: null, Left: null, Right: null};\n  this.GetHorzDirection(horzEdge, $var);\n  var dir = $var.Dir;\n  var horzLeft = $var.Left;\n  var horzRight = $var.Right;\n\n  var eLastHorz = horzEdge,\n    eMaxPair = null;\n  while (eLastHorz.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(eLastHorz.NextInLML))\n    eLastHorz = eLastHorz.NextInLML;\n  if (eLastHorz.NextInLML === null)\n    eMaxPair = this.GetMaximaPair(eLastHorz);\n  for (;;)\n  {\n    var IsLastHorz = (horzEdge == eLastHorz);\n    var e = this.GetNextInAEL(horzEdge, dir);\n    while (e !== null)\n    {\n      //Break if we've got to the end of an intermediate horizontal edge ...\n      //nb: Smaller Dx's are to the right of larger Dx's ABOVE the horizontal.\n      if (e.Curr.X == horzEdge.Top.X && horzEdge.NextInLML !== null && e.Dx < horzEdge.NextInLML.Dx)\n        break;\n      var eNext = this.GetNextInAEL(e, dir);\n      //saves eNext for later\n      if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X <= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X >= horzLeft))\n      {\n\n        if (horzEdge.OutIdx >= 0 && horzEdge.WindDelta != 0)\n          this.PrepareHorzJoins(horzEdge, isTopOfScanbeam);\n\n        //so far we're still in range of the horizontal Edge  but make sure\n        //we're at the last of consec. horizontals when matching with eMaxPair\n        if (e == eMaxPair && IsLastHorz)\n        {\n          if (dir == ClipperLib.Direction.dLeftToRight)\n            this.IntersectEdges(horzEdge, e, e.Top, false);\n          else\n            this.IntersectEdges(e, horzEdge, e.Top, false);\n          if (eMaxPair.OutIdx >= 0)\n            ClipperLib.Error(\"ProcessHorizontal error\");\n          return;\n        }\n        else if (dir == ClipperLib.Direction.dLeftToRight)\n        {\n          var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n          this.IntersectEdges(horzEdge, e, Pt, true);\n        }\n        else\n        {\n          var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n          this.IntersectEdges(e, horzEdge, Pt, true);\n        }\n        this.SwapPositionsInAEL(horzEdge, e);\n      }\n      else if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X >= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X <= horzLeft))\n        break;\n      e = eNext;\n    }\n    //end while\n    if (horzEdge.OutIdx >= 0 && horzEdge.WindDelta !== 0)\n      this.PrepareHorzJoins(horzEdge, isTopOfScanbeam);\n    if (horzEdge.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(horzEdge.NextInLML))\n    {\n      horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n      if (horzEdge.OutIdx >= 0)\n        this.AddOutPt(horzEdge, horzEdge.Bot);\n        \n        var $var = {Dir: dir, Left: horzLeft, Right: horzRight};\n        this.GetHorzDirection(horzEdge, $var);\n        dir = $var.Dir;\n        horzLeft = $var.Left;\n        horzRight = $var.Right;\n    }\n    else\n      break;\n  }\n  //end for (;;)\n  if (horzEdge.NextInLML !== null)\n  {\n    if (horzEdge.OutIdx >= 0)\n    {\n      var op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n      horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n      if (horzEdge.WindDelta === 0)\n        return;\n      //nb: HorzEdge is no longer horizontal here\n      var ePrev = horzEdge.PrevInAEL;\n      var eNext = horzEdge.NextInAEL;\n      if (ePrev !== null && ePrev.Curr.X == horzEdge.Bot.X &&\n        ePrev.Curr.Y == horzEdge.Bot.Y && ePrev.WindDelta !== 0 &&\n        (ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&\n          ClipperLib.ClipperBase.SlopesEqual(horzEdge, ePrev, this.m_UseFullRange)))\n      {\n        var op2 = this.AddOutPt(ePrev, horzEdge.Bot);\n        this.AddJoin(op1, op2, horzEdge.Top);\n      }\n      else if (eNext !== null && eNext.Curr.X == horzEdge.Bot.X &&\n        eNext.Curr.Y == horzEdge.Bot.Y && eNext.WindDelta !== 0 &&\n        eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&\n        ClipperLib.ClipperBase.SlopesEqual(horzEdge, eNext, this.m_UseFullRange))\n      {\n        var op2 = this.AddOutPt(eNext, horzEdge.Bot);\n        this.AddJoin(op1, op2, horzEdge.Top);\n      }\n    }\n    else horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n  }\n  else if (eMaxPair !== null)\n  {\n    if (eMaxPair.OutIdx >= 0)\n    {\n      if (dir == ClipperLib.Direction.dLeftToRight)\n        this.IntersectEdges(horzEdge, eMaxPair, horzEdge.Top, false);\n      else\n        this.IntersectEdges(eMaxPair, horzEdge, horzEdge.Top, false);\n      if (eMaxPair.OutIdx >= 0)\n        ClipperLib.Error(\"ProcessHorizontal error\");\n    }\n    else\n    {\n      this.DeleteFromAEL(horzEdge);\n      this.DeleteFromAEL(eMaxPair);\n    }\n  }\n  else\n  {\n    if (horzEdge.OutIdx >= 0)\n      this.AddOutPt(horzEdge, horzEdge.Top);\n    this.DeleteFromAEL(horzEdge);\n  }\n};\nClipperLib.Clipper.prototype.GetNextInAEL = function (e, Direction)\n{\n  return Direction == ClipperLib.Direction.dLeftToRight ? e.NextInAEL : e.PrevInAEL;\n};\nClipperLib.Clipper.prototype.IsMinima = function (e)\n{\n  return e !== null && (e.Prev.NextInLML != e) && (e.Next.NextInLML != e);\n};\nClipperLib.Clipper.prototype.IsMaxima = function (e, Y)\n{\n  return (e !== null && e.Top.Y == Y && e.NextInLML === null);\n};\nClipperLib.Clipper.prototype.IsIntermediate = function (e, Y)\n{\n  return (e.Top.Y == Y && e.NextInLML !== null);\n};\nClipperLib.Clipper.prototype.GetMaximaPair = function (e)\n{\n  var result = null;\n  if ((ClipperLib.IntPoint.op_Equality(e.Next.Top, e.Top)) && e.Next.NextInLML === null)\n    result = e.Next;\n  else if ((ClipperLib.IntPoint.op_Equality(e.Prev.Top, e.Top)) && e.Prev.NextInLML === null)\n    result = e.Prev;\n  if (result !== null && (result.OutIdx == -2 || (result.NextInAEL == result.PrevInAEL && !ClipperLib.ClipperBase.IsHorizontal(result))))\n    return null;\n  return result;\n};\nClipperLib.Clipper.prototype.ProcessIntersections = function (botY, topY)\n{\n  if (this.m_ActiveEdges == null)\n    return true;\n  try\n  {\n    this.BuildIntersectList(botY, topY);\n    if (this.m_IntersectList.length == 0)\n      return true;\n    if (this.m_IntersectList.length == 1 || this.FixupIntersectionOrder())\n      this.ProcessIntersectList();\n    else\n      return false;\n  }\n  catch ($$e2)\n  {\n    this.m_SortedEdges = null;\n    this.m_IntersectList.length = 0;\n    ClipperLib.Error(\"ProcessIntersections error\");\n  }\n  this.m_SortedEdges = null;\n  return true;\n};\nClipperLib.Clipper.prototype.BuildIntersectList = function (botY, topY)\n{\n  if (this.m_ActiveEdges === null)\n    return;\n  //prepare for sorting ...\n  var e = this.m_ActiveEdges;\n  //console.log(JSON.stringify(JSON.decycle( e )));\n  this.m_SortedEdges = e;\n  while (e !== null)\n  {\n    e.PrevInSEL = e.PrevInAEL;\n    e.NextInSEL = e.NextInAEL;\n    e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n    e = e.NextInAEL;\n  }\n  //bubblesort ...\n  var isModified = true;\n  while (isModified && this.m_SortedEdges !== null)\n  {\n    isModified = false;\n    e = this.m_SortedEdges;\n    while (e.NextInSEL !== null)\n    {\n      var eNext = e.NextInSEL;\n      var pt = new ClipperLib.IntPoint();\n      //console.log(\"e.Curr.X: \" + e.Curr.X + \" eNext.Curr.X\" + eNext.Curr.X);\n      if (e.Curr.X > eNext.Curr.X)\n      {\n        if (!this.IntersectPoint(e, eNext, pt) && e.Curr.X > eNext.Curr.X + 1)\n        {\n          //console.log(\"e.Curr.X: \"+JSON.stringify(JSON.decycle( e.Curr.X )));\n          //console.log(\"eNext.Curr.X+1: \"+JSON.stringify(JSON.decycle( eNext.Curr.X+1)));\n          ClipperLib.Error(\"Intersection error\");\n        }\n        if (pt.Y > botY)\n        {\n          pt.Y = botY;\n          if (Math.abs(e.Dx) > Math.abs(eNext.Dx))\n            pt.X = ClipperLib.Clipper.TopX(eNext, botY);\n          else\n            pt.X = ClipperLib.Clipper.TopX(e, botY);\n        }\n        var newNode = new ClipperLib.IntersectNode();\n        newNode.Edge1 = e;\n        newNode.Edge2 = eNext;\n        //newNode.Pt = pt;\n        newNode.Pt.X = pt.X;\n        newNode.Pt.Y = pt.Y;\n        this.m_IntersectList.push(newNode);\n        this.SwapPositionsInSEL(e, eNext);\n        isModified = true;\n      }\n      else\n        e = eNext;\n    }\n    if (e.PrevInSEL !== null)\n      e.PrevInSEL.NextInSEL = null;\n    else\n      break;\n  }\n  this.m_SortedEdges = null;\n};\nClipperLib.Clipper.prototype.EdgesAdjacent = function (inode)\n{\n  return (inode.Edge1.NextInSEL == inode.Edge2) || (inode.Edge1.PrevInSEL == inode.Edge2);\n};\nClipperLib.Clipper.IntersectNodeSort = function (node1, node2)\n{\n  //the following typecast is safe because the differences in Pt.Y will\n  //be limited to the height of the scanbeam.\n  return (node2.Pt.Y - node1.Pt.Y);\n};\nClipperLib.Clipper.prototype.FixupIntersectionOrder = function ()\n{\n  //pre-condition: intersections are sorted bottom-most first.\n  //Now it's crucial that intersections are made only between adjacent edges,\n  //so to ensure this the order of intersections may need adjusting ...\n  this.m_IntersectList.sort(this.m_IntersectNodeComparer);\n  this.CopyAELToSEL();\n  var cnt = this.m_IntersectList.length;\n  for (var i = 0; i < cnt; i++)\n  {\n    if (!this.EdgesAdjacent(this.m_IntersectList[i]))\n    {\n      var j = i + 1;\n      while (j < cnt && !this.EdgesAdjacent(this.m_IntersectList[j]))\n        j++;\n      if (j == cnt)\n        return false;\n      var tmp = this.m_IntersectList[i];\n      this.m_IntersectList[i] = this.m_IntersectList[j];\n      this.m_IntersectList[j] = tmp;\n    }\n    this.SwapPositionsInSEL(this.m_IntersectList[i].Edge1, this.m_IntersectList[i].Edge2);\n  }\n  return true;\n};\nClipperLib.Clipper.prototype.ProcessIntersectList = function ()\n{\n  for (var i = 0, ilen = this.m_IntersectList.length; i < ilen; i++)\n  {\n    var iNode = this.m_IntersectList[i];\n    this.IntersectEdges(iNode.Edge1, iNode.Edge2, iNode.Pt, true);\n    this.SwapPositionsInAEL(iNode.Edge1, iNode.Edge2);\n  }\n  this.m_IntersectList.length = 0;\n};\n/*\n--------------------------------\nRound speedtest: http://jsperf.com/fastest-round\n--------------------------------\n*/\nvar R1 = function (a)\n{\n  return a < 0 ? Math.ceil(a - 0.5) : Math.round(a)\n};\nvar R2 = function (a)\n{\n  return a < 0 ? Math.ceil(a - 0.5) : Math.floor(a + 0.5)\n};\nvar R3 = function (a)\n{\n  return a < 0 ? -Math.round(Math.abs(a)) : Math.round(a)\n};\nvar R4 = function (a)\n{\n  if (a < 0)\n  {\n    a -= 0.5;\n    return a < -2147483648 ? Math.ceil(a) : a | 0;\n  }\n  else\n  {\n    a += 0.5;\n    return a > 2147483647 ? Math.floor(a) : a | 0;\n  }\n};\nif (browser.msie) ClipperLib.Clipper.Round = R1;\nelse if (browser.chromium) ClipperLib.Clipper.Round = R3;\nelse if (browser.safari) ClipperLib.Clipper.Round = R4;\nelse ClipperLib.Clipper.Round = R2; // eg. browser.chrome || browser.firefox || browser.opera\nClipperLib.Clipper.TopX = function (edge, currentY)\n{\n  //if (edge.Bot == edge.Curr) alert (\"edge.Bot = edge.Curr\");\n  //if (edge.Bot == edge.Top) alert (\"edge.Bot = edge.Top\");\n  if (currentY == edge.Top.Y)\n    return edge.Top.X;\n  return edge.Bot.X + ClipperLib.Clipper.Round(edge.Dx * (currentY - edge.Bot.Y));\n};\nClipperLib.Clipper.prototype.IntersectPoint = function (edge1, edge2, ip)\n{\n  ip.X = 0;\n  ip.Y = 0;\n  var b1, b2;\n  //nb: with very large coordinate values, it's possible for SlopesEqual() to \n  //return false but for the edge.Dx value be equal due to double precision rounding.\n  if (ClipperLib.ClipperBase.SlopesEqual(edge1, edge2, this.m_UseFullRange) || edge1.Dx == edge2.Dx)\n  {\n    if (edge2.Bot.Y > edge1.Bot.Y)\n    {\n      ip.X = edge2.Bot.X;\n      ip.Y = edge2.Bot.Y;\n    }\n    else\n    {\n      ip.X = edge1.Bot.X;\n      ip.Y = edge1.Bot.Y;\n    }\n    return false;\n  }\n  else if (edge1.Delta.X === 0)\n  {\n    ip.X = edge1.Bot.X;\n    if (ClipperLib.ClipperBase.IsHorizontal(edge2))\n    {\n      ip.Y = edge2.Bot.Y;\n    }\n    else\n    {\n      b2 = edge2.Bot.Y - (edge2.Bot.X / edge2.Dx);\n      ip.Y = ClipperLib.Clipper.Round(ip.X / edge2.Dx + b2);\n    }\n  }\n  else if (edge2.Delta.X === 0)\n  {\n    ip.X = edge2.Bot.X;\n    if (ClipperLib.ClipperBase.IsHorizontal(edge1))\n    {\n      ip.Y = edge1.Bot.Y;\n    }\n    else\n    {\n      b1 = edge1.Bot.Y - (edge1.Bot.X / edge1.Dx);\n      ip.Y = ClipperLib.Clipper.Round(ip.X / edge1.Dx + b1);\n    }\n  }\n  else\n  {\n    b1 = edge1.Bot.X - edge1.Bot.Y * edge1.Dx;\n    b2 = edge2.Bot.X - edge2.Bot.Y * edge2.Dx;\n    var q = (b2 - b1) / (edge1.Dx - edge2.Dx);\n    ip.Y = ClipperLib.Clipper.Round(q);\n    if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n      ip.X = ClipperLib.Clipper.Round(edge1.Dx * q + b1);\n    else\n      ip.X = ClipperLib.Clipper.Round(edge2.Dx * q + b2);\n  }\n  if (ip.Y < edge1.Top.Y || ip.Y < edge2.Top.Y)\n  {\n    if (edge1.Top.Y > edge2.Top.Y)\n    {\n      ip.Y = edge1.Top.Y;\n      ip.X = ClipperLib.Clipper.TopX(edge2, edge1.Top.Y);\n      return ip.X < edge1.Top.X;\n    }\n    else\n      ip.Y = edge2.Top.Y;\n    if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n      ip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n    else\n      ip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n  }\n  return true;\n};\nClipperLib.Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function (topY)\n{\n  var e = this.m_ActiveEdges;\n  while (e !== null)\n  {\n    //1. process maxima, treating them as if they're 'bent' horizontal edges,\n    //   but exclude maxima with horizontal edges. nb: e can't be a horizontal.\n    var IsMaximaEdge = this.IsMaxima(e, topY);\n    if (IsMaximaEdge)\n    {\n      var eMaxPair = this.GetMaximaPair(e);\n      IsMaximaEdge = (eMaxPair === null || !ClipperLib.ClipperBase.IsHorizontal(eMaxPair));\n    }\n    if (IsMaximaEdge)\n    {\n      var ePrev = e.PrevInAEL;\n      this.DoMaxima(e);\n      if (ePrev === null)\n        e = this.m_ActiveEdges;\n      else\n        e = ePrev.NextInAEL;\n    }\n    else\n    {\n      //2. promote horizontal edges, otherwise update Curr.X and Curr.Y ...\n      if (this.IsIntermediate(e, topY) && ClipperLib.ClipperBase.IsHorizontal(e.NextInLML))\n      {\n        e = this.UpdateEdgeIntoAEL(e);\n        if (e.OutIdx >= 0)\n          this.AddOutPt(e, e.Bot);\n        this.AddEdgeToSEL(e);\n      }\n      else\n      {\n        e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n        e.Curr.Y = topY;\n      }\n      if (this.StrictlySimple)\n      {\n        var ePrev = e.PrevInAEL;\n        if ((e.OutIdx >= 0) && (e.WindDelta !== 0) && ePrev !== null &&\n          (ePrev.OutIdx >= 0) && (ePrev.Curr.X == e.Curr.X) &&\n          (ePrev.WindDelta !== 0))\n        {\n          var op = this.AddOutPt(ePrev, e.Curr);\n          var op2 = this.AddOutPt(e, e.Curr);\n          this.AddJoin(op, op2, e.Curr);\n          //StrictlySimple (type-3) join\n        }\n      }\n      e = e.NextInAEL;\n    }\n  }\n  //3. Process horizontals at the Top of the scanbeam ...\n  this.ProcessHorizontals(true);\n  //4. Promote intermediate vertices ...\n  e = this.m_ActiveEdges;\n  while (e !== null)\n  {\n    if (this.IsIntermediate(e, topY))\n    {\n      var op = null;\n      if (e.OutIdx >= 0)\n        op = this.AddOutPt(e, e.Top);\n      e = this.UpdateEdgeIntoAEL(e);\n      //if output polygons share an edge, they'll need joining later ...\n      var ePrev = e.PrevInAEL;\n      var eNext = e.NextInAEL;\n      if (ePrev !== null && ePrev.Curr.X == e.Bot.X &&\n        ePrev.Curr.Y == e.Bot.Y && op !== null &&\n        ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&\n        ClipperLib.ClipperBase.SlopesEqual(e, ePrev, this.m_UseFullRange) &&\n        (e.WindDelta !== 0) && (ePrev.WindDelta !== 0))\n      {\n        var op2 = this.AddOutPt(ePrev, e.Bot);\n        this.AddJoin(op, op2, e.Top);\n      }\n      else if (eNext !== null && eNext.Curr.X == e.Bot.X &&\n        eNext.Curr.Y == e.Bot.Y && op !== null &&\n        eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&\n        ClipperLib.ClipperBase.SlopesEqual(e, eNext, this.m_UseFullRange) &&\n        (e.WindDelta !== 0) && (eNext.WindDelta !== 0))\n      {\n        var op2 = this.AddOutPt(eNext, e.Bot);\n        this.AddJoin(op, op2, e.Top);\n      }\n    }\n    e = e.NextInAEL;\n  }\n};\nClipperLib.Clipper.prototype.DoMaxima = function (e)\n{\n  var eMaxPair = this.GetMaximaPair(e);\n  if (eMaxPair === null)\n  {\n    if (e.OutIdx >= 0)\n      this.AddOutPt(e, e.Top);\n    this.DeleteFromAEL(e);\n    return;\n  }\n  var eNext = e.NextInAEL;\n  var use_lines = true;\n  while (eNext !== null && eNext != eMaxPair)\n  {\n    this.IntersectEdges(e, eNext, e.Top, true);\n    this.SwapPositionsInAEL(e, eNext);\n    eNext = e.NextInAEL;\n  }\n  if (e.OutIdx == -1 && eMaxPair.OutIdx == -1)\n  {\n    this.DeleteFromAEL(e);\n    this.DeleteFromAEL(eMaxPair);\n  }\n  else if (e.OutIdx >= 0 && eMaxPair.OutIdx >= 0)\n  {\n    this.IntersectEdges(e, eMaxPair, e.Top, false);\n  }\n  else if (use_lines && e.WindDelta === 0)\n  {\n    if (e.OutIdx >= 0)\n    {\n      this.AddOutPt(e, e.Top);\n      e.OutIdx = -1;\n    }\n    this.DeleteFromAEL(e);\n    if (eMaxPair.OutIdx >= 0)\n    {\n      this.AddOutPt(eMaxPair, e.Top);\n      eMaxPair.OutIdx = -1;\n    }\n    this.DeleteFromAEL(eMaxPair);\n  }\n  else\n    ClipperLib.Error(\"DoMaxima error\");\n};\nClipperLib.Clipper.ReversePaths = function (polys)\n{\n  for (var i = 0, len = polys.length; i < len; i++)\n    polys[i].reverse();\n};\nClipperLib.Clipper.Orientation = function (poly)\n{\n  return ClipperLib.Clipper.Area(poly) >= 0;\n};\nClipperLib.Clipper.prototype.PointCount = function (pts)\n{\n  if (pts === null)\n    return 0;\n  var result = 0;\n  var p = pts;\n  do {\n    result++;\n    p = p.Next;\n  }\n  while (p != pts)\n  return result;\n};\nClipperLib.Clipper.prototype.BuildResult = function (polyg)\n{\n  ClipperLib.Clear(polyg);\n  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n  {\n    var outRec = this.m_PolyOuts[i];\n    if (outRec.Pts === null)\n      continue;\n    var p = outRec.Pts.Prev;\n    var cnt = this.PointCount(p);\n    if (cnt < 2)\n      continue;\n    var pg = new Array(cnt);\n    for (var j = 0; j < cnt; j++)\n    {\n      pg[j] = p.Pt;\n      p = p.Prev;\n    }\n    polyg.push(pg);\n  }\n};\nClipperLib.Clipper.prototype.BuildResult2 = function (polytree)\n{\n  polytree.Clear();\n  //add each output polygon/contour to polytree ...\n  //polytree.m_AllPolys.set_Capacity(this.m_PolyOuts.length);\n  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n  {\n    var outRec = this.m_PolyOuts[i];\n    var cnt = this.PointCount(outRec.Pts);\n    if ((outRec.IsOpen && cnt < 2) || (!outRec.IsOpen && cnt < 3))\n      continue;\n    this.FixHoleLinkage(outRec);\n    var pn = new ClipperLib.PolyNode();\n    polytree.m_AllPolys.push(pn);\n    outRec.PolyNode = pn;\n    pn.m_polygon.length = cnt;\n    var op = outRec.Pts.Prev;\n    for (var j = 0; j < cnt; j++)\n    {\n      pn.m_polygon[j] = op.Pt;\n      op = op.Prev;\n    }\n  }\n  //fixup PolyNode links etc ...\n  //polytree.m_Childs.set_Capacity(this.m_PolyOuts.length);\n  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n  {\n    var outRec = this.m_PolyOuts[i];\n    if (outRec.PolyNode === null)\n      continue;\n    else if (outRec.IsOpen)\n    {\n      outRec.PolyNode.IsOpen = true;\n      polytree.AddChild(outRec.PolyNode);\n    }\n    else if (outRec.FirstLeft !== null && outRec.FirstLeft.PolyNode != null)\n      outRec.FirstLeft.PolyNode.AddChild(outRec.PolyNode);\n    else\n      polytree.AddChild(outRec.PolyNode);\n  }\n};\nClipperLib.Clipper.prototype.FixupOutPolygon = function (outRec)\n{\n  //FixupOutPolygon() - removes duplicate points and simplifies consecutive\n  //parallel edges by removing the middle vertex.\n  var lastOK = null;\n  outRec.BottomPt = null;\n  var pp = outRec.Pts;\n  for (;;)\n  {\n    if (pp.Prev == pp || pp.Prev == pp.Next)\n    {\n      this.DisposeOutPts(pp);\n      outRec.Pts = null;\n      return;\n    }\n    //test for duplicate points and collinear edges ...\n    if ((ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Next.Pt)) || (ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Prev.Pt)) ||\n      (ClipperLib.ClipperBase.SlopesEqual(pp.Prev.Pt, pp.Pt, pp.Next.Pt, this.m_UseFullRange) &&\n        (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(pp.Prev.Pt, pp.Pt, pp.Next.Pt))))\n    {\n      lastOK = null;\n      var tmp = pp;\n      pp.Prev.Next = pp.Next;\n      pp.Next.Prev = pp.Prev;\n      pp = pp.Prev;\n      tmp = null;\n    }\n    else if (pp == lastOK)\n      break;\n    else\n    {\n      if (lastOK === null)\n        lastOK = pp;\n      pp = pp.Next;\n    }\n  }\n  outRec.Pts = pp;\n};\nClipperLib.Clipper.prototype.DupOutPt = function (outPt, InsertAfter)\n{\n  var result = new ClipperLib.OutPt();\n  //result.Pt = outPt.Pt;\n  result.Pt.X = outPt.Pt.X;\n  result.Pt.Y = outPt.Pt.Y;\n  result.Idx = outPt.Idx;\n  if (InsertAfter)\n  {\n    result.Next = outPt.Next;\n    result.Prev = outPt;\n    outPt.Next.Prev = result;\n    outPt.Next = result;\n  }\n  else\n  {\n    result.Prev = outPt.Prev;\n    result.Next = outPt;\n    outPt.Prev.Next = result;\n    outPt.Prev = result;\n  }\n  return result;\n};\nClipperLib.Clipper.prototype.GetOverlap = function (a1, a2, b1, b2, $val)\n{\n  if (a1 < a2)\n  {\n    if (b1 < b2)\n    {\n      $val.Left = Math.max(a1, b1);\n      $val.Right = Math.min(a2, b2);\n    }\n    else\n    {\n      $val.Left = Math.max(a1, b2);\n      $val.Right = Math.min(a2, b1);\n    }\n  }\n  else\n  {\n    if (b1 < b2)\n    {\n      $val.Left = Math.max(a2, b1);\n      $val.Right = Math.min(a1, b2);\n    }\n    else\n    {\n      $val.Left = Math.max(a2, b2);\n      $val.Right = Math.min(a1, b1);\n    }\n  }\n  return $val.Left < $val.Right;\n};\nClipperLib.Clipper.prototype.JoinHorz = function (op1, op1b, op2, op2b, Pt, DiscardLeft)\n{\n  var Dir1 = (op1.Pt.X > op1b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n  var Dir2 = (op2.Pt.X > op2b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n  if (Dir1 == Dir2)\n    return false;\n  //When DiscardLeft, we want Op1b to be on the Left of Op1, otherwise we\n  //want Op1b to be on the Right. (And likewise with Op2 and Op2b.)\n  //So, to facilitate this while inserting Op1b and Op2b ...\n  //when DiscardLeft, make sure we're AT or RIGHT of Pt before adding Op1b,\n  //otherwise make sure we're AT or LEFT of Pt. (Likewise with Op2b.)\n  if (Dir1 == ClipperLib.Direction.dLeftToRight)\n  {\n    while (op1.Next.Pt.X <= Pt.X &&\n      op1.Next.Pt.X >= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)\n      op1 = op1.Next;\n    if (DiscardLeft && (op1.Pt.X != Pt.X))\n      op1 = op1.Next;\n    op1b = this.DupOutPt(op1, !DiscardLeft);\n    if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n    {\n      op1 = op1b;\n      //op1.Pt = Pt;\n      op1.Pt.X = Pt.X;\n      op1.Pt.Y = Pt.Y;\n      op1b = this.DupOutPt(op1, !DiscardLeft);\n    }\n  }\n  else\n  {\n    while (op1.Next.Pt.X >= Pt.X &&\n      op1.Next.Pt.X <= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)\n      op1 = op1.Next;\n    if (!DiscardLeft && (op1.Pt.X != Pt.X))\n      op1 = op1.Next;\n    op1b = this.DupOutPt(op1, DiscardLeft);\n    if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n    {\n      op1 = op1b;\n      //op1.Pt = Pt;\n      op1.Pt.X = Pt.X;\n      op1.Pt.Y = Pt.Y;\n      op1b = this.DupOutPt(op1, DiscardLeft);\n    }\n  }\n  if (Dir2 == ClipperLib.Direction.dLeftToRight)\n  {\n    while (op2.Next.Pt.X <= Pt.X &&\n      op2.Next.Pt.X >= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)\n      op2 = op2.Next;\n    if (DiscardLeft && (op2.Pt.X != Pt.X))\n      op2 = op2.Next;\n    op2b = this.DupOutPt(op2, !DiscardLeft);\n    if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n    {\n      op2 = op2b;\n      //op2.Pt = Pt;\n      op2.Pt.X = Pt.X;\n      op2.Pt.Y = Pt.Y;\n      op2b = this.DupOutPt(op2, !DiscardLeft);\n    }\n  }\n  else\n  {\n    while (op2.Next.Pt.X >= Pt.X &&\n      op2.Next.Pt.X <= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)\n      op2 = op2.Next;\n    if (!DiscardLeft && (op2.Pt.X != Pt.X))\n      op2 = op2.Next;\n    op2b = this.DupOutPt(op2, DiscardLeft);\n    if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n    {\n      op2 = op2b;\n      //op2.Pt = Pt;\n      op2.Pt.X = Pt.X;\n      op2.Pt.Y = Pt.Y;\n      op2b = this.DupOutPt(op2, DiscardLeft);\n    }\n  }\n  if ((Dir1 == ClipperLib.Direction.dLeftToRight) == DiscardLeft)\n  {\n    op1.Prev = op2;\n    op2.Next = op1;\n    op1b.Next = op2b;\n    op2b.Prev = op1b;\n  }\n  else\n  {\n    op1.Next = op2;\n    op2.Prev = op1;\n    op1b.Prev = op2b;\n    op2b.Next = op1b;\n  }\n  return true;\n};\nClipperLib.Clipper.prototype.JoinPoints = function (j, outRec1, outRec2)\n{\n  var op1 = j.OutPt1,\n    op1b = new ClipperLib.OutPt();\n  var op2 = j.OutPt2,\n    op2b = new ClipperLib.OutPt();\n  //There are 3 kinds of joins for output polygons ...\n  //1. Horizontal joins where Join.OutPt1 & Join.OutPt2 are a vertices anywhere\n  //along (horizontal) collinear edges (& Join.OffPt is on the same horizontal).\n  //2. Non-horizontal joins where Join.OutPt1 & Join.OutPt2 are at the same\n  //location at the Bottom of the overlapping segment (& Join.OffPt is above).\n  //3. StrictlySimple joins where edges touch but are not collinear and where\n  //Join.OutPt1, Join.OutPt2 & Join.OffPt all share the same point.\n  var isHorizontal = (j.OutPt1.Pt.Y == j.OffPt.Y);\n  if (isHorizontal && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt1.Pt)) && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt2.Pt)))\n  {\n    //Strictly Simple join ...\n    op1b = j.OutPt1.Next;\n    while (op1b != op1 && (ClipperLib.IntPoint.op_Equality(op1b.Pt, j.OffPt)))\n      op1b = op1b.Next;\n    var reverse1 = (op1b.Pt.Y > j.OffPt.Y);\n    op2b = j.OutPt2.Next;\n    while (op2b != op2 && (ClipperLib.IntPoint.op_Equality(op2b.Pt, j.OffPt)))\n      op2b = op2b.Next;\n    var reverse2 = (op2b.Pt.Y > j.OffPt.Y);\n    if (reverse1 == reverse2)\n      return false;\n    if (reverse1)\n    {\n      op1b = this.DupOutPt(op1, false);\n      op2b = this.DupOutPt(op2, true);\n      op1.Prev = op2;\n      op2.Next = op1;\n      op1b.Next = op2b;\n      op2b.Prev = op1b;\n      j.OutPt1 = op1;\n      j.OutPt2 = op1b;\n      return true;\n    }\n    else\n    {\n      op1b = this.DupOutPt(op1, true);\n      op2b = this.DupOutPt(op2, false);\n      op1.Next = op2;\n      op2.Prev = op1;\n      op1b.Prev = op2b;\n      op2b.Next = op1b;\n      j.OutPt1 = op1;\n      j.OutPt2 = op1b;\n      return true;\n    }\n  }\n  else if (isHorizontal)\n  {\n    //treat horizontal joins differently to non-horizontal joins since with\n    //them we're not yet sure where the overlapping is. OutPt1.Pt & OutPt2.Pt\n    //may be anywhere along the horizontal edge.\n    op1b = op1;\n    while (op1.Prev.Pt.Y == op1.Pt.Y && op1.Prev != op1b && op1.Prev != op2)\n      op1 = op1.Prev;\n    while (op1b.Next.Pt.Y == op1b.Pt.Y && op1b.Next != op1 && op1b.Next != op2)\n      op1b = op1b.Next;\n    if (op1b.Next == op1 || op1b.Next == op2)\n      return false;\n    //a flat 'polygon'\n    op2b = op2;\n    while (op2.Prev.Pt.Y == op2.Pt.Y && op2.Prev != op2b && op2.Prev != op1b)\n      op2 = op2.Prev;\n    while (op2b.Next.Pt.Y == op2b.Pt.Y && op2b.Next != op2 && op2b.Next != op1)\n      op2b = op2b.Next;\n    if (op2b.Next == op2 || op2b.Next == op1)\n      return false;\n    //a flat 'polygon'\n    //Op1 -. Op1b & Op2 -. Op2b are the extremites of the horizontal edges\n\n    var $val = {Left: null, Right: null};\n    if (!this.GetOverlap(op1.Pt.X, op1b.Pt.X, op2.Pt.X, op2b.Pt.X, $val))\n      return false;\n    var Left = $val.Left;\n    var Right = $val.Right;\n\n    //DiscardLeftSide: when overlapping edges are joined, a spike will created\n    //which needs to be cleaned up. However, we don't want Op1 or Op2 caught up\n    //on the discard Side as either may still be needed for other joins ...\n    var Pt = new ClipperLib.IntPoint();\n    var DiscardLeftSide;\n    if (op1.Pt.X >= Left && op1.Pt.X <= Right)\n    {\n      //Pt = op1.Pt;\n      Pt.X = op1.Pt.X;\n      Pt.Y = op1.Pt.Y;\n      DiscardLeftSide = (op1.Pt.X > op1b.Pt.X);\n    }\n    else if (op2.Pt.X >= Left && op2.Pt.X <= Right)\n    {\n      //Pt = op2.Pt;\n      Pt.X = op2.Pt.X;\n      Pt.Y = op2.Pt.Y;\n      DiscardLeftSide = (op2.Pt.X > op2b.Pt.X);\n    }\n    else if (op1b.Pt.X >= Left && op1b.Pt.X <= Right)\n    {\n      //Pt = op1b.Pt;\n      Pt.X = op1b.Pt.X;\n      Pt.Y = op1b.Pt.Y;\n      DiscardLeftSide = op1b.Pt.X > op1.Pt.X;\n    }\n    else\n    {\n      //Pt = op2b.Pt;\n      Pt.X = op2b.Pt.X;\n      Pt.Y = op2b.Pt.Y;\n      DiscardLeftSide = (op2b.Pt.X > op2.Pt.X);\n    }\n    j.OutPt1 = op1;\n    j.OutPt2 = op2;\n    return this.JoinHorz(op1, op1b, op2, op2b, Pt, DiscardLeftSide);\n  }\n  else\n  {\n    //nb: For non-horizontal joins ...\n    //    1. Jr.OutPt1.Pt.Y == Jr.OutPt2.Pt.Y\n    //    2. Jr.OutPt1.Pt > Jr.OffPt.Y\n    //make sure the polygons are correctly oriented ...\n    op1b = op1.Next;\n    while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))\n      op1b = op1b.Next;\n    var Reverse1 = ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange));\n    if (Reverse1)\n    {\n      op1b = op1.Prev;\n      while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))\n        op1b = op1b.Prev;\n      if ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange))\n        return false;\n    }\n    op2b = op2.Next;\n    while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))\n      op2b = op2b.Next;\n    var Reverse2 = ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange));\n    if (Reverse2)\n    {\n      op2b = op2.Prev;\n      while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))\n        op2b = op2b.Prev;\n      if ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange))\n        return false;\n    }\n    if ((op1b == op1) || (op2b == op2) || (op1b == op2b) ||\n      ((outRec1 == outRec2) && (Reverse1 == Reverse2)))\n      return false;\n    if (Reverse1)\n    {\n      op1b = this.DupOutPt(op1, false);\n      op2b = this.DupOutPt(op2, true);\n      op1.Prev = op2;\n      op2.Next = op1;\n      op1b.Next = op2b;\n      op2b.Prev = op1b;\n      j.OutPt1 = op1;\n      j.OutPt2 = op1b;\n      return true;\n    }\n    else\n    {\n      op1b = this.DupOutPt(op1, true);\n      op2b = this.DupOutPt(op2, false);\n      op1.Next = op2;\n      op2.Prev = op1;\n      op1b.Prev = op2b;\n      op2b.Next = op1b;\n      j.OutPt1 = op1;\n      j.OutPt2 = op1b;\n      return true;\n    }\n  }\n};\nClipperLib.Clipper.GetBounds = function (paths)\n{\n  var i = 0,\n    cnt = paths.length;\n  while (i < cnt && paths[i].length == 0) i++;\n  if (i == cnt) return new ClipperLib.IntRect(0, 0, 0, 0);\n  var result = new ClipperLib.IntRect();\n  result.left = paths[i][0].X;\n  result.right = result.left;\n  result.top = paths[i][0].Y;\n  result.bottom = result.top;\n  for (; i < cnt; i++)\n    for (var j = 0, jlen = paths[i].length; j < jlen; j++)\n    {\n      if (paths[i][j].X < result.left) result.left = paths[i][j].X;\n      else if (paths[i][j].X > result.right) result.right = paths[i][j].X;\n      if (paths[i][j].Y < result.top) result.top = paths[i][j].Y;\n      else if (paths[i][j].Y > result.bottom) result.bottom = paths[i][j].Y;\n    }\n  return result;\n}\nClipperLib.Clipper.prototype.GetBounds2 = function (ops)\n{\n  var opStart = ops;\n  var result = new ClipperLib.IntRect();\n  result.left = ops.Pt.X;\n  result.right = ops.Pt.X;\n  result.top = ops.Pt.Y;\n  result.bottom = ops.Pt.Y;\n  ops = ops.Next;\n  while (ops != opStart)\n  {\n    if (ops.Pt.X < result.left)\n      result.left = ops.Pt.X;\n    if (ops.Pt.X > result.right)\n      result.right = ops.Pt.X;\n    if (ops.Pt.Y < result.top)\n      result.top = ops.Pt.Y;\n    if (ops.Pt.Y > result.bottom)\n      result.bottom = ops.Pt.Y;\n    ops = ops.Next;\n  }\n  return result;\n};\n\nClipperLib.Clipper.PointInPolygon = function (pt, path)\n{\n  //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n  //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n  var result = 0,\n    cnt = path.length;\n  if (cnt < 3)\n    return 0;\n  var ip = path[0];\n  for (var i = 1; i <= cnt; ++i)\n  {\n    var ipNext = (i == cnt ? path[0] : path[i]);\n    if (ipNext.Y == pt.Y)\n    {\n      if ((ipNext.X == pt.X) || (ip.Y == pt.Y && ((ipNext.X > pt.X) == (ip.X < pt.X))))\n        return -1;\n    }\n    if ((ip.Y < pt.Y) != (ipNext.Y < pt.Y))\n    {\n      if (ip.X >= pt.X)\n      {\n        if (ipNext.X > pt.X)\n          result = 1 - result;\n        else\n        {\n          var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n          if (d == 0)\n            return -1;\n          else if ((d > 0) == (ipNext.Y > ip.Y))\n            result = 1 - result;\n        }\n      }\n      else\n      {\n        if (ipNext.X > pt.X)\n        {\n          var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n          if (d == 0)\n            return -1;\n          else if ((d > 0) == (ipNext.Y > ip.Y))\n            result = 1 - result;\n        }\n      }\n    }\n    ip = ipNext;\n  }\n  return result;\n};\n    \nClipperLib.Clipper.prototype.PointInPolygon = function (pt, op)\n{\n  //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n  //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n  var result = 0;\n  var startOp = op;\n  for (;;)\n  {\n    var poly0x = op.Pt.X,\n      poly0y = op.Pt.Y;\n    var poly1x = op.Next.Pt.X,\n      poly1y = op.Next.Pt.Y;\n    if (poly1y == pt.Y)\n    {\n      if ((poly1x == pt.X) || (poly0y == pt.Y && ((poly1x > pt.X) == (poly0x < pt.X))))\n        return -1;\n    }\n    if ((poly0y < pt.Y) != (poly1y < pt.Y))\n    {\n      if (poly0x >= pt.X)\n      {\n        if (poly1x > pt.X)\n          result = 1 - result;\n        else\n        {\n          var d = (poly0x - pt.X) * (poly1y - pt.Y) - (poly1x - pt.X) * (poly0y - pt.Y);\n          if (d == 0)\n            return -1;\n          if ((d > 0) == (poly1y > poly0y))\n            result = 1 - result;\n        }\n      }\n      else\n      {\n        if (poly1x > pt.X)\n        {\n          var d = (poly0x - pt.X) * (poly1y - pt.Y) - (poly1x - pt.X) * (poly0y - pt.Y);\n          if (d == 0)\n            return -1;\n          if ((d > 0) == (poly1y > poly0y))\n            result = 1 - result;\n        }\n      }\n    }\n    op = op.Next;\n    if (startOp == op)\n      break;\n  }\n  return result;\n};\n\nClipperLib.Clipper.prototype.Poly2ContainsPoly1 = function (outPt1, outPt2)\n{\n  var op = outPt1;\n  do {\n    var res = this.PointInPolygon(op.Pt, outPt2);\n    if (res >= 0)\n      return res != 0;\n    op = op.Next;\n  }\n  while (op != outPt1)\n  return true;\n};\nClipperLib.Clipper.prototype.FixupFirstLefts1 = function (OldOutRec, NewOutRec)\n{\n  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n  {\n    var outRec = this.m_PolyOuts[i];\n    if (outRec.Pts !== null && outRec.FirstLeft == OldOutRec)\n    {\n      if (this.Poly2ContainsPoly1(outRec.Pts, NewOutRec.Pts))\n        outRec.FirstLeft = NewOutRec;\n    }\n  }\n};\nClipperLib.Clipper.prototype.FixupFirstLefts2 = function (OldOutRec, NewOutRec)\n{\n  for (var $i2 = 0, $t2 = this.m_PolyOuts, $l2 = $t2.length, outRec = $t2[$i2]; $i2 < $l2; $i2++, outRec = $t2[$i2])\n    if (outRec.FirstLeft == OldOutRec)\n      outRec.FirstLeft = NewOutRec;\n};\nClipperLib.Clipper.ParseFirstLeft = function (FirstLeft)\n{\n  while (FirstLeft != null && FirstLeft.Pts == null)\n    FirstLeft = FirstLeft.FirstLeft;\n  return FirstLeft;\n};\nClipperLib.Clipper.prototype.JoinCommonEdges = function ()\n{\n  for (var i = 0, ilen = this.m_Joins.length; i < ilen; i++)\n  {\n    var join = this.m_Joins[i];\n    var outRec1 = this.GetOutRec(join.OutPt1.Idx);\n    var outRec2 = this.GetOutRec(join.OutPt2.Idx);\n    if (outRec1.Pts == null || outRec2.Pts == null)\n      continue;\n    //get the polygon fragment with the correct hole state (FirstLeft)\n    //before calling JoinPoints() ...\n    var holeStateRec;\n    if (outRec1 == outRec2)\n      holeStateRec = outRec1;\n    else if (this.Param1RightOfParam2(outRec1, outRec2))\n      holeStateRec = outRec2;\n    else if (this.Param1RightOfParam2(outRec2, outRec1))\n      holeStateRec = outRec1;\n    else\n      holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n\n    if (!this.JoinPoints(join, outRec1, outRec2)) continue;\n\n    if (outRec1 == outRec2)\n    {\n      //instead of joining two polygons, we've just created a new one by\n      //splitting one polygon into two.\n      outRec1.Pts = join.OutPt1;\n      outRec1.BottomPt = null;\n      outRec2 = this.CreateOutRec();\n      outRec2.Pts = join.OutPt2;\n      //update all OutRec2.Pts Idx's ...\n      this.UpdateOutPtIdxs(outRec2);\n      //We now need to check every OutRec.FirstLeft pointer. If it points\n      //to OutRec1 it may need to point to OutRec2 instead ...\n      if (this.m_UsingPolyTree)\n        for (var j = 0, jlen = this.m_PolyOuts.length; j < jlen - 1; j++)\n        {\n          var oRec = this.m_PolyOuts[j];\n          if (oRec.Pts == null || ClipperLib.Clipper.ParseFirstLeft(oRec.FirstLeft) != outRec1 || oRec.IsHole == outRec1.IsHole)\n            continue;\n          if (this.Poly2ContainsPoly1(oRec.Pts, join.OutPt2))\n            oRec.FirstLeft = outRec2;\n        }\n      if (this.Poly2ContainsPoly1(outRec2.Pts, outRec1.Pts))\n      {\n        //outRec2 is contained by outRec1 ...\n        outRec2.IsHole = !outRec1.IsHole;\n        outRec2.FirstLeft = outRec1;\n        //fixup FirstLeft pointers that may need reassigning to OutRec1\n        if (this.m_UsingPolyTree)\n          this.FixupFirstLefts2(outRec2, outRec1);\n        if ((outRec2.IsHole ^ this.ReverseSolution) == (this.Area(outRec2) > 0))\n          this.ReversePolyPtLinks(outRec2.Pts);\n      }\n      else if (this.Poly2ContainsPoly1(outRec1.Pts, outRec2.Pts))\n      {\n        //outRec1 is contained by outRec2 ...\n        outRec2.IsHole = outRec1.IsHole;\n        outRec1.IsHole = !outRec2.IsHole;\n        outRec2.FirstLeft = outRec1.FirstLeft;\n        outRec1.FirstLeft = outRec2;\n        //fixup FirstLeft pointers that may need reassigning to OutRec1\n        if (this.m_UsingPolyTree)\n          this.FixupFirstLefts2(outRec1, outRec2);\n        if ((outRec1.IsHole ^ this.ReverseSolution) == (this.Area(outRec1) > 0))\n          this.ReversePolyPtLinks(outRec1.Pts);\n      }\n      else\n      {\n        //the 2 polygons are completely separate ...\n        outRec2.IsHole = outRec1.IsHole;\n        outRec2.FirstLeft = outRec1.FirstLeft;\n        //fixup FirstLeft pointers that may need reassigning to OutRec2\n        if (this.m_UsingPolyTree)\n          this.FixupFirstLefts1(outRec1, outRec2);\n      }\n    }\n    else\n    {\n      //joined 2 polygons together ...\n      outRec2.Pts = null;\n      outRec2.BottomPt = null;\n      outRec2.Idx = outRec1.Idx;\n      outRec1.IsHole = holeStateRec.IsHole;\n      if (holeStateRec == outRec2)\n        outRec1.FirstLeft = outRec2.FirstLeft;\n      outRec2.FirstLeft = outRec1;\n      //fixup FirstLeft pointers that may need reassigning to OutRec1\n      if (this.m_UsingPolyTree)\n        this.FixupFirstLefts2(outRec2, outRec1);\n    }\n  }\n};\nClipperLib.Clipper.prototype.UpdateOutPtIdxs = function (outrec)\n{\n  var op = outrec.Pts;\n  do {\n    op.Idx = outrec.Idx;\n    op = op.Prev;\n  }\n  while (op != outrec.Pts)\n};\nClipperLib.Clipper.prototype.DoSimplePolygons = function ()\n{\n  var i = 0;\n  while (i < this.m_PolyOuts.length)\n  {\n    var outrec = this.m_PolyOuts[i++];\n    var op = outrec.Pts;\n    if (op === null)\n      continue;\n    do //for each Pt in Polygon until duplicate found do ...\n    {\n      var op2 = op.Next;\n      while (op2 != outrec.Pts)\n      {\n        if ((ClipperLib.IntPoint.op_Equality(op.Pt, op2.Pt)) && op2.Next != op && op2.Prev != op)\n        {\n          //split the polygon into two ...\n          var op3 = op.Prev;\n          var op4 = op2.Prev;\n          op.Prev = op4;\n          op4.Next = op;\n          op2.Prev = op3;\n          op3.Next = op2;\n          outrec.Pts = op;\n          var outrec2 = this.CreateOutRec();\n          outrec2.Pts = op2;\n          this.UpdateOutPtIdxs(outrec2);\n          if (this.Poly2ContainsPoly1(outrec2.Pts, outrec.Pts))\n          {\n            //OutRec2 is contained by OutRec1 ...\n            outrec2.IsHole = !outrec.IsHole;\n            outrec2.FirstLeft = outrec;\n          }\n          else if (this.Poly2ContainsPoly1(outrec.Pts, outrec2.Pts))\n          {\n            //OutRec1 is contained by OutRec2 ...\n            outrec2.IsHole = outrec.IsHole;\n            outrec.IsHole = !outrec2.IsHole;\n            outrec2.FirstLeft = outrec.FirstLeft;\n            outrec.FirstLeft = outrec2;\n          }\n          else\n          {\n            //the 2 polygons are separate ...\n            outrec2.IsHole = outrec.IsHole;\n            outrec2.FirstLeft = outrec.FirstLeft;\n          }\n          op2 = op;\n          //ie get ready for the next iteration\n        }\n        op2 = op2.Next;\n      }\n      op = op.Next;\n    }\n    while (op != outrec.Pts)\n  }\n};\nClipperLib.Clipper.Area = function (poly)\n{\n  var cnt = poly.length;\n  if (cnt < 3)\n    return 0;\n  var a = 0;\n  for (var i = 0, j = cnt - 1; i < cnt; ++i)\n  {\n    a += (poly[j].X + poly[i].X) * (poly[j].Y - poly[i].Y);\n    j = i;\n  }\n  return -a * 0.5;\n};\nClipperLib.Clipper.prototype.Area = function (outRec)\n{\n  var op = outRec.Pts;\n  if (op == null)\n    return 0;\n  var a = 0;\n  do {\n    a = a + (op.Prev.Pt.X + op.Pt.X) * (op.Prev.Pt.Y - op.Pt.Y);\n    op = op.Next;\n  }\n  while (op != outRec.Pts)\n  return a * 0.5;\n};\nif (use_deprecated)\n{\n  ClipperLib.Clipper.OffsetPaths = function (polys, delta, jointype, endtype, MiterLimit)\n  {\n    var result = new ClipperLib.Paths();\n    var co = new ClipperLib.ClipperOffset(MiterLimit, MiterLimit);\n    co.AddPaths(polys, jointype, endtype);\n    co.Execute(result, delta);\n    return result;\n  };\n}\nClipperLib.Clipper.SimplifyPolygon = function (poly, fillType)\n{\n  var result = new Array();\n  var c = new ClipperLib.Clipper(0);\n  c.StrictlySimple = true;\n  c.AddPath(poly, ClipperLib.PolyType.ptSubject, true);\n  c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n  return result;\n};\nClipperLib.Clipper.SimplifyPolygons = function (polys, fillType)\n{\n  if (typeof (fillType) == \"undefined\") fillType = ClipperLib.PolyFillType.pftEvenOdd;\n  var result = new Array();\n  var c = new ClipperLib.Clipper(0);\n  c.StrictlySimple = true;\n  c.AddPaths(polys, ClipperLib.PolyType.ptSubject, true);\n  c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n  return result;\n};\nClipperLib.Clipper.DistanceSqrd = function (pt1, pt2)\n{\n  var dx = (pt1.X - pt2.X);\n  var dy = (pt1.Y - pt2.Y);\n  return (dx * dx + dy * dy);\n};\nClipperLib.Clipper.DistanceFromLineSqrd = function (pt, ln1, ln2)\n{\n  //The equation of a line in general form (Ax + By + C = 0)\n  //given 2 points (x�,y�) & (x�,y�) is ...\n  //(y� - y�)x + (x� - x�)y + (y� - y�)x� - (x� - x�)y� = 0\n  //A = (y� - y�); B = (x� - x�); C = (y� - y�)x� - (x� - x�)y�\n  //perpendicular distance of point (x�,y�) = (Ax� + By� + C)/Sqrt(A� + B�)\n  //see http://en.wikipedia.org/wiki/Perpendicular_distance\n  var A = ln1.Y - ln2.Y;\n  var B = ln2.X - ln1.X;\n  var C = A * ln1.X + B * ln1.Y;\n  C = A * pt.X + B * pt.Y - C;\n  return (C * C) / (A * A + B * B);\n};\nClipperLib.Clipper.SlopesNearCollinear = function (pt1, pt2, pt3, distSqrd)\n{\n  return ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n};\nClipperLib.Clipper.PointsAreClose = function (pt1, pt2, distSqrd)\n{\n  var dx = pt1.X - pt2.X;\n  var dy = pt1.Y - pt2.Y;\n  return ((dx * dx) + (dy * dy) <= distSqrd);\n};\n//------------------------------------------------------------------------------\nClipperLib.Clipper.ExcludeOp = function (op)\n{\n  var result = op.Prev;\n  result.Next = op.Next;\n  op.Next.Prev = result;\n  result.Idx = 0;\n  return result;\n};\nClipperLib.Clipper.CleanPolygon = function (path, distance)\n{\n  if (typeof (distance) == \"undefined\") distance = 1.415;\n  //distance = proximity in units/pixels below which vertices will be stripped. \n  //Default ~= sqrt(2) so when adjacent vertices or semi-adjacent vertices have \n  //both x & y coords within 1 unit, then the second vertex will be stripped.\n  var cnt = path.length;\n  if (cnt == 0)\n    return new Array();\n  var outPts = new Array(cnt);\n  for (var i = 0; i < cnt; ++i)\n    outPts[i] = new ClipperLib.OutPt();\n  for (var i = 0; i < cnt; ++i)\n  {\n    outPts[i].Pt = path[i];\n    outPts[i].Next = outPts[(i + 1) % cnt];\n    outPts[i].Next.Prev = outPts[i];\n    outPts[i].Idx = 0;\n  }\n  var distSqrd = distance * distance;\n  var op = outPts[0];\n  while (op.Idx == 0 && op.Next != op.Prev)\n  {\n    if (ClipperLib.Clipper.PointsAreClose(op.Pt, op.Prev.Pt, distSqrd))\n    {\n      op = ClipperLib.Clipper.ExcludeOp(op);\n      cnt--;\n    }\n    else if (ClipperLib.Clipper.PointsAreClose(op.Prev.Pt, op.Next.Pt, distSqrd))\n    {\n      ClipperLib.Clipper.ExcludeOp(op.Next);\n      op = ClipperLib.Clipper.ExcludeOp(op);\n      cnt -= 2;\n    }\n    else if (ClipperLib.Clipper.SlopesNearCollinear(op.Prev.Pt, op.Pt, op.Next.Pt, distSqrd))\n    {\n      op = ClipperLib.Clipper.ExcludeOp(op);\n      cnt--;\n    }\n    else\n    {\n      op.Idx = 1;\n      op = op.Next;\n    }\n  }\n  if (cnt < 3)\n    cnt = 0;\n  var result = new Array(cnt);\n  for (var i = 0; i < cnt; ++i)\n  {\n    result[i] = new ClipperLib.IntPoint(op.Pt);\n    op = op.Next;\n  }\n  outPts = null;\n  return result;\n};\nClipperLib.Clipper.CleanPolygons = function (polys, distance)\n{\n  var result = new Array(polys.length);\n  for (var i = 0, ilen = polys.length; i < ilen; i++)\n    result[i] = ClipperLib.Clipper.CleanPolygon(polys[i], distance);\n  return result;\n};\nClipperLib.Clipper.Minkowski = function (pattern, path, IsSum, IsClosed)\n{\n  var delta = (IsClosed ? 1 : 0);\n  var polyCnt = pattern.length;\n  var pathCnt = path.length;\n  var result = new Array();\n  if (IsSum)\n    for (var i = 0; i < pathCnt; i++)\n    {\n      var p = new Array(polyCnt);\n      for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n        p[j] = new ClipperLib.IntPoint(path[i].X + ip.X, path[i].Y + ip.Y);\n      result.push(p);\n    }\n  else\n    for (var i = 0; i < pathCnt; i++)\n    {\n      var p = new Array(polyCnt);\n      for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n        p[j] = new ClipperLib.IntPoint(path[i].X - ip.X, path[i].Y - ip.Y);\n      result.push(p);\n    }\n  var quads = new Array();\n  for (var i = 0; i < pathCnt - 1 + delta; i++)\n    for (var j = 0; j < polyCnt; j++)\n    {\n      var quad = new Array();\n      quad.push(result[i % pathCnt][j % polyCnt]);\n      quad.push(result[(i + 1) % pathCnt][j % polyCnt]);\n      quad.push(result[(i + 1) % pathCnt][(j + 1) % polyCnt]);\n      quad.push(result[i % pathCnt][(j + 1) % polyCnt]);\n      if (!ClipperLib.Clipper.Orientation(quad))\n        quad.reverse();\n      quads.push(quad);\n    }\n  var c = new ClipperLib.Clipper(0);\n  c.AddPaths(quads, ClipperLib.PolyType.ptSubject, true);\n  c.Execute(ClipperLib.ClipType.ctUnion, result, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n  return result;\n};\n\nClipperLib.Clipper.MinkowskiSum = function ()\n{\n  var a = arguments,\n    alen = a.length;\n  if (alen == 3) // MinkowskiSum(Path pattern, path, pathIsClosed)\n  {\n    var pattern = a[0],\n      path = a[1],\n      pathIsClosed = a[2];\n    return ClipperLib.Clipper.Minkowski(pattern, path, true, pathIsClosed);\n  }\n  else if (alen == 4) // MinkowskiSum(pattern, paths, pathFillType, pathIsClosed)\n  {\n    var pattern = a[0],\n      paths = a[1],\n      pathFillType = a[2],\n      pathIsClosed = a[3];\n    var c = new ClipperLib.Clipper(),\n      tmp;\n    for (var i = 0, ilen = paths.length; i < ilen; ++i)\n    {\n      var tmp = ClipperLib.Clipper.Minkowski(pattern, paths[i], true, pathIsClosed);\n      c.AddPaths(tmp, ClipperLib.PolyType.ptSubject, true);\n    }\n    if (pathIsClosed) c.AddPaths(paths, ClipperLib.PolyType.ptClip, true);\n    var solution = new ClipperLib.Paths();\n    c.Execute(ClipperLib.ClipType.ctUnion, solution, pathFillType, pathFillType);\n    return solution;\n  }\n};\n\nClipperLib.Clipper.MinkowskiDiff = function (pattern, path, pathIsClosed)\n{\n  return ClipperLib.Clipper.Minkowski(pattern, path, false, pathIsClosed);\n};\n\nClipperLib.Clipper.PolyTreeToPaths = function (polytree)\n{\n  var result = new Array();\n  //result.set_Capacity(polytree.get_Total());\n  ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntAny, result);\n  return result;\n};\nClipperLib.Clipper.AddPolyNodeToPaths = function (polynode, nt, paths)\n{\n  var match = true;\n  switch (nt)\n  {\n  case ClipperLib.Clipper.NodeType.ntOpen:\n    return;\n  case ClipperLib.Clipper.NodeType.ntClosed:\n    match = !polynode.IsOpen;\n    break;\n  default:\n    break;\n  }\n  if (polynode.m_polygon.length > 0 && match)\n    paths.push(polynode.m_polygon);\n  for (var $i3 = 0, $t3 = polynode.Childs(), $l3 = $t3.length, pn = $t3[$i3]; $i3 < $l3; $i3++, pn = $t3[$i3])\n    ClipperLib.Clipper.AddPolyNodeToPaths(pn, nt, paths);\n};\nClipperLib.Clipper.OpenPathsFromPolyTree = function (polytree)\n{\n  var result = new ClipperLib.Paths();\n  //result.set_Capacity(polytree.ChildCount());\n  for (var i = 0, ilen = polytree.ChildCount(); i < ilen; i++)\n    if (polytree.Childs()[i].IsOpen)\n      result.push(polytree.Childs()[i].m_polygon);\n  return result;\n};\nClipperLib.Clipper.ClosedPathsFromPolyTree = function (polytree)\n{\n  var result = new ClipperLib.Paths();\n  //result.set_Capacity(polytree.Total());\n  ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntClosed, result);\n  return result;\n};\nInherit(ClipperLib.Clipper, ClipperLib.ClipperBase);\nClipperLib.Clipper.NodeType = {\n  ntAny: 0,\n  ntOpen: 1,\n  ntClosed: 2\n};\nClipperLib.ClipperOffset = function (miterLimit, arcTolerance)\n{\n  if (typeof (miterLimit) == \"undefined\") miterLimit = 2;\n  if (typeof (arcTolerance) == \"undefined\") arcTolerance = ClipperLib.ClipperOffset.def_arc_tolerance;\n  this.m_destPolys = new ClipperLib.Paths();\n  this.m_srcPoly = new ClipperLib.Path();\n  this.m_destPoly = new ClipperLib.Path();\n  this.m_normals = new Array();\n  this.m_delta = 0;\n  this.m_sinA = 0;\n  this.m_sin = 0;\n  this.m_cos = 0;\n  this.m_miterLim = 0;\n  this.m_StepsPerRad = 0;\n  this.m_lowest = new ClipperLib.IntPoint();\n  this.m_polyNodes = new ClipperLib.PolyNode();\n  this.MiterLimit = miterLimit;\n  this.ArcTolerance = arcTolerance;\n  this.m_lowest.X = -1;\n};\nClipperLib.ClipperOffset.two_pi = 6.28318530717959;\nClipperLib.ClipperOffset.def_arc_tolerance = 0.25;\nClipperLib.ClipperOffset.prototype.Clear = function ()\n{\n  ClipperLib.Clear(this.m_polyNodes.Childs());\n  this.m_lowest.X = -1;\n};\nClipperLib.ClipperOffset.Round = ClipperLib.Clipper.Round;\nClipperLib.ClipperOffset.prototype.AddPath = function (path, joinType, endType)\n{\n  var highI = path.length - 1;\n  if (highI < 0)\n    return;\n  var newNode = new ClipperLib.PolyNode();\n  newNode.m_jointype = joinType;\n  newNode.m_endtype = endType;\n  //strip duplicate points from path and also get index to the lowest point ...\n  if (endType == ClipperLib.EndType.etClosedLine || endType == ClipperLib.EndType.etClosedPolygon)\n    while (highI > 0 && ClipperLib.IntPoint.op_Equality(path[0], path[highI]))\n      highI--;\n  //newNode.m_polygon.set_Capacity(highI + 1);\n  newNode.m_polygon.push(path[0]);\n  var j = 0,\n    k = 0;\n  for (var i = 1; i <= highI; i++)\n    if (ClipperLib.IntPoint.op_Inequality(newNode.m_polygon[j], path[i]))\n    {\n      j++;\n      newNode.m_polygon.push(path[i]);\n      if (path[i].Y > newNode.m_polygon[k].Y || (path[i].Y == newNode.m_polygon[k].Y && path[i].X < newNode.m_polygon[k].X))\n        k = j;\n    }\n  if ((endType == ClipperLib.EndType.etClosedPolygon && j < 2) || (endType != ClipperLib.EndType.etClosedPolygon && j < 0))\n    return;\n  this.m_polyNodes.AddChild(newNode);\n  //if this path's lowest pt is lower than all the others then update m_lowest\n  if (endType != ClipperLib.EndType.etClosedPolygon)\n    return;\n  if (this.m_lowest.X < 0)\n    this.m_lowest = new ClipperLib.IntPoint(0, k);\n  else\n  {\n    var ip = this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon[this.m_lowest.Y];\n    if (newNode.m_polygon[k].Y > ip.Y || (newNode.m_polygon[k].Y == ip.Y && newNode.m_polygon[k].X < ip.X))\n      this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);\n  }\n};\nClipperLib.ClipperOffset.prototype.AddPaths = function (paths, joinType, endType)\n{\n  for (var i = 0, ilen = paths.length; i < ilen; i++)\n    this.AddPath(paths[i], joinType, endType);\n};\nClipperLib.ClipperOffset.prototype.FixOrientations = function ()\n{\n  //fixup orientations of all closed paths if the orientation of the\n  //closed path with the lowermost vertex is wrong ...\n  if (this.m_lowest.X >= 0 && !ClipperLib.Clipper.Orientation(this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon))\n  {\n    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n    {\n      var node = this.m_polyNodes.Childs()[i];\n      if (node.m_endtype == ClipperLib.EndType.etClosedPolygon || (node.m_endtype == ClipperLib.EndType.etClosedLine && ClipperLib.Clipper.Orientation(node.m_polygon)))\n        node.m_polygon.reverse();\n    }\n  }\n  else\n  {\n    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n    {\n      var node = this.m_polyNodes.Childs()[i];\n      if (node.m_endtype == ClipperLib.EndType.etClosedLine && !ClipperLib.Clipper.Orientation(node.m_polygon))\n        node.m_polygon.reverse();\n    }\n  }\n};\nClipperLib.ClipperOffset.GetUnitNormal = function (pt1, pt2)\n{\n  var dx = (pt2.X - pt1.X);\n  var dy = (pt2.Y - pt1.Y);\n  if ((dx == 0) && (dy == 0))\n    return new ClipperLib.DoublePoint(0, 0);\n  var f = 1 / Math.sqrt(dx * dx + dy * dy);\n  dx *= f;\n  dy *= f;\n  return new ClipperLib.DoublePoint(dy, -dx);\n};\nClipperLib.ClipperOffset.prototype.DoOffset = function (delta)\n{\n  this.m_destPolys = new Array();\n  this.m_delta = delta;\n  //if Zero offset, just copy any CLOSED polygons to m_p and return ...\n  if (ClipperLib.ClipperBase.near_zero(delta))\n  {\n    //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount);\n    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n    {\n      var node = this.m_polyNodes.Childs()[i];\n      if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n        this.m_destPolys.push(node.m_polygon);\n    }\n    return;\n  }\n  //see offset_triginometry3.svg in the documentation folder ...\n  if (this.MiterLimit > 2)\n    this.m_miterLim = 2 / (this.MiterLimit * this.MiterLimit);\n  else\n    this.m_miterLim = 0.5;\n  var y;\n  if (this.ArcTolerance <= 0)\n    y = ClipperLib.ClipperOffset.def_arc_tolerance;\n  else if (this.ArcTolerance > Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance)\n    y = Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance;\n  else\n    y = this.ArcTolerance;\n  //see offset_triginometry2.svg in the documentation folder ...\n  var steps = 3.14159265358979 / Math.acos(1 - y / Math.abs(delta));\n  this.m_sin = Math.sin(ClipperLib.ClipperOffset.two_pi / steps);\n  this.m_cos = Math.cos(ClipperLib.ClipperOffset.two_pi / steps);\n  this.m_StepsPerRad = steps / ClipperLib.ClipperOffset.two_pi;\n  if (delta < 0)\n    this.m_sin = -this.m_sin;\n  //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount * 2);\n  for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n  {\n    var node = this.m_polyNodes.Childs()[i];\n    this.m_srcPoly = node.m_polygon;\n    var len = this.m_srcPoly.length;\n    if (len == 0 || (delta <= 0 && (len < 3 || node.m_endtype != ClipperLib.EndType.etClosedPolygon)))\n      continue;\n    this.m_destPoly = new Array();\n    if (len == 1)\n    {\n      if (node.m_jointype == ClipperLib.JoinType.jtRound)\n      {\n        var X = 1,\n          Y = 0;\n        for (var j = 1; j <= steps; j++)\n        {\n          this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n          var X2 = X;\n          X = X * this.m_cos - this.m_sin * Y;\n          Y = X2 * this.m_sin + Y * this.m_cos;\n        }\n      }\n      else\n      {\n        var X = -1,\n          Y = -1;\n        for (var j = 0; j < 4; ++j)\n        {\n          this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n          if (X < 0)\n            X = 1;\n          else if (Y < 0)\n            Y = 1;\n          else\n            X = -1;\n        }\n      }\n      this.m_destPolys.push(this.m_destPoly);\n      continue;\n    }\n    //build m_normals ...\n    this.m_normals.length = 0;\n    //this.m_normals.set_Capacity(len);\n    for (var j = 0; j < len - 1; j++)\n      this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[j], this.m_srcPoly[j + 1]));\n    if (node.m_endtype == ClipperLib.EndType.etClosedLine || node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n      this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[len - 1], this.m_srcPoly[0]));\n    else\n      this.m_normals.push(new ClipperLib.DoublePoint(this.m_normals[len - 2]));\n    if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n    {\n      var k = len - 1;\n      for (var j = 0; j < len; j++)\n        k = this.OffsetPoint(j, k, node.m_jointype);\n      this.m_destPolys.push(this.m_destPoly);\n    }\n    else if (node.m_endtype == ClipperLib.EndType.etClosedLine)\n    {\n      var k = len - 1;\n      for (var j = 0; j < len; j++)\n        k = this.OffsetPoint(j, k, node.m_jointype);\n      this.m_destPolys.push(this.m_destPoly);\n      this.m_destPoly = new Array();\n      //re-build m_normals ...\n      var n = this.m_normals[len - 1];\n      for (var j = len - 1; j > 0; j--)\n        this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n      this.m_normals[0] = new ClipperLib.DoublePoint(-n.X, -n.Y);\n      k = 0;\n      for (var j = len - 1; j >= 0; j--)\n        k = this.OffsetPoint(j, k, node.m_jointype);\n      this.m_destPolys.push(this.m_destPoly);\n    }\n    else\n    {\n      var k = 0;\n      for (var j = 1; j < len - 1; ++j)\n        k = this.OffsetPoint(j, k, node.m_jointype);\n      var pt1;\n      if (node.m_endtype == ClipperLib.EndType.etOpenButt)\n      {\n        var j = len - 1;\n        pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * delta));\n        this.m_destPoly.push(pt1);\n        pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X - this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y - this.m_normals[j].Y * delta));\n        this.m_destPoly.push(pt1);\n      }\n      else\n      {\n        var j = len - 1;\n        k = len - 2;\n        this.m_sinA = 0;\n        this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j].X, -this.m_normals[j].Y);\n        if (node.m_endtype == ClipperLib.EndType.etOpenSquare)\n          this.DoSquare(j, k);\n        else\n          this.DoRound(j, k);\n      }\n      //re-build m_normals ...\n      for (var j = len - 1; j > 0; j--)\n        this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n      this.m_normals[0] = new ClipperLib.DoublePoint(-this.m_normals[1].X, -this.m_normals[1].Y);\n      k = len - 1;\n      for (var j = k - 1; j > 0; --j)\n        k = this.OffsetPoint(j, k, node.m_jointype);\n      if (node.m_endtype == ClipperLib.EndType.etOpenButt)\n      {\n        pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X - this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y - this.m_normals[0].Y * delta));\n        this.m_destPoly.push(pt1);\n        pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + this.m_normals[0].Y * delta));\n        this.m_destPoly.push(pt1);\n      }\n      else\n      {\n        k = 1;\n        this.m_sinA = 0;\n        if (node.m_endtype == ClipperLib.EndType.etOpenSquare)\n          this.DoSquare(0, 1);\n        else\n          this.DoRound(0, 1);\n      }\n      this.m_destPolys.push(this.m_destPoly);\n    }\n  }\n};\nClipperLib.ClipperOffset.prototype.Execute = function ()\n{\n  var a = arguments,\n    ispolytree = a[0] instanceof ClipperLib.PolyTree;\n  if (!ispolytree) // function (solution, delta)\n  {\n    var solution = a[0],\n      delta = a[1];\n    ClipperLib.Clear(solution);\n    this.FixOrientations();\n    this.DoOffset(delta);\n    //now clean up 'corners' ...\n    var clpr = new ClipperLib.Clipper(0);\n    clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n    if (delta > 0)\n    {\n      clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n    }\n    else\n    {\n      var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n      var outer = new ClipperLib.Path();\n      outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n      outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n      outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n      outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n      clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n      clpr.ReverseSolution = true;\n      clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n      if (solution.length > 0)\n        solution.splice(0, 1);\n    }\n    //console.log(JSON.stringify(solution));\n  }\n  else // function (polytree, delta)\n  {\n    var solution = a[0],\n      delta = a[1];\n    solution.Clear();\n    this.FixOrientations();\n    this.DoOffset(delta);\n    //now clean up 'corners' ...\n    var clpr = new ClipperLib.Clipper(0);\n    clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n    if (delta > 0)\n    {\n      clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n    }\n    else\n    {\n      var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n      var outer = new ClipperLib.Path();\n      outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n      outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n      outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n      outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n      clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n      clpr.ReverseSolution = true;\n      clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n      //remove the outer PolyNode rectangle ...\n      if (solution.ChildCount() == 1 && solution.Childs()[0].ChildCount() > 0)\n      {\n        var outerNode = solution.Childs()[0];\n        //solution.Childs.set_Capacity(outerNode.ChildCount);\n        solution.Childs()[0] = outerNode.Childs()[0];\n        for (var i = 1; i < outerNode.ChildCount(); i++)\n          solution.AddChild(outerNode.Childs()[i]);\n      }\n      else\n        solution.Clear();\n    }\n  }\n};\nClipperLib.ClipperOffset.prototype.OffsetPoint = function (j, k, jointype)\n{\n  this.m_sinA = (this.m_normals[k].X * this.m_normals[j].Y - this.m_normals[j].X * this.m_normals[k].Y);\n  if (this.m_sinA < 0.00005 && this.m_sinA > -0.00005)\n    return k;\n  else if (this.m_sinA > 1)\n    this.m_sinA = 1.0;\n  else if (this.m_sinA < -1)\n    this.m_sinA = -1.0;\n  if (this.m_sinA * this.m_delta < 0)\n  {\n    this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n    this.m_destPoly.push(new ClipperLib.IntPoint(this.m_srcPoly[j]));\n    this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n  }\n  else\n    switch (jointype)\n    {\n    case ClipperLib.JoinType.jtMiter:\n      {\n        var r = 1 + (this.m_normals[j].X * this.m_normals[k].X + this.m_normals[j].Y * this.m_normals[k].Y);\n        if (r >= this.m_miterLim)\n          this.DoMiter(j, k, r);\n        else\n          this.DoSquare(j, k);\n        break;\n      }\n    case ClipperLib.JoinType.jtSquare:\n      this.DoSquare(j, k);\n      break;\n    case ClipperLib.JoinType.jtRound:\n      this.DoRound(j, k);\n      break;\n    }\n  k = j;\n  return k;\n};\nClipperLib.ClipperOffset.prototype.DoSquare = function (j, k)\n{\n  var dx = Math.tan(Math.atan2(this.m_sinA,\n    this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y) / 4);\n  this.m_destPoly.push(new ClipperLib.IntPoint(\n    ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[k].X - this.m_normals[k].Y * dx)),\n    ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[k].Y + this.m_normals[k].X * dx))));\n  this.m_destPoly.push(new ClipperLib.IntPoint(\n    ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[j].X + this.m_normals[j].Y * dx)),\n    ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[j].Y - this.m_normals[j].X * dx))));\n};\nClipperLib.ClipperOffset.prototype.DoMiter = function (j, k, r)\n{\n  var q = this.m_delta / r;\n  this.m_destPoly.push(new ClipperLib.IntPoint(\n    ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + (this.m_normals[k].X + this.m_normals[j].X) * q),\n    ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + (this.m_normals[k].Y + this.m_normals[j].Y) * q)));\n};\nClipperLib.ClipperOffset.prototype.DoRound = function (j, k)\n{\n  var a = Math.atan2(this.m_sinA,\n    this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y);\n  var steps = ClipperLib.Cast_Int32(ClipperLib.ClipperOffset.Round(this.m_StepsPerRad * Math.abs(a)));\n  var X = this.m_normals[k].X,\n    Y = this.m_normals[k].Y,\n    X2;\n  for (var i = 0; i < steps; ++i)\n  {\n    this.m_destPoly.push(new ClipperLib.IntPoint(\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + X * this.m_delta),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + Y * this.m_delta)));\n    X2 = X;\n    X = X * this.m_cos - this.m_sin * Y;\n    Y = X2 * this.m_sin + Y * this.m_cos;\n  }\n  this.m_destPoly.push(new ClipperLib.IntPoint(\n    ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n    ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n};\nClipperLib.Error = function (message)\n{\n  try\n  {\n    throw new Error(message);\n  }\n  catch (err)\n  {\n    alert(err.message);\n  }\n};\n// ---------------------------------\n// JS extension by Timo 2013\nClipperLib.JS = {};\nClipperLib.JS.AreaOfPolygon = function (poly, scale)\n{\n  if (!scale) scale = 1;\n  return ClipperLib.Clipper.Area(poly) / (scale * scale);\n};\nClipperLib.JS.AreaOfPolygons = function (poly, scale)\n{\n  if (!scale) scale = 1;\n  var area = 0;\n  for (var i = 0; i < poly.length; i++)\n  {\n    area += ClipperLib.Clipper.Area(poly[i]);\n  }\n  return area / (scale * scale);\n};\nClipperLib.JS.BoundsOfPath = function (path, scale)\n{\n  return ClipperLib.JS.BoundsOfPaths([path], scale);\n};\nClipperLib.JS.BoundsOfPaths = function (paths, scale)\n{\n  if (!scale) scale = 1;\n  var bounds = ClipperLib.Clipper.GetBounds(paths);\n  bounds.left /= scale;\n  bounds.bottom /= scale;\n  bounds.right /= scale;\n  bounds.top /= scale;\n  return bounds;\n};\n// Clean() joins vertices that are too near each other\n// and causes distortion to offsetted polygons without cleaning\nClipperLib.JS.Clean = function (polygon, delta)\n{\n  if (!(polygon instanceof Array)) return [];\n  var isPolygons = polygon[0] instanceof Array;\n  var polygon = ClipperLib.JS.Clone(polygon);\n  if (typeof delta != \"number\" || delta === null)\n  {\n    ClipperLib.Error(\"Delta is not a number in Clean().\");\n    return polygon;\n  }\n  if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || delta < 0) return polygon;\n  if (!isPolygons) polygon = [polygon];\n  var k_length = polygon.length;\n  var len, poly, result, d, p, j, i;\n  var results = [];\n  for (var k = 0; k < k_length; k++)\n  {\n    poly = polygon[k];\n    len = poly.length;\n    if (len === 0) continue;\n    else if (len < 3)\n    {\n      result = poly;\n      results.push(result);\n      continue;\n    }\n    result = poly;\n    d = delta * delta;\n    //d = Math.floor(c_delta * c_delta);\n    p = poly[0];\n    j = 1;\n    for (i = 1; i < len; i++)\n    {\n      if ((poly[i].X - p.X) * (poly[i].X - p.X) +\n        (poly[i].Y - p.Y) * (poly[i].Y - p.Y) <= d)\n        continue;\n      result[j] = poly[i];\n      p = poly[i];\n      j++;\n    }\n    p = poly[j - 1];\n    if ((poly[0].X - p.X) * (poly[0].X - p.X) +\n      (poly[0].Y - p.Y) * (poly[0].Y - p.Y) <= d)\n      j--;\n    if (j < len)\n      result.splice(j, len - j);\n    if (result.length) results.push(result);\n  }\n  if (!isPolygons && results.length) results = results[0];\n  else if (!isPolygons && results.length === 0) results = [];\n  else if (isPolygons && results.length === 0) results = [\n    []\n  ];\n  return results;\n}\n// Make deep copy of Polygons or Polygon\n// so that also IntPoint objects are cloned and not only referenced\n// This should be the fastest way\nClipperLib.JS.Clone = function (polygon)\n{\n  if (!(polygon instanceof Array)) return [];\n  if (polygon.length === 0) return [];\n  else if (polygon.length == 1 && polygon[0].length === 0) return [[]];\n  var isPolygons = polygon[0] instanceof Array;\n  if (!isPolygons) polygon = [polygon];\n  var len = polygon.length,\n    plen, i, j, result;\n  var results = new Array(len);\n  for (i = 0; i < len; i++)\n  {\n    plen = polygon[i].length;\n    result = new Array(plen);\n    for (j = 0; j < plen; j++)\n    {\n      result[j] = {\n        X: polygon[i][j].X,\n        Y: polygon[i][j].Y\n      };\n    }\n    results[i] = result;\n  }\n  if (!isPolygons) results = results[0];\n  return results;\n};\n// Removes points that doesn't affect much to the visual appearance.\n// If middle point is at or under certain distance (tolerance) of the line segment between \n// start and end point, the middle point is removed.\nClipperLib.JS.Lighten = function (polygon, tolerance)\n{\n  if (!(polygon instanceof Array)) return [];\n  if (typeof tolerance != \"number\" || tolerance === null)\n  {\n    ClipperLib.Error(\"Tolerance is not a number in Lighten().\")\n    return ClipperLib.JS.Clone(polygon);\n  }\n  if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || tolerance < 0)\n  {\n    return ClipperLib.JS.Clone(polygon);\n  }\n  if (!(polygon[0] instanceof Array)) polygon = [polygon];\n  var i, j, poly, k, poly2, plen, A, B, P, d, rem, addlast;\n  var bxax, byay, l, ax, ay;\n  var len = polygon.length;\n  var toleranceSq = tolerance * tolerance;\n  var results = [];\n  for (i = 0; i < len; i++)\n  {\n    poly = polygon[i];\n    plen = poly.length;\n    if (plen == 0) continue;\n    for (k = 0; k < 1000000; k++) // could be forever loop, but wiser to restrict max repeat count\n    {\n      poly2 = [];\n      plen = poly.length;\n      // the first have to added to the end, if first and last are not the same\n      // this way we ensure that also the actual last point can be removed if needed\n      if (poly[plen - 1].X != poly[0].X || poly[plen - 1].Y != poly[0].Y)\n      {\n        addlast = 1;\n        poly.push(\n        {\n          X: poly[0].X,\n          Y: poly[0].Y\n        });\n        plen = poly.length;\n      }\n      else addlast = 0;\n      rem = []; // Indexes of removed points\n      for (j = 0; j < plen - 2; j++)\n      {\n        A = poly[j]; // Start point of line segment\n        P = poly[j + 1]; // Middle point. This is the one to be removed.\n        B = poly[j + 2]; // End point of line segment\n        ax = A.X;\n        ay = A.Y;\n        bxax = B.X - ax;\n        byay = B.Y - ay;\n        if (bxax !== 0 || byay !== 0) // To avoid Nan, when A==P && P==B. And to avoid peaks (A==B && A!=P), which have lenght, but not area.\n        {\n          l = ((P.X - ax) * bxax + (P.Y - ay) * byay) / (bxax * bxax + byay * byay);\n          if (l > 1)\n          {\n            ax = B.X;\n            ay = B.Y;\n          }\n          else if (l > 0)\n          {\n            ax += bxax * l;\n            ay += byay * l;\n          }\n        }\n        bxax = P.X - ax;\n        byay = P.Y - ay;\n        d = bxax * bxax + byay * byay;\n        if (d <= toleranceSq)\n        {\n          rem[j + 1] = 1;\n          j++; // when removed, transfer the pointer to the next one\n        }\n      }\n      // add all unremoved points to poly2\n      poly2.push(\n      {\n        X: poly[0].X,\n        Y: poly[0].Y\n      });\n      for (j = 1; j < plen - 1; j++)\n        if (!rem[j]) poly2.push(\n        {\n          X: poly[j].X,\n          Y: poly[j].Y\n        });\n      poly2.push(\n      {\n        X: poly[plen - 1].X,\n        Y: poly[plen - 1].Y\n      });\n      // if the first point was added to the end, remove it\n      if (addlast) poly.pop();\n      // break, if there was not anymore removed points\n      if (!rem.length) break;\n      // else continue looping using poly2, to check if there are points to remove\n      else poly = poly2;\n    }\n    plen = poly2.length;\n    // remove duplicate from end, if needed\n    if (poly2[plen - 1].X == poly2[0].X && poly2[plen - 1].Y == poly2[0].Y)\n    {\n      poly2.pop();\n    }\n    if (poly2.length > 2) // to avoid two-point-polygons\n      results.push(poly2);\n  }\n  if (!polygon[0] instanceof Array) results = results[0];\n  if (typeof (results) == \"undefined\") results = [\n    []\n  ];\n  return results;\n}\nClipperLib.JS.PerimeterOfPath = function (path, closed, scale)\n{\n  if (typeof (path) == \"undefined\") return 0;\n  var sqrt = Math.sqrt;\n  var perimeter = 0.0;\n  var p1, p2, p1x = 0.0,\n    p1y = 0.0,\n    p2x = 0.0,\n    p2y = 0.0;\n  var j = path.length;\n  if (j < 2) return 0;\n  if (closed)\n  {\n    path[j] = path[0];\n    j++;\n  }\n  while (--j)\n  {\n    p1 = path[j];\n    p1x = p1.X;\n    p1y = p1.Y;\n    p2 = path[j - 1];\n    p2x = p2.X;\n    p2y = p2.Y;\n    perimeter += sqrt((p1x - p2x) * (p1x - p2x) + (p1y - p2y) * (p1y - p2y));\n  }\n  if (closed) path.pop();\n  return perimeter / scale;\n};\nClipperLib.JS.PerimeterOfPaths = function (paths, closed, scale)\n{\n  if (!scale) scale = 1;\n  var perimeter = 0;\n  for (var i = 0; i < paths.length; i++)\n  {\n    perimeter += ClipperLib.JS.PerimeterOfPath(paths[i], closed, scale);\n  }\n  return perimeter;\n};\nClipperLib.JS.ScaleDownPath = function (path, scale)\n{\n  var i, p;\n  if (!scale) scale = 1;\n  i = path.length;\n  while (i--)\n  {\n    p = path[i];\n    p.X = p.X / scale;\n    p.Y = p.Y / scale;\n  }\n};\nClipperLib.JS.ScaleDownPaths = function (paths, scale)\n{\n  var i, j, p, round = Math.round;\n  if (!scale) scale = 1;\n  i = paths.length;\n  while (i--)\n  {\n    j = paths[i].length;\n    while (j--)\n    {\n      p = paths[i][j];\n      p.X = p.X / scale;\n      p.Y = p.Y / scale;\n    }\n  }\n};\nClipperLib.JS.ScaleUpPath = function (path, scale)\n{\n  var i, p, round = Math.round;\n  if (!scale) scale = 1;\n  i = path.length;\n  while (i--)\n  {\n    p = path[i];\n    p.X = round(p.X * scale);\n    p.Y = round(p.Y * scale);\n  }\n};\nClipperLib.JS.ScaleUpPaths = function (paths, scale)\n{\n  var i, j, p, round = Math.round;\n  if (!scale) scale = 1;\n  i = paths.length;\n  while (i--)\n  {\n    j = paths[i].length;\n    while (j--)\n    {\n      p = paths[i][j];\n      p.X = round(p.X * scale);\n      p.Y = round(p.Y * scale);\n    }\n  }\n};\nClipperLib.ExPolygons = function ()\n{\n  return [];\n}\nClipperLib.ExPolygon = function ()\n{\n  this.outer = null;\n  this.holes = null;\n};\nClipperLib.JS.AddOuterPolyNodeToExPolygons = function (polynode, expolygons)\n{\n  var ep = new ClipperLib.ExPolygon();\n  ep.outer = polynode.Contour();\n  var childs = polynode.Childs();\n  var ilen = childs.length;\n  ep.holes = new Array(ilen);\n  var node, n, i, j, childs2, jlen;\n  for (i = 0; i < ilen; i++)\n  {\n    node = childs[i];\n    ep.holes[i] = node.Contour();\n    //Add outer polygons contained by (nested within) holes ...\n    for (j = 0, childs2 = node.Childs(), jlen = childs2.length; j < jlen; j++)\n    {\n      n = childs2[j];\n      ClipperLib.JS.AddOuterPolyNodeToExPolygons(n, expolygons);\n    }\n  }\n  expolygons.push(ep);\n};\nClipperLib.JS.ExPolygonsToPaths = function (expolygons)\n{\n  var a, i, alen, ilen;\n  var paths = new ClipperLib.Paths();\n  for (a = 0, alen = expolygons.length; a < alen; a++)\n  {\n    paths.push(expolygons[a].outer);\n    for (i = 0, ilen = expolygons[a].holes.length; i < ilen; i++)\n    {\n      paths.push(expolygons[a].holes[i]);\n    }\n  }\n  return paths;\n}\nClipperLib.JS.PolyTreeToExPolygons = function (polytree)\n{\n  var expolygons = new ClipperLib.ExPolygons();\n  var node, i, childs, ilen;\n  for (i = 0, childs = polytree.Childs(), ilen = childs.length; i < ilen; i++)\n  {\n    node = childs[i];\n    ClipperLib.JS.AddOuterPolyNodeToExPolygons(node, expolygons);\n  }\n  return expolygons;\n};\n\n\nmodule.exports = ClipperLib;","!function(t,n){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=n():\"function\"==typeof define&&define.amd?define([],n):\"object\"==typeof exports?exports.OsmoseRequest=n():t.OsmoseRequest=n()}(this,function(){return function(t){function n(e){if(r[e])return r[e].exports;var o=r[e]={i:e,l:!1,exports:{}};return t[e].call(o.exports,o,o.exports,n),o.l=!0,o.exports}var r={};return n.m=t,n.c=r,n.d=function(t,r,e){n.o(t,r)||Object.defineProperty(t,r,{configurable:!1,enumerable:!0,get:e})},n.n=function(t){var r=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(r,\"a\",r),r},n.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},n.p=\"\",n(n.s=92)}([function(t,n,r){var e=r(2),o=r(25),i=r(10),u=r(17),c=r(13),a=function(t,n,r){var f,s,l,h,p=t&a.F,v=t&a.G,d=t&a.S,y=t&a.P,g=t&a.B,m=v?e:d?e[n]||(e[n]={}):(e[n]||{}).prototype,b=v?o:o[n]||(o[n]={}),w=b.prototype||(b.prototype={});v&&(r=n);for(f in r)s=!p&&m&&void 0!==m[f],l=(s?m:r)[f],h=g&&s?c(l,e):y&&\"function\"==typeof l?c(Function.call,l):l,m&&u(m,f,l,t&a.U),b[f]!=l&&i(b,f,h),y&&w[f]!=l&&(w[f]=l)};e.core=o,a.F=1,a.G=2,a.S=4,a.P=8,a.B=16,a.W=32,a.U=64,a.R=128,t.exports=a},function(t,n){t.exports=function(t){return\"object\"==typeof t?null!==t:\"function\"==typeof t}},function(t,n){var r=t.exports=\"undefined\"!=typeof window&&window.Math==Math?window:\"undefined\"!=typeof self&&self.Math==Math?self:Function(\"return this\")();\"number\"==typeof __g&&(__g=r)},function(t,n,r){var e=r(1);t.exports=function(t){if(!e(t))throw TypeError(t+\" is not an object!\");return t}},function(t,n,r){var e=r(52)(\"wks\"),o=r(20),i=r(2).Symbol,u=\"function\"==typeof i;(t.exports=function(t){return e[t]||(e[t]=u&&i[t]||(u?i:o)(\"Symbol.\"+t))}).store=e},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n,r){var e=r(3),o=r(66),i=r(36),u=Object.defineProperty;n.f=r(8)?Object.defineProperty:function(t,n,r){if(e(t),n=i(n,!0),e(r),o)try{return u(t,n,r)}catch(t){}if(\"get\"in r||\"set\"in r)throw TypeError(\"Accessors not supported!\");return\"value\"in r&&(t[n]=r.value),t}},function(t,n,r){var e=r(22),o=Math.min;t.exports=function(t){return t>0?o(e(t),9007199254740991):0}},function(t,n,r){t.exports=!r(5)(function(){return 7!=Object.defineProperty({},\"a\",{get:function(){return 7}}).a})},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n,r){var e=r(6),o=r(19);t.exports=r(8)?function(t,n,r){return e.f(t,n,o(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(49),o=r(23);t.exports=function(t){return e(o(t))}},function(t,n,r){var e=r(0),o=r(25),i=r(5);t.exports=function(t,n){var r=(o.Object||{})[t]||Object[t],u={};u[t]=n(r),e(e.S+e.F*i(function(){r(1)}),\"Object\",u)}},function(t,n,r){var e=r(21);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,o){return t.call(n,r,e,o)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(23);t.exports=function(t){return Object(e(t))}},function(t,n,r){\"use strict\";if(r(8)){var e=r(26),o=r(2),i=r(5),u=r(0),c=r(48),a=r(67),f=r(13),s=r(28),l=r(19),h=r(10),p=r(27),v=r(22),d=r(7),y=r(68),g=r(30),m=r(36),b=r(9),w=r(56),_=r(1),x=r(14),S=r(57),E=r(38),O=r(33),P=r(37).f,A=r(58),j=r(20),M=r(4),R=r(39),F=r(50),T=r(55),L=r(59),I=r(32),k=r(42),B=r(41),N=r(54),C=r(74),U=r(6),D=r(16),W=U.f,q=D.f,G=o.RangeError,V=o.TypeError,H=o.Uint8Array,z=Array.prototype,Y=a.ArrayBuffer,K=a.DataView,J=R(0),X=R(2),Q=R(3),$=R(4),Z=R(5),tt=R(6),nt=F(!0),rt=F(!1),et=L.values,ot=L.keys,it=L.entries,ut=z.lastIndexOf,ct=z.reduce,at=z.reduceRight,ft=z.join,st=z.sort,lt=z.slice,ht=z.toString,pt=z.toLocaleString,vt=M(\"iterator\"),dt=M(\"toStringTag\"),yt=j(\"typed_constructor\"),gt=j(\"def_constructor\"),mt=c.CONSTR,bt=c.TYPED,wt=c.VIEW,_t=R(1,function(t,n){return Pt(T(t,t[gt]),n)}),xt=i(function(){return 1===new H(new Uint16Array([1]).buffer)[0]}),St=!!H&&!!H.prototype.set&&i(function(){new H(1).set({})}),Et=function(t,n){var r=v(t);if(r<0||r%n)throw G(\"Wrong offset!\");return r},Ot=function(t){if(_(t)&&bt in t)return t;throw V(t+\" is not a typed array!\")},Pt=function(t,n){if(!(_(t)&&yt in t))throw V(\"It is not a typed array constructor!\");return new t(n)},At=function(t,n){return jt(T(t,t[gt]),n)},jt=function(t,n){for(var r=0,e=n.length,o=Pt(t,e);e>r;)o[r]=n[r++];return o},Mt=function(t,n,r){W(t,n,{get:function(){return this._d[r]}})},Rt=function(t){var n,r,e,o,i,u,c=x(t),a=arguments.length,s=a>1?arguments[1]:void 0,l=void 0!==s,h=A(c);if(void 0!=h&&!S(h)){for(u=h.call(c),e=[],n=0;!(i=u.next()).done;n++)e.push(i.value);c=e}for(l&&a>2&&(s=f(s,arguments[2],2)),n=0,r=d(c.length),o=Pt(this,r);r>n;n++)o[n]=l?s(c[n],n):c[n];return o},Ft=function(){for(var t=0,n=arguments.length,r=Pt(this,n);n>t;)r[t]=arguments[t++];return r},Tt=!!H&&i(function(){pt.call(new H(1))}),Lt=function(){return pt.apply(Tt?lt.call(Ot(this)):Ot(this),arguments)},It={copyWithin:function(t,n){return C.call(Ot(this),t,n,arguments.length>2?arguments[2]:void 0)},every:function(t){return $(Ot(this),t,arguments.length>1?arguments[1]:void 0)},fill:function(t){return N.apply(Ot(this),arguments)},filter:function(t){return At(this,X(Ot(this),t,arguments.length>1?arguments[1]:void 0))},find:function(t){return Z(Ot(this),t,arguments.length>1?arguments[1]:void 0)},findIndex:function(t){return tt(Ot(this),t,arguments.length>1?arguments[1]:void 0)},forEach:function(t){J(Ot(this),t,arguments.length>1?arguments[1]:void 0)},indexOf:function(t){return rt(Ot(this),t,arguments.length>1?arguments[1]:void 0)},includes:function(t){return nt(Ot(this),t,arguments.length>1?arguments[1]:void 0)},join:function(t){return ft.apply(Ot(this),arguments)},lastIndexOf:function(t){return ut.apply(Ot(this),arguments)},map:function(t){return _t(Ot(this),t,arguments.length>1?arguments[1]:void 0)},reduce:function(t){return ct.apply(Ot(this),arguments)},reduceRight:function(t){return at.apply(Ot(this),arguments)},reverse:function(){for(var t,n=this,r=Ot(n).length,e=Math.floor(r/2),o=0;o<e;)t=n[o],n[o++]=n[--r],n[r]=t;return n},some:function(t){return Q(Ot(this),t,arguments.length>1?arguments[1]:void 0)},sort:function(t){return st.call(Ot(this),t)},subarray:function(t,n){var r=Ot(this),e=r.length,o=g(t,e);return new(T(r,r[gt]))(r.buffer,r.byteOffset+o*r.BYTES_PER_ELEMENT,d((void 0===n?e:g(n,e))-o))}},kt=function(t,n){return At(this,lt.call(Ot(this),t,n))},Bt=function(t){Ot(this);var n=Et(arguments[1],1),r=this.length,e=x(t),o=d(e.length),i=0;if(o+n>r)throw G(\"Wrong length!\");for(;i<o;)this[n+i]=e[i++]},Nt={entries:function(){return it.call(Ot(this))},keys:function(){return ot.call(Ot(this))},values:function(){return et.call(Ot(this))}},Ct=function(t,n){return _(t)&&t[bt]&&\"symbol\"!=typeof n&&n in t&&String(+n)==String(n)},Ut=function(t,n){return Ct(t,n=m(n,!0))?l(2,t[n]):q(t,n)},Dt=function(t,n,r){return!(Ct(t,n=m(n,!0))&&_(r)&&b(r,\"value\"))||b(r,\"get\")||b(r,\"set\")||r.configurable||b(r,\"writable\")&&!r.writable||b(r,\"enumerable\")&&!r.enumerable?W(t,n,r):(t[n]=r.value,t)};mt||(D.f=Ut,U.f=Dt),u(u.S+u.F*!mt,\"Object\",{getOwnPropertyDescriptor:Ut,defineProperty:Dt}),i(function(){ht.call({})})&&(ht=pt=function(){return ft.call(this)});var Wt=p({},It);p(Wt,Nt),h(Wt,vt,Nt.values),p(Wt,{slice:kt,set:Bt,constructor:function(){},toString:ht,toLocaleString:Lt}),Mt(Wt,\"buffer\",\"b\"),Mt(Wt,\"byteOffset\",\"o\"),Mt(Wt,\"byteLength\",\"l\"),Mt(Wt,\"length\",\"e\"),W(Wt,dt,{get:function(){return this[bt]}}),t.exports=function(t,n,r,a){a=!!a;var f=t+(a?\"Clamped\":\"\")+\"Array\",l=\"get\"+t,p=\"set\"+t,v=o[f],g=v||{},m=v&&O(v),b=!v||!c.ABV,x={},S=v&&v.prototype,A=function(t,r){var e=t._d;return e.v[l](r*n+e.o,xt)},j=function(t,r,e){var o=t._d;a&&(e=(e=Math.round(e))<0?0:e>255?255:255&e),o.v[p](r*n+o.o,e,xt)},M=function(t,n){W(t,n,{get:function(){return A(this,n)},set:function(t){return j(this,n,t)},enumerable:!0})};b?(v=r(function(t,r,e,o){s(t,v,f,\"_d\");var i,u,c,a,l=0,p=0;if(_(r)){if(!(r instanceof Y||\"ArrayBuffer\"==(a=w(r))||\"SharedArrayBuffer\"==a))return bt in r?jt(v,r):Rt.call(v,r);i=r,p=Et(e,n);var g=r.byteLength;if(void 0===o){if(g%n)throw G(\"Wrong length!\");if((u=g-p)<0)throw G(\"Wrong length!\")}else if((u=d(o)*n)+p>g)throw G(\"Wrong length!\");c=u/n}else c=y(r),u=c*n,i=new Y(u);for(h(t,\"_d\",{b:i,o:p,l:u,e:c,v:new K(i)});l<c;)M(t,l++)}),S=v.prototype=E(Wt),h(S,\"constructor\",v)):i(function(){v(1)})&&i(function(){new v(-1)})&&k(function(t){new v,new v(null),new v(1.5),new v(t)},!0)||(v=r(function(t,r,e,o){s(t,v,f);var i;return _(r)?r instanceof Y||\"ArrayBuffer\"==(i=w(r))||\"SharedArrayBuffer\"==i?void 0!==o?new g(r,Et(e,n),o):void 0!==e?new g(r,Et(e,n)):new g(r):bt in r?jt(v,r):Rt.call(v,r):new g(y(r))}),J(m!==Function.prototype?P(g).concat(P(m)):P(g),function(t){t in v||h(v,t,g[t])}),v.prototype=S,e||(S.constructor=v));var R=S[vt],F=!!R&&(\"values\"==R.name||void 0==R.name),T=Nt.values;h(v,yt,!0),h(S,bt,f),h(S,wt,!0),h(S,gt,v),(a?new v(1)[dt]==f:dt in S)||W(S,dt,{get:function(){return f}}),x[f]=v,u(u.G+u.W+u.F*(v!=g),x),u(u.S,f,{BYTES_PER_ELEMENT:n}),u(u.S+u.F*i(function(){g.of.call(v,1)}),f,{from:Rt,of:Ft}),\"BYTES_PER_ELEMENT\"in S||h(S,\"BYTES_PER_ELEMENT\",n),u(u.P,f,It),B(f),u(u.P+u.F*St,f,{set:Bt}),u(u.P+u.F*!F,f,Nt),e||S.toString==ht||(S.toString=ht),u(u.P+u.F*i(function(){new v(1).slice()}),f,{slice:kt}),u(u.P+u.F*(i(function(){return[1,2].toLocaleString()!=new v([1,2]).toLocaleString()})||!i(function(){S.toLocaleString.call([1,2])})),f,{toLocaleString:Lt}),I[f]=F?R:T,e||F||h(S,vt,T)}}else t.exports=function(){}},function(t,n,r){var e=r(40),o=r(19),i=r(11),u=r(36),c=r(9),a=r(66),f=Object.getOwnPropertyDescriptor;n.f=r(8)?f:function(t,n){if(t=i(t),n=u(n,!0),a)try{return f(t,n)}catch(t){}if(c(t,n))return o(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(2),o=r(10),i=r(9),u=r(20)(\"src\"),c=Function.toString,a=(\"\"+c).split(\"toString\");r(25).inspectSource=function(t){return c.call(t)},(t.exports=function(t,n,r,c){var f=\"function\"==typeof r;f&&(i(r,\"name\")||o(r,\"name\",n)),t[n]!==r&&(f&&(i(r,u)||o(r,u,t[n]?\"\"+t[n]:a.join(String(n)))),t===e?t[n]=r:c?t[n]?t[n]=r:o(t,n,r):(delete t[n],o(t,n,r)))})(Function.prototype,\"toString\",function(){return\"function\"==typeof this&&this[u]||c.call(this)})},function(t,n,r){var e=r(20)(\"meta\"),o=r(1),i=r(9),u=r(6).f,c=0,a=Object.isExtensible||function(){return!0},f=!r(5)(function(){return a(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:\"O\"+ ++c,w:{}}})},l=function(t,n){if(!o(t))return\"symbol\"==typeof t?t:(\"string\"==typeof t?\"S\":\"P\")+t;if(!i(t,e)){if(!a(t))return\"F\";if(!n)return\"E\";s(t)}return t[e].i},h=function(t,n){if(!i(t,e)){if(!a(t))return!0;if(!n)return!1;s(t)}return t[e].w},p=function(t){return f&&v.NEED&&a(t)&&!i(t,e)&&s(t),t},v=t.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:p}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return\"Symbol(\".concat(void 0===t?\"\":t,\")_\",(++r+e).toString(36))}},function(t,n){t.exports=function(t){if(\"function\"!=typeof t)throw TypeError(t+\" is not a function!\");return t}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError(\"Can't call method on  \"+t);return t}},function(t,n,r){var e=r(69),o=r(53);t.exports=Object.keys||function(t){return e(t,o)}},function(t,n){var r=t.exports={version:\"2.5.1\"};\"number\"==typeof __e&&(__e=r)},function(t,n){t.exports=!1},function(t,n,r){var e=r(17);t.exports=function(t,n,r){for(var o in n)e(t,o,n[o],r);return t}},function(t,n){t.exports=function(t,n,r,e){if(!(t instanceof n)||void 0!==e&&e in t)throw TypeError(r+\": incorrect invocation!\");return t}},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n,r){var e=r(22),o=Math.max,i=Math.min;t.exports=function(t,n){return t=e(t),t<0?o(t+n,0):i(t,n)}},function(t,n,r){var e=r(6).f,o=r(9),i=r(4)(\"toStringTag\");t.exports=function(t,n,r){t&&!o(t=r?t:t.prototype,i)&&e(t,i,{configurable:!0,value:n})}},function(t,n){t.exports={}},function(t,n,r){var e=r(9),o=r(14),i=r(51)(\"IE_PROTO\"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=o(t),e(t,i)?t[i]:\"function\"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,r){var e=r(4)(\"unscopables\"),o=Array.prototype;void 0==o[e]&&r(10)(o,e,{}),t.exports=function(t){o[e][t]=!0}},function(t,n,r){var e=r(1);t.exports=function(t,n){if(!e(t)||t._t!==n)throw TypeError(\"Incompatible receiver, \"+n+\" required!\");return t}},function(t,n,r){var e=r(1);t.exports=function(t,n){if(!e(t))return t;var r,o;if(n&&\"function\"==typeof(r=t.toString)&&!e(o=r.call(t)))return o;if(\"function\"==typeof(r=t.valueOf)&&!e(o=r.call(t)))return o;if(!n&&\"function\"==typeof(r=t.toString)&&!e(o=r.call(t)))return o;throw TypeError(\"Can't convert object to primitive value\")}},function(t,n,r){var e=r(69),o=r(53).concat(\"length\",\"prototype\");n.f=Object.getOwnPropertyNames||function(t){return e(t,o)}},function(t,n,r){var e=r(3),o=r(95),i=r(53),u=r(51)(\"IE_PROTO\"),c=function(){},a=function(){var t,n=r(47)(\"iframe\"),e=i.length;for(n.style.display=\"none\",r(70).appendChild(n),n.src=\"javascript:\",t=n.contentWindow.document,t.open(),t.write(\"<script>document.F=Object<\\/script>\"),t.close(),a=t.F;e--;)delete a.prototype[i[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c.prototype=e(t),r=new c,c.prototype=null,r[u]=t):r=a(),void 0===n?r:o(r,n)}},function(t,n,r){var e=r(13),o=r(49),i=r(14),u=r(7),c=r(96);t.exports=function(t,n){var r=1==t,a=2==t,f=3==t,s=4==t,l=6==t,h=5==t||l,p=n||c;return function(n,c,v){for(var d,y,g=i(n),m=o(g),b=e(c,v,3),w=u(m.length),_=0,x=r?p(n,w):a?p(n,0):void 0;w>_;_++)if((h||_ in m)&&(d=m[_],y=b(d,_,g),t))if(r)x[_]=y;else if(y)switch(t){case 3:return!0;case 5:return d;case 6:return _;case 2:x.push(d)}else if(s)return!1;return l?-1:f||s?s:x}}},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){\"use strict\";var e=r(2),o=r(6),i=r(8),u=r(4)(\"species\");t.exports=function(t){var n=e[t];i&&n&&!n[u]&&o.f(n,u,{configurable:!0,get:function(){return this}})}},function(t,n,r){var e=r(4)(\"iterator\"),o=!1;try{var i=[7][e]();i.return=function(){o=!0},Array.from(i,function(){throw 2})}catch(t){}t.exports=function(t,n){if(!n&&!o)return!1;var r=!1;try{var i=[7],u=i[e]();u.next=function(){return{done:r=!0}},i[e]=function(){return u},t(i)}catch(t){}return r}},function(t,n,r){var e=r(13),o=r(76),i=r(57),u=r(3),c=r(7),a=r(58),f={},s={},n=t.exports=function(t,n,r,l,h){var p,v,d,y,g=h?function(){return t}:a(t),m=e(r,l,n?2:1),b=0;if(\"function\"!=typeof g)throw TypeError(t+\" is not iterable!\");if(i(g)){for(p=c(t.length);p>b;b++)if((y=n?m(u(v=t[b])[0],v[1]):m(t[b]))===f||y===s)return y}else for(d=g.call(t);!(v=d.next()).done;)if((y=o(d,m,v.value,n))===f||y===s)return y};n.BREAK=f,n.RETURN=s},function(t,n,r){\"use strict\";var e=r(2),o=r(0),i=r(17),u=r(27),c=r(18),a=r(43),f=r(28),s=r(1),l=r(5),h=r(42),p=r(31),v=r(108);t.exports=function(t,n,r,d,y,g){var m=e[t],b=m,w=y?\"set\":\"add\",_=b&&b.prototype,x={},S=function(t){var n=_[t];i(_,t,\"delete\"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:\"has\"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:\"get\"==t?function(t){return g&&!s(t)?void 0:n.call(this,0===t?0:t)}:\"add\"==t?function(t){return n.call(this,0===t?0:t),this}:function(t,r){return n.call(this,0===t?0:t,r),this})};if(\"function\"==typeof b&&(g||_.forEach&&!l(function(){(new b).entries().next()}))){var E=new b,O=E[w](g?{}:-0,1)!=E,P=l(function(){E.has(1)}),A=h(function(t){new b(t)}),j=!g&&l(function(){for(var t=new b,n=5;n--;)t[w](n,n);return!t.has(-0)});A||(b=n(function(n,r){f(n,b,t);var e=v(new m,n,b);return void 0!=r&&a(r,y,e[w],e),e}),b.prototype=_,_.constructor=b),(P||j)&&(S(\"delete\"),S(\"has\"),y&&S(\"get\")),(j||O)&&S(w),g&&_.clear&&delete _.clear}else b=d.getConstructor(n,t,y,w),u(b.prototype,r),c.NEED=!0;return p(b,t),x[t]=b,o(o.G+o.W+o.F*(b!=m),x),g||d.setStrong(b,t,y),b}},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){\"use strict\";var e=r(10),o=r(17),i=r(5),u=r(23),c=r(4);t.exports=function(t,n,r){var a=c(t),f=r(u,a,\"\"[t]),s=f[0],l=f[1];i(function(){var n={};return n[a]=function(){return 7},7!=\"\"[t](n)})&&(o(String.prototype,t,s),e(RegExp.prototype,a,2==n?function(t,n){return l.call(t,this,n)}:function(t){return l.call(t,this)}))}},function(t,n,r){var e=r(1),o=r(2).document,i=e(o)&&e(o.createElement);t.exports=function(t){return i?o.createElement(t):{}}},function(t,n,r){for(var e,o=r(2),i=r(10),u=r(20),c=u(\"typed_array\"),a=u(\"view\"),f=!(!o.ArrayBuffer||!o.DataView),s=f,l=0,h=\"Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array\".split(\",\");l<9;)(e=o[h[l++]])?(i(e.prototype,c,!0),i(e.prototype,a,!0)):s=!1;t.exports={ABV:f,CONSTR:s,TYPED:c,VIEW:a}},function(t,n,r){var e=r(29);t.exports=Object(\"z\").propertyIsEnumerable(0)?Object:function(t){return\"String\"==e(t)?t.split(\"\"):Object(t)}},function(t,n,r){var e=r(11),o=r(7),i=r(30);t.exports=function(t){return function(n,r,u){var c,a=e(n),f=o(a.length),s=i(u,f);if(t&&r!=r){for(;f>s;)if((c=a[s++])!=c)return!0}else for(;f>s;s++)if((t||s in a)&&a[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){var e=r(52)(\"keys\"),o=r(20);t.exports=function(t){return e[t]||(e[t]=o(t))}},function(t,n,r){var e=r(2),o=e[\"__core-js_shared__\"]||(e[\"__core-js_shared__\"]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n){t.exports=\"constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf\".split(\",\")},function(t,n,r){\"use strict\";var e=r(14),o=r(30),i=r(7);t.exports=function(t){for(var n=e(this),r=i(n.length),u=arguments.length,c=o(u>1?arguments[1]:void 0,r),a=u>2?arguments[2]:void 0,f=void 0===a?r:o(a,r);f>c;)n[c++]=t;return n}},function(t,n,r){var e=r(3),o=r(21),i=r(4)(\"species\");t.exports=function(t,n){var r,u=e(t).constructor;return void 0===u||void 0==(r=e(u)[i])?n:o(r)}},function(t,n,r){var e=r(29),o=r(4)(\"toStringTag\"),i=\"Arguments\"==e(function(){return arguments}()),u=function(t,n){try{return t[n]}catch(t){}};t.exports=function(t){var n,r,c;return void 0===t?\"Undefined\":null===t?\"Null\":\"string\"==typeof(r=u(n=Object(t),o))?r:i?e(n):\"Object\"==(c=e(n))&&\"function\"==typeof n.callee?\"Arguments\":c}},function(t,n,r){var e=r(32),o=r(4)(\"iterator\"),i=Array.prototype;t.exports=function(t){return void 0!==t&&(e.Array===t||i[o]===t)}},function(t,n,r){var e=r(56),o=r(4)(\"iterator\"),i=r(32);t.exports=r(25).getIteratorMethod=function(t){if(void 0!=t)return t[o]||t[\"@@iterator\"]||i[e(t)]}},function(t,n,r){\"use strict\";var e=r(34),o=r(72),i=r(32),u=r(11);t.exports=r(73)(Array,\"Array\",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,o(1)):\"keys\"==n?o(0,r):\"values\"==n?o(0,t[r]):o(0,[r,t[r]])},\"values\"),i.Arguments=i.Array,e(\"keys\"),e(\"values\"),e(\"entries\")},function(t,n,r){var e,o,i,u=r(13),c=r(80),a=r(70),f=r(47),s=r(2),l=s.process,h=s.setImmediate,p=s.clearImmediate,v=s.MessageChannel,d=s.Dispatch,y=0,g={},m=function(){var t=+this;if(g.hasOwnProperty(t)){var n=g[t];delete g[t],n()}},b=function(t){m.call(t.data)};h&&p||(h=function(t){for(var n=[],r=1;arguments.length>r;)n.push(arguments[r++]);return g[++y]=function(){c(\"function\"==typeof t?t:Function(t),n)},e(y),y},p=function(t){delete g[t]},\"process\"==r(29)(l)?e=function(t){l.nextTick(u(m,t,1))}:d&&d.now?e=function(t){d.now(u(m,t,1))}:v?(o=new v,i=o.port2,o.port1.onmessage=b,e=u(i.postMessage,i,1)):s.addEventListener&&\"function\"==typeof postMessage&&!s.importScripts?(e=function(t){s.postMessage(t+\"\",\"*\")},s.addEventListener(\"message\",b,!1)):e=\"onreadystatechange\"in f(\"script\")?function(t){a.appendChild(f(\"script\")).onreadystatechange=function(){a.removeChild(this),m.call(t)}}:function(t){setTimeout(u(m,t,1),0)}),t.exports={set:h,clear:p}},function(t,n,r){var e=r(86),o=r(23);t.exports=function(t,n,r){if(e(n))throw TypeError(\"String#\"+r+\" doesn't accept regex!\");return String(o(t))}},function(t,n,r){var e=r(4)(\"match\");t.exports=function(t){var n=/./;try{\"/./\"[t](n)}catch(r){try{return n[e]=!1,!\"/./\"[t](n)}catch(t){}}return!0}},function(t,n,r){\"use strict\";var e=r(6),o=r(19);t.exports=function(t,n,r){n in t?e.f(t,n,o(0,r)):t[n]=r}},function(t,n){t.exports=Math.sign||function(t){return 0==(t=+t)||t!=t?t:t<0?-1:1}},function(t,n){var r=Math.expm1;t.exports=!r||r(10)>22025.465794806718||r(10)<22025.465794806718||-2e-17!=r(-2e-17)?function(t){return 0==(t=+t)?t:t>-1e-6&&t<1e-6?t+t*t/2:Math.exp(t)-1}:r},function(t,n,r){t.exports=!r(8)&&!r(5)(function(){return 7!=Object.defineProperty(r(47)(\"div\"),\"a\",{get:function(){return 7}}).a})},function(t,n,r){\"use strict\";function e(t,n,r){var e,o,i,u=Array(r),c=8*r-n-1,a=(1<<c)-1,f=a>>1,s=23===n?C(2,-24)-C(2,-77):0,l=0,h=t<0||0===t&&1/t<0?1:0;for(t=N(t),t!=t||t===k?(o=t!=t?1:0,e=a):(e=U(D(t)/W),t*(i=C(2,-e))<1&&(e--,i*=2),t+=e+f>=1?s/i:s*C(2,1-f),t*i>=2&&(e++,i/=2),e+f>=a?(o=0,e=a):e+f>=1?(o=(t*i-1)*C(2,n),e+=f):(o=t*C(2,f-1)*C(2,n),e=0));n>=8;u[l++]=255&o,o/=256,n-=8);for(e=e<<n|o,c+=n;c>0;u[l++]=255&e,e/=256,c-=8);return u[--l]|=128*h,u}function o(t,n,r){var e,o=8*r-n-1,i=(1<<o)-1,u=i>>1,c=o-7,a=r-1,f=t[a--],s=127&f;for(f>>=7;c>0;s=256*s+t[a],a--,c-=8);for(e=s&(1<<-c)-1,s>>=-c,c+=n;c>0;e=256*e+t[a],a--,c-=8);if(0===s)s=1-u;else{if(s===i)return e?NaN:f?-k:k;e+=C(2,n),s-=u}return(f?-1:1)*e*C(2,s-n)}function i(t){return t[3]<<24|t[2]<<16|t[1]<<8|t[0]}function u(t){return[255&t]}function c(t){return[255&t,t>>8&255]}function a(t){return[255&t,t>>8&255,t>>16&255,t>>24&255]}function f(t){return e(t,52,8)}function s(t){return e(t,23,4)}function l(t,n,r){P(t[M],n,{get:function(){return this[r]}})}function h(t,n,r,e){var o=+r,i=E(o);if(i+n>t[G])throw I(R);var u=t[q]._b,c=i+t[V],a=u.slice(c,c+n);return e?a:a.reverse()}function p(t,n,r,e,o,i){var u=+r,c=E(u);if(c+n>t[G])throw I(R);for(var a=t[q]._b,f=c+t[V],s=e(+o),l=0;l<n;l++)a[f+l]=s[i?l:n-l-1]}var v=r(2),d=r(8),y=r(26),g=r(48),m=r(10),b=r(27),w=r(5),_=r(28),x=r(22),S=r(7),E=r(68),O=r(37).f,P=r(6).f,A=r(54),j=r(31),M=\"prototype\",R=\"Wrong index!\",F=v.ArrayBuffer,T=v.DataView,L=v.Math,I=v.RangeError,k=v.Infinity,B=F,N=L.abs,C=L.pow,U=L.floor,D=L.log,W=L.LN2,q=d?\"_b\":\"buffer\",G=d?\"_l\":\"byteLength\",V=d?\"_o\":\"byteOffset\";if(g.ABV){if(!w(function(){F(1)})||!w(function(){new F(-1)})||w(function(){return new F,new F(1.5),new F(NaN),\"ArrayBuffer\"!=F.name})){F=function(t){return _(this,F),new B(E(t))};for(var H,z=F[M]=B[M],Y=O(B),K=0;Y.length>K;)(H=Y[K++])in F||m(F,H,B[H]);y||(z.constructor=F)}var J=new T(new F(2)),X=T[M].setInt8;J.setInt8(0,2147483648),J.setInt8(1,2147483649),!J.getInt8(0)&&J.getInt8(1)||b(T[M],{setInt8:function(t,n){X.call(this,t,n<<24>>24)},setUint8:function(t,n){X.call(this,t,n<<24>>24)}},!0)}else F=function(t){_(this,F,\"ArrayBuffer\");var n=E(t);this._b=A.call(Array(n),0),this[G]=n},T=function(t,n,r){_(this,T,\"DataView\"),_(t,F,\"DataView\");var e=t[G],o=x(n);if(o<0||o>e)throw I(\"Wrong offset!\");if(r=void 0===r?e-o:S(r),o+r>e)throw I(\"Wrong length!\");this[q]=t,this[V]=o,this[G]=r},d&&(l(F,\"byteLength\",\"_l\"),l(T,\"buffer\",\"_b\"),l(T,\"byteLength\",\"_l\"),l(T,\"byteOffset\",\"_o\")),b(T[M],{getInt8:function(t){return h(this,1,t)[0]<<24>>24},getUint8:function(t){return h(this,1,t)[0]},getInt16:function(t){var n=h(this,2,t,arguments[1]);return(n[1]<<8|n[0])<<16>>16},getUint16:function(t){var n=h(this,2,t,arguments[1]);return n[1]<<8|n[0]},getInt32:function(t){return i(h(this,4,t,arguments[1]))},getUint32:function(t){return i(h(this,4,t,arguments[1]))>>>0},getFloat32:function(t){return o(h(this,4,t,arguments[1]),23,4)},getFloat64:function(t){return o(h(this,8,t,arguments[1]),52,8)},setInt8:function(t,n){p(this,1,t,u,n)},setUint8:function(t,n){p(this,1,t,u,n)},setInt16:function(t,n){p(this,2,t,c,n,arguments[2])},setUint16:function(t,n){p(this,2,t,c,n,arguments[2])},setInt32:function(t,n){p(this,4,t,a,n,arguments[2])},setUint32:function(t,n){p(this,4,t,a,n,arguments[2])},setFloat32:function(t,n){p(this,4,t,s,n,arguments[2])},setFloat64:function(t,n){p(this,8,t,f,n,arguments[2])}});j(F,\"ArrayBuffer\"),j(T,\"DataView\"),m(T[M],g.VIEW,!0),n.ArrayBuffer=F,n.DataView=T},function(t,n,r){var e=r(22),o=r(7);t.exports=function(t){if(void 0===t)return 0;var n=e(t),r=o(n);if(n!==r)throw RangeError(\"Wrong length!\");return r}},function(t,n,r){var e=r(9),o=r(11),i=r(50)(!1),u=r(51)(\"IE_PROTO\");t.exports=function(t,n){var r,c=o(t),a=0,f=[];for(r in c)r!=u&&e(c,r)&&f.push(r);for(;n.length>a;)e(c,r=n[a++])&&(~i(f,r)||f.push(r));return f}},function(t,n,r){var e=r(2).document;t.exports=e&&e.documentElement},function(t,n,r){var e=r(29);t.exports=Array.isArray||function(t){return\"Array\"==e(t)}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,r){\"use strict\";var e=r(26),o=r(0),i=r(17),u=r(10),c=r(9),a=r(32),f=r(98),s=r(31),l=r(33),h=r(4)(\"iterator\"),p=!([].keys&&\"next\"in[].keys()),v=function(){return this};t.exports=function(t,n,r,d,y,g,m){f(r,n,d);var b,w,_,x=function(t){if(!p&&t in P)return P[t];switch(t){case\"keys\":case\"values\":return function(){return new r(this,t)}}return function(){return new r(this,t)}},S=n+\" Iterator\",E=\"values\"==y,O=!1,P=t.prototype,A=P[h]||P[\"@@iterator\"]||y&&P[y],j=A||x(y),M=y?E?x(\"entries\"):j:void 0,R=\"Array\"==n?P.entries||A:A;if(R&&(_=l(R.call(new t)))!==Object.prototype&&_.next&&(s(_,S,!0),e||c(_,h)||u(_,h,v)),E&&A&&\"values\"!==A.name&&(O=!0,j=function(){return A.call(this)}),e&&!m||!p&&!O&&P[h]||u(P,h,j),a[n]=j,a[S]=v,y)if(b={values:E?j:x(\"values\"),keys:g?j:x(\"keys\"),entries:M},m)for(w in b)w in P||i(P,w,b[w]);else o(o.P+o.F*(p||O),n,b);return b}},function(t,n,r){\"use strict\";var e=r(14),o=r(30),i=r(7);t.exports=[].copyWithin||function(t,n){var r=e(this),u=i(r.length),c=o(t,u),a=o(n,u),f=arguments.length>2?arguments[2]:void 0,s=Math.min((void 0===f?u:o(f,u))-a,u-c),l=1;for(a<c&&c<a+s&&(l=-1,a+=s-1,c+=s-1);s-- >0;)a in r?r[c]=r[a]:delete r[c],c+=l,a+=l;return r}},function(t,n,r){\"use strict\";var e=r(6).f,o=r(38),i=r(27),u=r(13),c=r(28),a=r(43),f=r(73),s=r(72),l=r(41),h=r(8),p=r(18).fastKey,v=r(35),d=h?\"_s\":\"size\",y=function(t,n){var r,e=p(n);if(\"F\"!==e)return t._i[e];for(r=t._f;r;r=r.n)if(r.k==n)return r};t.exports={getConstructor:function(t,n,r,f){var s=t(function(t,e){c(t,s,n,\"_i\"),t._t=n,t._i=o(null),t._f=void 0,t._l=void 0,t[d]=0,void 0!=e&&a(e,r,t[f],t)});return i(s.prototype,{clear:function(){for(var t=v(this,n),r=t._i,e=t._f;e;e=e.n)e.r=!0,e.p&&(e.p=e.p.n=void 0),delete r[e.i];t._f=t._l=void 0,t[d]=0},delete:function(t){var r=v(this,n),e=y(r,t);if(e){var o=e.n,i=e.p;delete r._i[e.i],e.r=!0,i&&(i.n=o),o&&(o.p=i),r._f==e&&(r._f=o),r._l==e&&(r._l=i),r[d]--}return!!e},forEach:function(t){v(this,n);for(var r,e=u(t,arguments.length>1?arguments[1]:void 0,3);r=r?r.n:this._f;)for(e(r.v,r.k,this);r&&r.r;)r=r.p},has:function(t){return!!y(v(this,n),t)}}),h&&e(s.prototype,\"size\",{get:function(){return v(this,n)[d]}}),s},def:function(t,n,r){var e,o,i=y(t,n);return i?i.v=r:(t._l=i={i:o=p(n,!0),k:n,v:r,p:e=t._l,n:void 0,r:!1},t._f||(t._f=i),e&&(e.n=i),t[d]++,\"F\"!==o&&(t._i[o]=i)),t},getEntry:y,setStrong:function(t,n,r){f(t,n,function(t,r){this._t=v(t,n),this._k=r,this._l=void 0},function(){for(var t=this,n=t._k,r=t._l;r&&r.r;)r=r.p;return t._t&&(t._l=r=r?r.n:t._t._f)?\"keys\"==n?s(0,r.k):\"values\"==n?s(0,r.v):s(0,[r.k,r.v]):(t._t=void 0,s(1))},r?\"entries\":\"values\",!r,!0),l(n)}}},function(t,n,r){var e=r(3);t.exports=function(t,n,r,o){try{return o?n(e(r)[0],r[1]):n(r)}catch(n){var i=t.return;throw void 0!==i&&e(i.call(t)),n}}},function(t,n,r){var e=r(1),o=r(3),i=function(t,n){if(o(t),!e(n)&&null!==n)throw TypeError(n+\": can't set as prototype!\")};t.exports={set:Object.setPrototypeOf||(\"__proto__\"in{}?function(t,n,e){try{e=r(13)(Function.call,r(16).f(Object.prototype,\"__proto__\").set,2),e(t,[]),n=!(t instanceof Array)}catch(t){n=!0}return function(t,r){return i(t,r),n?t.__proto__=r:e(t,r),t}}({},!1):void 0),check:i}},function(t,n,r){\"use strict\";var e=r(24),o=r(45),i=r(40),u=r(14),c=r(49),a=Object.assign;t.exports=!a||r(5)(function(){var t={},n={},r=Symbol(),e=\"abcdefghijklmnopqrst\";return t[r]=7,e.split(\"\").forEach(function(t){n[t]=t}),7!=a({},t)[r]||Object.keys(a({},n)).join(\"\")!=e})?function(t,n){for(var r=u(t),a=arguments.length,f=1,s=o.f,l=i.f;a>f;)for(var h,p=c(arguments[f++]),v=s?e(p).concat(s(p)):e(p),d=v.length,y=0;d>y;)l.call(p,h=v[y++])&&(r[h]=p[h]);return r}:a},function(t,n,r){\"use strict\";var e=r(27),o=r(18).getWeak,i=r(3),u=r(1),c=r(28),a=r(43),f=r(39),s=r(9),l=r(35),h=f(5),p=f(6),v=0,d=function(t){return t._l||(t._l=new y)},y=function(){this.a=[]},g=function(t,n){return h(t.a,function(t){return t[0]===n})};y.prototype={get:function(t){var n=g(this,t);if(n)return n[1]},has:function(t){return!!g(this,t)},set:function(t,n){var r=g(this,t);r?r[1]=n:this.a.push([t,n])},delete:function(t){var n=p(this.a,function(n){return n[0]===t});return~n&&this.a.splice(n,1),!!~n}},t.exports={getConstructor:function(t,n,r,i){var f=t(function(t,e){c(t,f,n,\"_i\"),t._t=n,t._i=v++,t._l=void 0,void 0!=e&&a(e,r,t[i],t)});return e(f.prototype,{delete:function(t){if(!u(t))return!1;var r=o(t);return!0===r?d(l(this,n)).delete(t):r&&s(r,this._i)&&delete r[this._i]},has:function(t){if(!u(t))return!1;var r=o(t);return!0===r?d(l(this,n)).has(t):r&&s(r,this._i)}}),f},def:function(t,n,r){var e=o(i(n),!0);return!0===e?d(t).set(n,r):e[t._i]=r,t},ufstore:d}},function(t,n){t.exports=function(t,n,r){var e=void 0===r;switch(n.length){case 0:return e?t():t.call(r);case 1:return e?t(n[0]):t.call(r,n[0]);case 2:return e?t(n[0],n[1]):t.call(r,n[0],n[1]);case 3:return e?t(n[0],n[1],n[2]):t.call(r,n[0],n[1],n[2]);case 4:return e?t(n[0],n[1],n[2],n[3]):t.call(r,n[0],n[1],n[2],n[3])}return t.apply(r,n)}},function(t,n,r){var e=r(37),o=r(45),i=r(3),u=r(2).Reflect;t.exports=u&&u.ownKeys||function(t){var n=e.f(i(t)),r=o.f;return r?n.concat(r(t)):n}},function(t,n,r){\"use strict\";function e(t){var n,r;this.promise=new t(function(t,e){if(void 0!==n||void 0!==r)throw TypeError(\"Bad Promise constructor\");n=t,r=e}),this.resolve=o(n),this.reject=o(r)}var o=r(21);t.exports.f=function(t){return new e(t)}},function(t,n,r){n.f=r(4)},function(t,n,r){var e=r(11),o=r(37).f,i={}.toString,u=\"object\"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return o(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&\"[object Window]\"==i.call(t)?c(t):o(e(t))}},function(t,n,r){\"use strict\";var e=r(22),o=r(23);t.exports=function(t){var n=String(o(this)),r=\"\",i=e(t);if(i<0||i==1/0)throw RangeError(\"Count can't be negative\");for(;i>0;(i>>>=1)&&(n+=n))1&i&&(r+=n);return r}},function(t,n,r){var e=r(1),o=r(29),i=r(4)(\"match\");t.exports=function(t){var n;return e(t)&&(void 0!==(n=t[i])?!!n:\"RegExp\"==o(t))}},function(t,n,r){var e=r(1),o=Math.floor;t.exports=function(t){return!e(t)&&isFinite(t)&&o(t)===t}},function(t,n){t.exports=Math.log1p||function(t){return(t=+t)>-1e-8&&t<1e-8?t-t*t/2:Math.log(1+t)}},function(t,n,r){var e=r(24),o=r(11),i=r(40).f;t.exports=function(t){return function(n){for(var r,u=o(n),c=e(u),a=c.length,f=0,s=[];a>f;)i.call(u,r=c[f++])&&s.push(t?[r,u[r]]:u[r]);return s}}},function(t,n,r){var e=r(7),o=r(85),i=r(23);t.exports=function(t,n,r,u){var c=String(i(t)),a=c.length,f=void 0===r?\" \":String(r),s=e(n);if(s<=a||\"\"==f)return c;var l=s-a,h=o.call(f,Math.ceil(l/f.length));return h.length>l&&(h=h.slice(0,l)),u?h+c:c+h}},function(t,n){t.exports={language:\"en\",endpoint:\"https://osmose.openstreetmap.fr/api/0.2\"}},function(t,n,r){\"use strict\";function e(t){return function(){var n=t.apply(this,arguments);return new Promise(function(t,r){function e(o,i){try{var u=n[o](i),c=u.value}catch(t){return void r(t)}if(!u.done)return Promise.resolve(c).then(function(t){e(\"next\",t)},function(t){e(\"throw\",t)});t(c)}return e(\"next\")})}}function o(t,n){if(!(t instanceof n))throw new TypeError(\"Cannot call a class as a function\")}Object.defineProperty(n,\"__esModule\",{value:!0});var i=Object.assign||function(t){for(var n=1;n<arguments.length;n++){var r=arguments[n];for(var e in r)Object.prototype.hasOwnProperty.call(r,e)&&(t[e]=r[e])}return t},u=function(){function t(t,n){for(var r=0;r<n.length;r++){var e=n[r];e.enumerable=e.enumerable||!1,e.configurable=!0,\"value\"in e&&(e.writable=!0),Object.defineProperty(t,e.key,e)}}return function(n,r,e){return r&&t(n.prototype,r),e&&t(n,e),n}}();r(93),r(94),r(99),r(100),r(101),r(102),r(103),r(104),r(105),r(106),r(107),r(109),r(110),r(111),r(112),r(113),r(115),r(116),r(117),r(118),r(119),r(120),r(121),r(122),r(123),r(124),r(125),r(126),r(130),r(133),r(134),r(135),r(136),r(137),r(138),r(139),r(140),r(141),r(142),r(143),r(144),r(146),r(147),r(148),r(149),r(151),r(152),r(153),r(154),r(155),r(157),r(158),r(159),r(160),r(161),r(162),r(163),r(164),r(165),r(166),r(59),r(167),r(168),r(169),r(170),r(171),r(172),r(173),r(174),r(175),r(176),r(177),r(178),r(179),r(180),r(181),r(183),r(184),r(185),r(186),r(187),r(188),r(189),r(190),r(191),r(192),r(193),r(194),r(195),r(196),r(197),r(198),r(199),r(200),r(201);var c=r(91),a=function(t){return t&&t.__esModule?t:{default:t}}(c),f=r(202),s=function(){function t(n){o(this,t),this._options=i({},a.default,n)}return u(t,[{key:\"fetchErrors\",value:function(){function t(t){return n.apply(this,arguments)}var n=e(regeneratorRuntime.mark(function t(n){var r;return regeneratorRuntime.wrap(function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,(0,f.fetchErrorsRequest)(this._options.endpoint,this._options.language,n);case 2:return r=t.sent,t.abrupt(\"return\",r.errors.map(function(t){return r.description.reduce(function(n,r,e){return n[r]=t[e],n},{})}));case 4:case\"end\":return t.stop()}},t,this)}));return t}()},{key:\"fetchError\",value:function(){function t(t){return n.apply(this,arguments)}var n=e(regeneratorRuntime.mark(function t(n){return regeneratorRuntime.wrap(function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,(0,f.fetchErrorRequest)(this._options.endpoint,this._options.language,n);case 2:return t.abrupt(\"return\",t.sent);case 3:case\"end\":return t.stop()}},t,this)}));return t}()},{key:\"closeError\",value:function(){function t(t){return n.apply(this,arguments)}var n=e(regeneratorRuntime.mark(function t(n){return regeneratorRuntime.wrap(function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,(0,f.closeErrorRequest)(this._options.endpoint,this._options.language,n);case 2:return t.abrupt(\"return\",t.sent);case 3:case\"end\":return t.stop()}},t,this)}));return t}()},{key:\"falseError\",value:function(){function t(t){return n.apply(this,arguments)}var n=e(regeneratorRuntime.mark(function t(n){return regeneratorRuntime.wrap(function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,(0,f.falseErrorRequest)(this._options.endpoint,this._options.language,n);case 2:return t.abrupt(\"return\",t.sent);case 3:case\"end\":return t.stop()}},t,this)}));return t}()},{key:\"fetchSupportedCountries\",value:function(){function t(){return n.apply(this,arguments)}var n=e(regeneratorRuntime.mark(function t(){var n;return regeneratorRuntime.wrap(function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,(0,f.fetchSupportedCountriesRequest)(this._options.endpoint,this._options.language);case 2:return n=t.sent,t.abrupt(\"return\",n.countries);case 4:case\"end\":return t.stop()}},t,this)}));return t}()},{key:\"fetchItemCategories\",value:function(){function t(){return n.apply(this,arguments)}var n=e(regeneratorRuntime.mark(function t(){var n;return regeneratorRuntime.wrap(function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,(0,f.fetchItemCategoriesRequest)(this._options.endpoint,this._options.language);case 2:return n=t.sent,t.abrupt(\"return\",n.categories.map(function(t){return{id:t.categ,name:t.menu,items:t.item.map(function(t){return{id:t.item,name:t.menu,tags:t.tags,count:t.number,levels:t.levels}})}}));case 4:case\"end\":return t.stop()}},t,this)}));return t}()},{key:\"fetchItems\",value:function(){function t(t){return n.apply(this,arguments)}var n=e(regeneratorRuntime.mark(function t(n){var r;return regeneratorRuntime.wrap(function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,(0,f.fetchItemsRequest)(this._options.endpoint,this._options.language);case 2:if(r=t.sent,!n){t.next=7;break}return t.abrupt(\"return\",r.items.map(function(t){return{id:t[0],name:t[1][n]}}));case 7:return t.abrupt(\"return\",r.items.map(function(t){return{id:t[0],name:t[1]}}));case 8:case\"end\":return t.stop()}},t,this)}));return t}()},{key:\"language\",get:function(){return this._options.language}},{key:\"endpoint\",get:function(){return this._options.endpoint}}]),t}();n.default=s},function(t,n,r){\"use strict\";var e=r(0),o=r(48),i=r(67),u=r(3),c=r(30),a=r(7),f=r(1),s=r(2).ArrayBuffer,l=r(55),h=i.ArrayBuffer,p=i.DataView,v=o.ABV&&s.isView,d=h.prototype.slice,y=o.VIEW;e(e.G+e.W+e.F*(s!==h),{ArrayBuffer:h}),e(e.S+e.F*!o.CONSTR,\"ArrayBuffer\",{isView:function(t){return v&&v(t)||f(t)&&y in t}}),e(e.P+e.U+e.F*r(5)(function(){return!new h(2).slice(1,void 0).byteLength}),\"ArrayBuffer\",{slice:function(t,n){if(void 0!==d&&void 0===n)return d.call(u(this),t);for(var r=u(this).byteLength,e=c(t,r),o=c(void 0===n?r:n,r),i=new(l(this,h))(a(o-e)),f=new p(this),s=new p(i),v=0;e<o;)s.setUint8(v++,f.getUint8(e++));return i}}),r(41)(\"ArrayBuffer\")},function(t,n,r){r(15)(\"Int8\",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){var e=r(6),o=r(3),i=r(24);t.exports=r(8)?Object.defineProperties:function(t,n){o(t);for(var r,u=i(n),c=u.length,a=0;c>a;)e.f(t,r=u[a++],n[r]);return t}},function(t,n,r){var e=r(97);t.exports=function(t,n){return new(e(t))(n)}},function(t,n,r){var e=r(1),o=r(71),i=r(4)(\"species\");t.exports=function(t){var n;return o(t)&&(n=t.constructor,\"function\"!=typeof n||n!==Array&&!o(n.prototype)||(n=void 0),e(n)&&null===(n=n[i])&&(n=void 0)),void 0===n?Array:n}},function(t,n,r){\"use strict\";var e=r(38),o=r(19),i=r(31),u={};r(10)(u,r(4)(\"iterator\"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:o(1,r)}),i(t,n+\" Iterator\")}},function(t,n,r){r(15)(\"Uint8\",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(15)(\"Uint8\",1,function(t){return function(n,r,e){return t(this,n,r,e)}},!0)},function(t,n,r){r(15)(\"Int16\",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(15)(\"Uint16\",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(15)(\"Int32\",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(15)(\"Uint32\",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(15)(\"Float32\",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(15)(\"Float64\",8,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){\"use strict\";var e=r(75),o=r(35);t.exports=r(44)(\"Map\",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{get:function(t){var n=e.getEntry(o(this,\"Map\"),t);return n&&n.v},set:function(t,n){return e.def(o(this,\"Map\"),0===t?0:t,n)}},e,!0)},function(t,n,r){var e=r(1),o=r(77).set;t.exports=function(t,n,r){var i,u=n.constructor;return u!==r&&\"function\"==typeof u&&(i=u.prototype)!==r.prototype&&e(i)&&o&&o(t,i),t}},function(t,n,r){\"use strict\";var e=r(75),o=r(35);t.exports=r(44)(\"Set\",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(o(this,\"Set\"),t=0===t?0:t,t)}},e)},function(t,n,r){\"use strict\";var e,o=r(39)(0),i=r(17),u=r(18),c=r(78),a=r(79),f=r(1),s=r(5),l=r(35),h=u.getWeak,p=Object.isExtensible,v=a.ufstore,d={},y=function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},g={get:function(t){if(f(t)){var n=h(t);return!0===n?v(l(this,\"WeakMap\")).get(t):n?n[this._i]:void 0}},set:function(t,n){return a.def(l(this,\"WeakMap\"),t,n)}},m=t.exports=r(44)(\"WeakMap\",y,g,a,!0,!0);s(function(){return 7!=(new m).set((Object.freeze||Object)(d),7).get(d)})&&(e=a.getConstructor(y,\"WeakMap\"),c(e.prototype,g),u.NEED=!0,o([\"delete\",\"has\",\"get\",\"set\"],function(t){var n=m.prototype,r=n[t];i(n,t,function(n,o){if(f(n)&&!p(n)){this._f||(this._f=new e);var i=this._f[t](n,o);return\"set\"==t?this:i}return r.call(this,n,o)})}))},function(t,n,r){\"use strict\";var e=r(79),o=r(35);r(44)(\"WeakSet\",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(o(this,\"WeakSet\"),t,!0)}},e,!1,!0)},function(t,n,r){var e=r(0),o=r(21),i=r(3),u=(r(2).Reflect||{}).apply,c=Function.apply;e(e.S+e.F*!r(5)(function(){u(function(){})}),\"Reflect\",{apply:function(t,n,r){var e=o(t),a=i(r);return u?u(e,n,a):c.call(e,n,a)}})},function(t,n,r){var e=r(0),o=r(38),i=r(21),u=r(3),c=r(1),a=r(5),f=r(114),s=(r(2).Reflect||{}).construct,l=a(function(){function t(){}return!(s(function(){},[],t)instanceof t)}),h=!a(function(){s(function(){})});e(e.S+e.F*(l||h),\"Reflect\",{construct:function(t,n){i(t),u(n);var r=arguments.length<3?t:i(arguments[2]);if(h&&!l)return s(t,n,r);if(t==r){switch(n.length){case 0:return new t;case 1:return new t(n[0]);case 2:return new t(n[0],n[1]);case 3:return new t(n[0],n[1],n[2]);case 4:return new t(n[0],n[1],n[2],n[3])}var e=[null];return e.push.apply(e,n),new(f.apply(t,e))}var a=r.prototype,p=o(c(a)?a:Object.prototype),v=Function.apply.call(t,p,n);return c(v)?v:p}})},function(t,n,r){\"use strict\";var e=r(21),o=r(1),i=r(80),u=[].slice,c={},a=function(t,n,r){if(!(n in c)){for(var e=[],o=0;o<n;o++)e[o]=\"a[\"+o+\"]\";c[n]=Function(\"F,a\",\"return new F(\"+e.join(\",\")+\")\")}return c[n](t,r)};t.exports=Function.bind||function(t){var n=e(this),r=u.call(arguments,1),c=function(){var e=r.concat(u.call(arguments));return this instanceof c?a(n,e.length,e):i(n,e,t)};return o(n.prototype)&&(c.prototype=n.prototype),c}},function(t,n,r){var e=r(6),o=r(0),i=r(3),u=r(36);o(o.S+o.F*r(5)(function(){Reflect.defineProperty(e.f({},1,{value:1}),1,{value:2})}),\"Reflect\",{defineProperty:function(t,n,r){i(t),n=u(n,!0),i(r);try{return e.f(t,n,r),!0}catch(t){return!1}}})},function(t,n,r){var e=r(0),o=r(16).f,i=r(3);e(e.S,\"Reflect\",{deleteProperty:function(t,n){var r=o(i(t),n);return!(r&&!r.configurable)&&delete t[n]}})},function(t,n,r){function e(t,n){var r,c,s=arguments.length<3?t:arguments[2];return f(t)===s?t[n]:(r=o.f(t,n))?u(r,\"value\")?r.value:void 0!==r.get?r.get.call(s):void 0:a(c=i(t))?e(c,n,s):void 0}var o=r(16),i=r(33),u=r(9),c=r(0),a=r(1),f=r(3);c(c.S,\"Reflect\",{get:e})},function(t,n,r){var e=r(16),o=r(0),i=r(3);o(o.S,\"Reflect\",{getOwnPropertyDescriptor:function(t,n){return e.f(i(t),n)}})},function(t,n,r){var e=r(0),o=r(33),i=r(3);e(e.S,\"Reflect\",{getPrototypeOf:function(t){return o(i(t))}})},function(t,n,r){var e=r(0);e(e.S,\"Reflect\",{has:function(t,n){return n in t}})},function(t,n,r){var e=r(0),o=r(3),i=Object.isExtensible;e(e.S,\"Reflect\",{isExtensible:function(t){return o(t),!i||i(t)}})},function(t,n,r){var e=r(0);e(e.S,\"Reflect\",{ownKeys:r(81)})},function(t,n,r){var e=r(0),o=r(3),i=Object.preventExtensions;e(e.S,\"Reflect\",{preventExtensions:function(t){o(t);try{return i&&i(t),!0}catch(t){return!1}}})},function(t,n,r){function e(t,n,r){var a,h,p=arguments.length<4?t:arguments[3],v=i.f(s(t),n);if(!v){if(l(h=u(t)))return e(h,n,r,p);v=f(0)}return c(v,\"value\")?!(!1===v.writable||!l(p))&&(a=i.f(p,n)||f(0),a.value=r,o.f(p,n,a),!0):void 0!==v.set&&(v.set.call(p,r),!0)}var o=r(6),i=r(16),u=r(33),c=r(9),a=r(0),f=r(19),s=r(3),l=r(1);a(a.S,\"Reflect\",{set:e})},function(t,n,r){var e=r(0),o=r(77);o&&e(e.S,\"Reflect\",{setPrototypeOf:function(t,n){o.check(t,n);try{return o.set(t,n),!0}catch(t){return!1}}})},function(t,n,r){\"use strict\";var e,o,i,u,c=r(26),a=r(2),f=r(13),s=r(56),l=r(0),h=r(1),p=r(21),v=r(28),d=r(43),y=r(55),g=r(60).set,m=r(127)(),b=r(82),w=r(128),_=r(129),x=a.TypeError,S=a.process,E=a.Promise,O=\"process\"==s(S),P=function(){},A=o=b.f,j=!!function(){try{var t=E.resolve(1),n=(t.constructor={})[r(4)(\"species\")]=function(t){t(P,P)};return(O||\"function\"==typeof PromiseRejectionEvent)&&t.then(P)instanceof n}catch(t){}}(),M=function(t){var n;return!(!h(t)||\"function\"!=typeof(n=t.then))&&n},R=function(t,n){if(!t._n){t._n=!0;var r=t._c;m(function(){for(var e=t._v,o=1==t._s,i=0;r.length>i;)!function(n){var r,i,u=o?n.ok:n.fail,c=n.resolve,a=n.reject,f=n.domain;try{u?(o||(2==t._h&&L(t),t._h=1),!0===u?r=e:(f&&f.enter(),r=u(e),f&&f.exit()),r===n.promise?a(x(\"Promise-chain cycle\")):(i=M(r))?i.call(r,c,a):c(r)):a(e)}catch(t){a(t)}}(r[i++]);t._c=[],t._n=!1,n&&!t._h&&F(t)})}},F=function(t){g.call(a,function(){var n,r,e,o=t._v,i=T(t);if(i&&(n=w(function(){O?S.emit(\"unhandledRejection\",o,t):(r=a.onunhandledrejection)?r({promise:t,reason:o}):(e=a.console)&&e.error&&e.error(\"Unhandled promise rejection\",o)}),t._h=O||T(t)?2:1),t._a=void 0,i&&n.e)throw n.v})},T=function(t){if(1==t._h)return!1;for(var n,r=t._a||t._c,e=0;r.length>e;)if(n=r[e++],n.fail||!T(n.promise))return!1;return!0},L=function(t){g.call(a,function(){var n;O?S.emit(\"rejectionHandled\",t):(n=a.onrejectionhandled)&&n({promise:t,reason:t._v})})},I=function(t){var n=this;n._d||(n._d=!0,n=n._w||n,n._v=t,n._s=2,n._a||(n._a=n._c.slice()),R(n,!0))},k=function(t){var n,r=this;if(!r._d){r._d=!0,r=r._w||r;try{if(r===t)throw x(\"Promise can't be resolved itself\");(n=M(t))?m(function(){var e={_w:r,_d:!1};try{n.call(t,f(k,e,1),f(I,e,1))}catch(t){I.call(e,t)}}):(r._v=t,r._s=1,R(r,!1))}catch(t){I.call({_w:r,_d:!1},t)}}};j||(E=function(t){v(this,E,\"Promise\",\"_h\"),p(t),e.call(this);try{t(f(k,this,1),f(I,this,1))}catch(t){I.call(this,t)}},e=function(t){this._c=[],this._a=void 0,this._s=0,this._d=!1,this._v=void 0,this._h=0,this._n=!1},e.prototype=r(27)(E.prototype,{then:function(t,n){var r=A(y(this,E));return r.ok=\"function\"!=typeof t||t,r.fail=\"function\"==typeof n&&n,r.domain=O?S.domain:void 0,this._c.push(r),this._a&&this._a.push(r),this._s&&R(this,!1),r.promise},catch:function(t){return this.then(void 0,t)}}),i=function(){var t=new e;this.promise=t,this.resolve=f(k,t,1),this.reject=f(I,t,1)},b.f=A=function(t){return t===E||t===u?new i(t):o(t)}),l(l.G+l.W+l.F*!j,{Promise:E}),r(31)(E,\"Promise\"),r(41)(\"Promise\"),u=r(25).Promise,l(l.S+l.F*!j,\"Promise\",{reject:function(t){var n=A(this);return(0,n.reject)(t),n.promise}}),l(l.S+l.F*(c||!j),\"Promise\",{resolve:function(t){return _(c&&this===u?E:this,t)}}),l(l.S+l.F*!(j&&r(42)(function(t){E.all(t).catch(P)})),\"Promise\",{all:function(t){var n=this,r=A(n),e=r.resolve,o=r.reject,i=w(function(){var r=[],i=0,u=1;d(t,!1,function(t){var c=i++,a=!1;r.push(void 0),u++,n.resolve(t).then(function(t){a||(a=!0,r[c]=t,--u||e(r))},o)}),--u||e(r)});return i.e&&o(i.v),r.promise},race:function(t){var n=this,r=A(n),e=r.reject,o=w(function(){d(t,!1,function(t){n.resolve(t).then(r.resolve,e)})});return o.e&&e(o.v),r.promise}})},function(t,n,r){var e=r(2),o=r(60).set,i=e.MutationObserver||e.WebKitMutationObserver,u=e.process,c=e.Promise,a=\"process\"==r(29)(u);t.exports=function(){var t,n,r,f=function(){var e,o;for(a&&(e=u.domain)&&e.exit();t;){o=t.fn,t=t.next;try{o()}catch(e){throw t?r():n=void 0,e}}n=void 0,e&&e.enter()};if(a)r=function(){u.nextTick(f)};else if(i){var s=!0,l=document.createTextNode(\"\");new i(f).observe(l,{characterData:!0}),r=function(){l.data=s=!s}}else if(c&&c.resolve){var h=c.resolve();r=function(){h.then(f)}}else r=function(){o.call(e,f)};return function(e){var o={fn:e,next:void 0};n&&(n.next=o),t||(t=o,r()),n=o}}},function(t,n){t.exports=function(t){try{return{e:!1,v:t()}}catch(t){return{e:!0,v:t}}}},function(t,n,r){var e=r(3),o=r(1),i=r(82);t.exports=function(t,n){if(e(t),o(n)&&n.constructor===t)return n;var r=i.f(t);return(0,r.resolve)(n),r.promise}},function(t,n,r){\"use strict\";var e=r(2),o=r(9),i=r(8),u=r(0),c=r(17),a=r(18).KEY,f=r(5),s=r(52),l=r(31),h=r(20),p=r(4),v=r(83),d=r(131),y=r(132),g=r(71),m=r(3),b=r(11),w=r(36),_=r(19),x=r(38),S=r(84),E=r(16),O=r(6),P=r(24),A=E.f,j=O.f,M=S.f,R=e.Symbol,F=e.JSON,T=F&&F.stringify,L=p(\"_hidden\"),I=p(\"toPrimitive\"),k={}.propertyIsEnumerable,B=s(\"symbol-registry\"),N=s(\"symbols\"),C=s(\"op-symbols\"),U=Object.prototype,D=\"function\"==typeof R,W=e.QObject,q=!W||!W.prototype||!W.prototype.findChild,G=i&&f(function(){return 7!=x(j({},\"a\",{get:function(){return j(this,\"a\",{value:7}).a}})).a})?function(t,n,r){var e=A(U,n);e&&delete U[n],j(t,n,r),e&&t!==U&&j(U,n,e)}:j,V=function(t){var n=N[t]=x(R.prototype);return n._k=t,n},H=D&&\"symbol\"==typeof R.iterator?function(t){return\"symbol\"==typeof t}:function(t){return t instanceof R},z=function(t,n,r){return t===U&&z(C,n,r),m(t),n=w(n,!0),m(r),o(N,n)?(r.enumerable?(o(t,L)&&t[L][n]&&(t[L][n]=!1),r=x(r,{enumerable:_(0,!1)})):(o(t,L)||j(t,L,_(1,{})),t[L][n]=!0),G(t,n,r)):j(t,n,r)},Y=function(t,n){m(t);for(var r,e=y(n=b(n)),o=0,i=e.length;i>o;)z(t,r=e[o++],n[r]);return t},K=function(t,n){return void 0===n?x(t):Y(x(t),n)},J=function(t){var n=k.call(this,t=w(t,!0));return!(this===U&&o(N,t)&&!o(C,t))&&(!(n||!o(this,t)||!o(N,t)||o(this,L)&&this[L][t])||n)},X=function(t,n){if(t=b(t),n=w(n,!0),t!==U||!o(N,n)||o(C,n)){var r=A(t,n);return!r||!o(N,n)||o(t,L)&&t[L][n]||(r.enumerable=!0),r}},Q=function(t){for(var n,r=M(b(t)),e=[],i=0;r.length>i;)o(N,n=r[i++])||n==L||n==a||e.push(n);return e},$=function(t){for(var n,r=t===U,e=M(r?C:b(t)),i=[],u=0;e.length>u;)!o(N,n=e[u++])||r&&!o(U,n)||i.push(N[n]);return i};D||(R=function(){if(this instanceof R)throw TypeError(\"Symbol is not a constructor!\");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===U&&n.call(C,r),o(this,L)&&o(this[L],t)&&(this[L][t]=!1),G(this,t,_(1,r))};return i&&q&&G(U,t,{configurable:!0,set:n}),V(t)},c(R.prototype,\"toString\",function(){return this._k}),E.f=X,O.f=z,r(37).f=S.f=Q,r(40).f=J,r(45).f=$,i&&!r(26)&&c(U,\"propertyIsEnumerable\",J,!0),v.f=function(t){return V(p(t))}),u(u.G+u.W+u.F*!D,{Symbol:R});for(var Z=\"hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables\".split(\",\"),tt=0;Z.length>tt;)p(Z[tt++]);for(var nt=P(p.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!D,\"Symbol\",{for:function(t){return o(B,t+=\"\")?B[t]:B[t]=R(t)},keyFor:function(t){if(!H(t))throw TypeError(t+\" is not a symbol!\");for(var n in B)if(B[n]===t)return n},useSetter:function(){q=!0},useSimple:function(){q=!1}}),u(u.S+u.F*!D,\"Object\",{create:K,defineProperty:z,defineProperties:Y,getOwnPropertyDescriptor:X,getOwnPropertyNames:Q,getOwnPropertySymbols:$}),F&&u(u.S+u.F*(!D||f(function(){var t=R();return\"[null]\"!=T([t])||\"{}\"!=T({a:t})||\"{}\"!=T(Object(t))})),\"JSON\",{stringify:function(t){if(void 0!==t&&!H(t)){for(var n,r,e=[t],o=1;arguments.length>o;)e.push(arguments[o++]);return n=e[1],\"function\"==typeof n&&(r=n),!r&&g(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!H(n))return n}),e[1]=n,T.apply(F,e)}}}),R.prototype[I]||r(10)(R.prototype,I,R.prototype.valueOf),l(R,\"Symbol\"),l(Math,\"Math\",!0),l(e.JSON,\"JSON\",!0)},function(t,n,r){var e=r(2),o=r(25),i=r(26),u=r(83),c=r(6).f;t.exports=function(t){var n=o.Symbol||(o.Symbol=i?{}:e.Symbol||{});\"_\"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){var e=r(24),o=r(45),i=r(40);t.exports=function(t){var n=e(t),r=o.f;if(r)for(var u,c=r(t),a=i.f,f=0;c.length>f;)a.call(t,u=c[f++])&&n.push(u);return n}},function(t,n,r){var e=r(1),o=r(18).onFreeze;r(12)(\"freeze\",function(t){return function(n){return t&&e(n)?t(o(n)):n}})},function(t,n,r){var e=r(1),o=r(18).onFreeze;r(12)(\"seal\",function(t){return function(n){return t&&e(n)?t(o(n)):n}})},function(t,n,r){var e=r(1),o=r(18).onFreeze;r(12)(\"preventExtensions\",function(t){return function(n){return t&&e(n)?t(o(n)):n}})},function(t,n,r){var e=r(1);r(12)(\"isFrozen\",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(1);r(12)(\"isSealed\",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(1);r(12)(\"isExtensible\",function(t){return function(n){return!!e(n)&&(!t||t(n))}})},function(t,n,r){var e=r(11),o=r(16).f;r(12)(\"getOwnPropertyDescriptor\",function(){return function(t,n){return o(e(t),n)}})},function(t,n,r){var e=r(14),o=r(33);r(12)(\"getPrototypeOf\",function(){return function(t){return o(e(t))}})},function(t,n,r){var e=r(14),o=r(24);r(12)(\"keys\",function(){return function(t){return o(e(t))}})},function(t,n,r){r(12)(\"getOwnPropertyNames\",function(){return r(84).f})},function(t,n,r){var e=r(0);e(e.S+e.F,\"Object\",{assign:r(78)})},function(t,n,r){var e=r(0);e(e.S,\"Object\",{is:r(145)})},function(t,n){t.exports=Object.is||function(t,n){return t===n?0!==t||1/t==1/n:t!=t&&n!=n}},function(t,n,r){var e=r(6).f,o=Function.prototype,i=/^\\s*function ([^ (]*)/;\"name\"in o||r(8)&&e(o,\"name\",{configurable:!0,get:function(){try{return(\"\"+this).match(i)[1]}catch(t){return\"\"}}})},function(t,n,r){var e=r(0),o=r(11),i=r(7);e(e.S,\"String\",{raw:function(t){for(var n=o(t.raw),r=i(n.length),e=arguments.length,u=[],c=0;r>c;)u.push(String(n[c++])),c<e&&u.push(String(arguments[c]));return u.join(\"\")}})},function(t,n,r){var e=r(0),o=r(30),i=String.fromCharCode,u=String.fromCodePoint;e(e.S+e.F*(!!u&&1!=u.length),\"String\",{fromCodePoint:function(t){for(var n,r=[],e=arguments.length,u=0;e>u;){if(n=+arguments[u++],o(n,1114111)!==n)throw RangeError(n+\" is not a valid code point\");r.push(n<65536?i(n):i(55296+((n-=65536)>>10),n%1024+56320))}return r.join(\"\")}})},function(t,n,r){\"use strict\";var e=r(0),o=r(150)(!1);e(e.P,\"String\",{codePointAt:function(t){return o(this,t)}})},function(t,n,r){var e=r(22),o=r(23);t.exports=function(t){return function(n,r){var i,u,c=String(o(n)),a=e(r),f=c.length;return a<0||a>=f?t?\"\":void 0:(i=c.charCodeAt(a),i<55296||i>56319||a+1===f||(u=c.charCodeAt(a+1))<56320||u>57343?t?c.charAt(a):i:t?c.slice(a,a+2):u-56320+(i-55296<<10)+65536)}}},function(t,n,r){var e=r(0);e(e.P,\"String\",{repeat:r(85)})},function(t,n,r){\"use strict\";var e=r(0),o=r(7),i=r(61),u=\"\".startsWith;e(e.P+e.F*r(62)(\"startsWith\"),\"String\",{startsWith:function(t){var n=i(this,t,\"startsWith\"),r=o(Math.min(arguments.length>1?arguments[1]:void 0,n.length)),e=String(t);return u?u.call(n,e,r):n.slice(r,r+e.length)===e}})},function(t,n,r){\"use strict\";var e=r(0),o=r(7),i=r(61),u=\"\".endsWith;e(e.P+e.F*r(62)(\"endsWith\"),\"String\",{endsWith:function(t){var n=i(this,t,\"endsWith\"),r=arguments.length>1?arguments[1]:void 0,e=o(n.length),c=void 0===r?e:Math.min(o(r),e),a=String(t);return u?u.call(n,a,c):n.slice(c-a.length,c)===a}})},function(t,n,r){\"use strict\";var e=r(0),o=r(61);e(e.P+e.F*r(62)(\"includes\"),\"String\",{includes:function(t){return!!~o(this,t,\"includes\").indexOf(t,arguments.length>1?arguments[1]:void 0)}})},function(t,n,r){r(8)&&\"g\"!=/./g.flags&&r(6).f(RegExp.prototype,\"flags\",{configurable:!0,get:r(156)})},function(t,n,r){\"use strict\";var e=r(3);t.exports=function(){var t=e(this),n=\"\";return t.global&&(n+=\"g\"),t.ignoreCase&&(n+=\"i\"),t.multiline&&(n+=\"m\"),t.unicode&&(n+=\"u\"),t.sticky&&(n+=\"y\"),n}},function(t,n,r){r(46)(\"match\",1,function(t,n,r){return[function(r){\"use strict\";var e=t(this),o=void 0==r?void 0:r[n];return void 0!==o?o.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(46)(\"replace\",2,function(t,n,r){return[function(e,o){\"use strict\";var i=t(this),u=void 0==e?void 0:e[n];return void 0!==u?u.call(e,i,o):r.call(String(i),e,o)},r]})},function(t,n,r){r(46)(\"split\",2,function(t,n,e){\"use strict\";var o=r(86),i=e,u=[].push,c=\"length\";if(\"c\"==\"abbc\".split(/(b)*/)[1]||4!=\"test\".split(/(?:)/,-1)[c]||2!=\"ab\".split(/(?:ab)*/)[c]||4!=\".\".split(/(.?)(.?)/)[c]||\".\".split(/()()/)[c]>1||\"\".split(/.?/)[c]){var a=void 0===/()??/.exec(\"\")[1];e=function(t,n){var r=String(this);if(void 0===t&&0===n)return[];if(!o(t))return i.call(r,t,n);var e,f,s,l,h,p=[],v=(t.ignoreCase?\"i\":\"\")+(t.multiline?\"m\":\"\")+(t.unicode?\"u\":\"\")+(t.sticky?\"y\":\"\"),d=0,y=void 0===n?4294967295:n>>>0,g=new RegExp(t.source,v+\"g\");for(a||(e=new RegExp(\"^\"+g.source+\"$(?!\\\\s)\",v));(f=g.exec(r))&&!((s=f.index+f[0][c])>d&&(p.push(r.slice(d,f.index)),!a&&f[c]>1&&f[0].replace(e,function(){for(h=1;h<arguments[c]-2;h++)void 0===arguments[h]&&(f[h]=void 0)}),f[c]>1&&f.index<r[c]&&u.apply(p,f.slice(1)),l=f[0][c],d=s,p[c]>=y));)g.lastIndex===f.index&&g.lastIndex++;return d===r[c]?!l&&g.test(\"\")||p.push(\"\"):p.push(r.slice(d)),p[c]>y?p.slice(0,y):p}}else\"0\".split(void 0,0)[c]&&(e=function(t,n){return void 0===t&&0===n?[]:i.call(this,t,n)});return[function(r,o){var i=t(this),u=void 0==r?void 0:r[n];return void 0!==u?u.call(r,i,o):e.call(String(i),r,o)},e]})},function(t,n,r){r(46)(\"search\",1,function(t,n,r){return[function(r){\"use strict\";var e=t(this),o=void 0==r?void 0:r[n];return void 0!==o?o.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){\"use strict\";var e=r(13),o=r(0),i=r(14),u=r(76),c=r(57),a=r(7),f=r(63),s=r(58);o(o.S+o.F*!r(42)(function(t){Array.from(t)}),\"Array\",{from:function(t){var n,r,o,l,h=i(t),p=\"function\"==typeof this?this:Array,v=arguments.length,d=v>1?arguments[1]:void 0,y=void 0!==d,g=0,m=s(h);if(y&&(d=e(d,v>2?arguments[2]:void 0,2)),void 0==m||p==Array&&c(m))for(n=a(h.length),r=new p(n);n>g;g++)f(r,g,y?d(h[g],g):h[g]);else for(l=m.call(h),r=new p;!(o=l.next()).done;g++)f(r,g,y?u(l,d,[o.value,g],!0):o.value);return r.length=g,r}})},function(t,n,r){\"use strict\";var e=r(0),o=r(63);e(e.S+e.F*r(5)(function(){function t(){}return!(Array.of.call(t)instanceof t)}),\"Array\",{of:function(){for(var t=0,n=arguments.length,r=new(\"function\"==typeof this?this:Array)(n);n>t;)o(r,t,arguments[t++]);return r.length=n,r}})},function(t,n,r){var e=r(0);e(e.P,\"Array\",{copyWithin:r(74)}),r(34)(\"copyWithin\")},function(t,n,r){\"use strict\";var e=r(0),o=r(39)(5),i=!0;\"find\"in[]&&Array(1).find(function(){i=!1}),e(e.P+e.F*i,\"Array\",{find:function(t){return o(this,t,arguments.length>1?arguments[1]:void 0)}}),r(34)(\"find\")},function(t,n,r){\"use strict\";var e=r(0),o=r(39)(6),i=\"findIndex\",u=!0;i in[]&&Array(1)[i](function(){u=!1}),e(e.P+e.F*u,\"Array\",{findIndex:function(t){return o(this,t,arguments.length>1?arguments[1]:void 0)}}),r(34)(i)},function(t,n,r){var e=r(0);e(e.P,\"Array\",{fill:r(54)}),r(34)(\"fill\")},function(t,n,r){var e=r(0),o=r(2).isFinite;e(e.S,\"Number\",{isFinite:function(t){return\"number\"==typeof t&&o(t)}})},function(t,n,r){var e=r(0);e(e.S,\"Number\",{isInteger:r(87)})},function(t,n,r){var e=r(0),o=r(87),i=Math.abs;e(e.S,\"Number\",{isSafeInteger:function(t){return o(t)&&i(t)<=9007199254740991}})},function(t,n,r){var e=r(0);e(e.S,\"Number\",{isNaN:function(t){return t!=t}})},function(t,n,r){var e=r(0);e(e.S,\"Number\",{EPSILON:Math.pow(2,-52)})},function(t,n,r){var e=r(0);e(e.S,\"Number\",{MIN_SAFE_INTEGER:-9007199254740991})},function(t,n,r){var e=r(0);e(e.S,\"Number\",{MAX_SAFE_INTEGER:9007199254740991})},function(t,n,r){var e=r(0),o=r(88),i=Math.sqrt,u=Math.acosh;e(e.S+e.F*!(u&&710==Math.floor(u(Number.MAX_VALUE))&&u(1/0)==1/0),\"Math\",{acosh:function(t){return(t=+t)<1?NaN:t>94906265.62425156?Math.log(t)+Math.LN2:o(t-1+i(t-1)*i(t+1))}})},function(t,n,r){function e(t){return isFinite(t=+t)&&0!=t?t<0?-e(-t):Math.log(t+Math.sqrt(t*t+1)):t}var o=r(0),i=Math.asinh;o(o.S+o.F*!(i&&1/i(0)>0),\"Math\",{asinh:e})},function(t,n,r){var e=r(0),o=Math.atanh;e(e.S+e.F*!(o&&1/o(-0)<0),\"Math\",{atanh:function(t){return 0==(t=+t)?t:Math.log((1+t)/(1-t))/2}})},function(t,n,r){var e=r(0),o=r(64);e(e.S,\"Math\",{cbrt:function(t){return o(t=+t)*Math.pow(Math.abs(t),1/3)}})},function(t,n,r){var e=r(0);e(e.S,\"Math\",{clz32:function(t){return(t>>>=0)?31-Math.floor(Math.log(t+.5)*Math.LOG2E):32}})},function(t,n,r){var e=r(0),o=Math.exp;e(e.S,\"Math\",{cosh:function(t){return(o(t=+t)+o(-t))/2}})},function(t,n,r){var e=r(0),o=r(65);e(e.S+e.F*(o!=Math.expm1),\"Math\",{expm1:o})},function(t,n,r){var e=r(0);e(e.S,\"Math\",{fround:r(182)})},function(t,n,r){var e=r(64),o=Math.pow,i=o(2,-52),u=o(2,-23),c=o(2,127)*(2-u),a=o(2,-126),f=function(t){return t+1/i-1/i};t.exports=Math.fround||function(t){var n,r,o=Math.abs(t),s=e(t);return o<a?s*f(o/a/u)*a*u:(n=(1+u/i)*o,r=n-(n-o),r>c||r!=r?s*(1/0):s*r)}},function(t,n,r){var e=r(0),o=Math.abs;e(e.S,\"Math\",{hypot:function(t,n){for(var r,e,i=0,u=0,c=arguments.length,a=0;u<c;)r=o(arguments[u++]),a<r?(e=a/r,i=i*e*e+1,a=r):r>0?(e=r/a,i+=e*e):i+=r;return a===1/0?1/0:a*Math.sqrt(i)}})},function(t,n,r){var e=r(0),o=Math.imul;e(e.S+e.F*r(5)(function(){return-5!=o(4294967295,5)||2!=o.length}),\"Math\",{imul:function(t,n){var r=+t,e=+n,o=65535&r,i=65535&e;return 0|o*i+((65535&r>>>16)*i+o*(65535&e>>>16)<<16>>>0)}})},function(t,n,r){var e=r(0);e(e.S,\"Math\",{log1p:r(88)})},function(t,n,r){var e=r(0);e(e.S,\"Math\",{log10:function(t){return Math.log(t)*Math.LOG10E}})},function(t,n,r){var e=r(0);e(e.S,\"Math\",{log2:function(t){return Math.log(t)/Math.LN2}})},function(t,n,r){var e=r(0);e(e.S,\"Math\",{sign:r(64)})},function(t,n,r){var e=r(0),o=r(65),i=Math.exp;e(e.S+e.F*r(5)(function(){return-2e-17!=!Math.sinh(-2e-17)}),\"Math\",{sinh:function(t){return Math.abs(t=+t)<1?(o(t)-o(-t))/2:(i(t-1)-i(-t-1))*(Math.E/2)}})},function(t,n,r){var e=r(0),o=r(65),i=Math.exp;e(e.S,\"Math\",{tanh:function(t){var n=o(t=+t),r=o(-t);return n==1/0?1:r==1/0?-1:(n-r)/(i(t)+i(-t))}})},function(t,n,r){var e=r(0);e(e.S,\"Math\",{trunc:function(t){return(t>0?Math.floor:Math.ceil)(t)}})},function(t,n,r){\"use strict\";var e=r(0),o=r(50)(!0);e(e.P,\"Array\",{includes:function(t){return o(this,t,arguments.length>1?arguments[1]:void 0)}}),r(34)(\"includes\")},function(t,n,r){var e=r(0),o=r(89)(!1);e(e.S,\"Object\",{values:function(t){return o(t)}})},function(t,n,r){var e=r(0),o=r(89)(!0);e(e.S,\"Object\",{entries:function(t){return o(t)}})},function(t,n,r){var e=r(0),o=r(81),i=r(11),u=r(16),c=r(63);e(e.S,\"Object\",{getOwnPropertyDescriptors:function(t){for(var n,r,e=i(t),a=u.f,f=o(e),s={},l=0;f.length>l;)void 0!==(r=a(e,n=f[l++]))&&c(s,n,r);return s}})},function(t,n,r){\"use strict\";var e=r(0),o=r(90);e(e.P,\"String\",{padStart:function(t){return o(this,t,arguments.length>1?arguments[1]:void 0,!0)}})},function(t,n,r){\"use strict\";var e=r(0),o=r(90);e(e.P,\"String\",{padEnd:function(t){return o(this,t,arguments.length>1?arguments[1]:void 0,!1)}})},function(t,n,r){var e=r(2),o=r(0),i=e.navigator,u=[].slice,c=!!i&&/MSIE .\\./.test(i.userAgent),a=function(t){return function(n,r){var e=arguments.length>2,o=!!e&&u.call(arguments,2);return t(e?function(){(\"function\"==typeof n?n:Function(n)).apply(this,o)}:n,r)}};o(o.G+o.B+o.F*c,{setTimeout:a(e.setTimeout),setInterval:a(e.setInterval)})},function(t,n,r){var e=r(0),o=r(60);e(e.G+e.B,{setImmediate:o.set,clearImmediate:o.clear})},function(t,n,r){for(var e=r(59),o=r(24),i=r(17),u=r(2),c=r(10),a=r(32),f=r(4),s=f(\"iterator\"),l=f(\"toStringTag\"),h=a.Array,p={CSSRuleList:!0,CSSStyleDeclaration:!1,CSSValueList:!1,ClientRectList:!1,DOMRectList:!1,DOMStringList:!1,DOMTokenList:!0,DataTransferItemList:!1,FileList:!1,HTMLAllCollection:!1,HTMLCollection:!1,HTMLFormElement:!1,HTMLSelectElement:!1,MediaList:!0,MimeTypeArray:!1,NamedNodeMap:!1,NodeList:!0,PaintRequestList:!1,Plugin:!1,PluginArray:!1,SVGLengthList:!1,SVGNumberList:!1,SVGPathSegList:!1,SVGPointList:!1,SVGStringList:!1,SVGTransformList:!1,SourceBufferList:!1,StyleSheetList:!0,TextTrackCueList:!1,TextTrackList:!1,TouchList:!1},v=o(p),d=0;d<v.length;d++){var y,g=v[d],m=p[g],b=u[g],w=b&&b.prototype;if(w&&(w[s]||c(w,s,h),w[l]||c(w,l,g),a[g]=h,m))for(y in e)w[y]||i(w,y,e[y],!0)}},function(t,n){!function(n){\"use strict\";function r(t,n,r,e){var i=n&&n.prototype instanceof o?n:o,u=Object.create(i.prototype),c=new p(e||[]);return u._invoke=f(t,r,c),u}function e(t,n,r){try{return{type:\"normal\",arg:t.call(n,r)}}catch(t){return{type:\"throw\",arg:t}}}function o(){}function i(){}function u(){}function c(t){[\"next\",\"throw\",\"return\"].forEach(function(n){t[n]=function(t){return this._invoke(n,t)}})}function a(t){function n(r,o,i,u){var c=e(t[r],t,o);if(\"throw\"!==c.type){var a=c.arg,f=a.value;return f&&\"object\"==typeof f&&m.call(f,\"__await\")?Promise.resolve(f.__await).then(function(t){n(\"next\",t,i,u)},function(t){n(\"throw\",t,i,u)}):Promise.resolve(f).then(function(t){a.value=t,i(a)},u)}u(c.arg)}function r(t,r){function e(){return new Promise(function(e,o){n(t,r,e,o)})}return o=o?o.then(e,e):e()}var o;this._invoke=r}function f(t,n,r){var o=O;return function(i,u){if(o===A)throw new Error(\"Generator is already running\");if(o===j){if(\"throw\"===i)throw u;return d()}for(r.method=i,r.arg=u;;){var c=r.delegate;if(c){var a=s(c,r);if(a){if(a===M)continue;return a}}if(\"next\"===r.method)r.sent=r._sent=r.arg;else if(\"throw\"===r.method){if(o===O)throw o=j,r.arg;r.dispatchException(r.arg)}else\"return\"===r.method&&r.abrupt(\"return\",r.arg);o=A;var f=e(t,n,r);if(\"normal\"===f.type){if(o=r.done?j:P,f.arg===M)continue;return{value:f.arg,done:r.done}}\"throw\"===f.type&&(o=j,r.method=\"throw\",r.arg=f.arg)}}}function s(t,n){var r=t.iterator[n.method];if(r===y){if(n.delegate=null,\"throw\"===n.method){if(t.iterator.return&&(n.method=\"return\",n.arg=y,s(t,n),\"throw\"===n.method))return M;n.method=\"throw\",n.arg=new TypeError(\"The iterator does not provide a 'throw' method\")}return M}var o=e(r,t.iterator,n.arg);if(\"throw\"===o.type)return n.method=\"throw\",n.arg=o.arg,n.delegate=null,M;var i=o.arg;return i?i.done?(n[t.resultName]=i.value,n.next=t.nextLoc,\"return\"!==n.method&&(n.method=\"next\",n.arg=y),n.delegate=null,M):i:(n.method=\"throw\",n.arg=new TypeError(\"iterator result is not an object\"),n.delegate=null,M)}function l(t){var n={tryLoc:t[0]};1 in t&&(n.catchLoc=t[1]),2 in t&&(n.finallyLoc=t[2],n.afterLoc=t[3]),this.tryEntries.push(n)}function h(t){var n=t.completion||{};n.type=\"normal\",delete n.arg,t.completion=n}function p(t){this.tryEntries=[{tryLoc:\"root\"}],t.forEach(l,this),this.reset(!0)}function v(t){if(t){var n=t[w];if(n)return n.call(t);if(\"function\"==typeof t.next)return t;if(!isNaN(t.length)){var r=-1,e=function n(){for(;++r<t.length;)if(m.call(t,r))return n.value=t[r],n.done=!1,n;return n.value=y,n.done=!0,n};return e.next=e}}return{next:d}}function d(){return{value:y,done:!0}}var y,g=Object.prototype,m=g.hasOwnProperty,b=\"function\"==typeof Symbol?Symbol:{},w=b.iterator||\"@@iterator\",_=b.asyncIterator||\"@@asyncIterator\",x=b.toStringTag||\"@@toStringTag\",S=\"object\"==typeof t,E=n.regeneratorRuntime;if(E)return void(S&&(t.exports=E));E=n.regeneratorRuntime=S?t.exports:{},E.wrap=r;var O=\"suspendedStart\",P=\"suspendedYield\",A=\"executing\",j=\"completed\",M={},R={};R[w]=function(){return this};var F=Object.getPrototypeOf,T=F&&F(F(v([])));T&&T!==g&&m.call(T,w)&&(R=T);var L=u.prototype=o.prototype=Object.create(R);i.prototype=L.constructor=u,u.constructor=i,u[x]=i.displayName=\"GeneratorFunction\",E.isGeneratorFunction=function(t){var n=\"function\"==typeof t&&t.constructor;return!!n&&(n===i||\"GeneratorFunction\"===(n.displayName||n.name))},E.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,u):(t.__proto__=u,x in t||(t[x]=\"GeneratorFunction\")),t.prototype=Object.create(L),t},E.awrap=function(t){return{__await:t}},c(a.prototype),a.prototype[_]=function(){return this},E.AsyncIterator=a,E.async=function(t,n,e,o){var i=new a(r(t,n,e,o));return E.isGeneratorFunction(n)?i:i.next().then(function(t){return t.done?t.value:i.next()})},c(L),L[x]=\"Generator\",L[w]=function(){return this},L.toString=function(){return\"[object Generator]\"},E.keys=function(t){var n=[];for(var r in t)n.push(r);return n.reverse(),function r(){for(;n.length;){var e=n.pop();if(e in t)return r.value=e,r.done=!1,r}return r.done=!0,r}},E.values=v,p.prototype={constructor:p,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=y,this.done=!1,this.delegate=null,this.method=\"next\",this.arg=y,this.tryEntries.forEach(h),!t)for(var n in this)\"t\"===n.charAt(0)&&m.call(this,n)&&!isNaN(+n.slice(1))&&(this[n]=y)},stop:function(){this.done=!0;var t=this.tryEntries[0],n=t.completion;if(\"throw\"===n.type)throw n.arg;return this.rval},dispatchException:function(t){function n(n,e){return i.type=\"throw\",i.arg=t,r.next=n,e&&(r.method=\"next\",r.arg=y),!!e}if(this.done)throw t;for(var r=this,e=this.tryEntries.length-1;e>=0;--e){var o=this.tryEntries[e],i=o.completion;if(\"root\"===o.tryLoc)return n(\"end\");if(o.tryLoc<=this.prev){var u=m.call(o,\"catchLoc\"),c=m.call(o,\"finallyLoc\");if(u&&c){if(this.prev<o.catchLoc)return n(o.catchLoc,!0);if(this.prev<o.finallyLoc)return n(o.finallyLoc)}else if(u){if(this.prev<o.catchLoc)return n(o.catchLoc,!0)}else{if(!c)throw new Error(\"try statement without catch or finally\");if(this.prev<o.finallyLoc)return n(o.finallyLoc)}}}},abrupt:function(t,n){for(var r=this.tryEntries.length-1;r>=0;--r){var e=this.tryEntries[r];if(e.tryLoc<=this.prev&&m.call(e,\"finallyLoc\")&&this.prev<e.finallyLoc){var o=e;break}}o&&(\"break\"===t||\"continue\"===t)&&o.tryLoc<=n&&n<=o.finallyLoc&&(o=null);var i=o?o.completion:{};return i.type=t,i.arg=n,o?(this.method=\"next\",this.next=o.finallyLoc,M):this.complete(i)},complete:function(t,n){if(\"throw\"===t.type)throw t.arg;return\"break\"===t.type||\"continue\"===t.type?this.next=t.arg:\"return\"===t.type?(this.rval=this.arg=t.arg,this.method=\"return\",this.next=\"end\"):\"normal\"===t.type&&n&&(this.next=n),M},finish:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),h(r),M}},catch:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.tryLoc===t){var e=r.completion;if(\"throw\"===e.type){var o=e.arg;h(r)}return o}}throw new Error(\"illegal catch attempt\")},delegateYield:function(t,n,r){return this.delegate={iterator:v(t),resultName:n,nextLoc:r},\"next\"===this.method&&(this.arg=y),M}}}(function(){return this}()||Function(\"return this\")())},function(t,n,r){\"use strict\";function e(t){return t&&t.__esModule?t:{default:t}}Object.defineProperty(n,\"__esModule\",{value:!0}),n.fetchItemsRequest=n.fetchItemCategoriesRequest=n.fetchSupportedCountriesRequest=n.falseErrorRequest=n.closeErrorRequest=n.fetchErrorRequest=n.fetchErrorsRequest=void 0;var o=r(203),i=e(o),u=r(91),c=e(u),a=r(204);n.fetchErrorsRequest=function(t,n,r){var e=t+\"/errors\"+(0,a.buildQueryString)(r),o={\"Accept-Language\":n||c.default.language};return(0,i.default)(e,{headers:o}).then(function(t){return t.json()}).then(function(t){if(!t||!t.description||!t.errors)throw\"The data received from the Osmose API is malformed (\"+e+\")\";return t})},n.fetchErrorRequest=function(t,n,r){var e=t+\"/error/\"+r,o={\"Accept-Language\":n||c.default.language};return(0,i.default)(e,{headers:o}).then(function(t){return t.json()}).then(function(t){if(!(t&&t.title&&t.lat&&t.lon))throw\"The data received from the Osmose API is malformed (\"+e+\")\";return t})},n.closeErrorRequest=function(t,n,r){var e=t+\"/error/\"+r+\"/done\",o={\"Accept-Language\":n||c.default.language};return(0,i.default)(e,{headers:o}).then(function(t){if(!t)throw\"The data received from the Osmose API is malformed (\"+e+\")\";return!0})},n.falseErrorRequest=function(t,n,r){var e=t+\"/error/\"+r+\"/false\",o={\"Accept-Language\":n||c.default.language};return(0,i.default)(e,{headers:o}).then(function(t){if(!t)throw\"The data received from the Osmose API is malformed (\"+e+\")\";return!0})},n.fetchSupportedCountriesRequest=function(t,n){var r=t+\"/meta/countries\",e={\"Accept-Language\":n||c.default.language};return(0,i.default)(r,{headers:e}).then(function(t){return t.json()}).then(function(t){if(!t||!t.countries)throw\"The data received from the Osmose API is malformed (\"+r+\")\";return t})},n.fetchItemCategoriesRequest=function(t,n){var r=t+\"/meta/categories\",e={\"Accept-Language\":n||c.default.language};return(0,i.default)(r,{headers:e}).then(function(t){return t.json()}).then(function(t){if(!t||!t.categories)throw\"The data received from the Osmose API is malformed (\"+r+\")\";return t})},n.fetchItemsRequest=function(t,n){var r=t+\"/meta/items\",e={\"Accept-Language\":n||c.default.language};return(0,i.default)(r,{headers:e}).then(function(t){return t.json()}).then(function(t){if(!t||!t.items)throw\"The data received from the Osmose API is malformed (\"+r+\")\";return t})}},function(t,n){var r={};!function(t){\"use strict\";function n(t){if(\"string\"!=typeof t&&(t=String(t)),/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(t))throw new TypeError(\"Invalid character in header field name\");return t.toLowerCase()}function r(t){return\"string\"!=typeof t&&(t=String(t)),t}function e(t){var n={next:function(){var n=t.shift();return{done:void 0===n,value:n}}};return g.iterable&&(n[Symbol.iterator]=function(){return n}),n}function o(t){this.map={},t instanceof o?t.forEach(function(t,n){this.append(n,t)},this):Array.isArray(t)?t.forEach(function(t){this.append(t[0],t[1])},this):t&&Object.getOwnPropertyNames(t).forEach(function(n){this.append(n,t[n])},this)}function i(t){if(t.bodyUsed)return Promise.reject(new TypeError(\"Already read\"));t.bodyUsed=!0}function u(t){return new Promise(function(n,r){t.onload=function(){n(t.result)},t.onerror=function(){r(t.error)}})}function c(t){var n=new FileReader,r=u(n);return n.readAsArrayBuffer(t),r}function a(t){var n=new FileReader,r=u(n);return n.readAsText(t),r}function f(t){for(var n=new Uint8Array(t),r=new Array(n.length),e=0;e<n.length;e++)r[e]=String.fromCharCode(n[e]);return r.join(\"\")}function s(t){if(t.slice)return t.slice(0);var n=new Uint8Array(t.byteLength);return n.set(new Uint8Array(t)),n.buffer}function l(){return this.bodyUsed=!1,this._initBody=function(t){if(this._bodyInit=t,t)if(\"string\"==typeof t)this._bodyText=t;else if(g.blob&&Blob.prototype.isPrototypeOf(t))this._bodyBlob=t;else if(g.formData&&FormData.prototype.isPrototypeOf(t))this._bodyFormData=t;else if(g.searchParams&&URLSearchParams.prototype.isPrototypeOf(t))this._bodyText=t.toString();else if(g.arrayBuffer&&g.blob&&b(t))this._bodyArrayBuffer=s(t.buffer),this._bodyInit=new Blob([this._bodyArrayBuffer]);else{if(!g.arrayBuffer||!ArrayBuffer.prototype.isPrototypeOf(t)&&!w(t))throw new Error(\"unsupported BodyInit type\");this._bodyArrayBuffer=s(t)}else this._bodyText=\"\";this.headers.get(\"content-type\")||(\"string\"==typeof t?this.headers.set(\"content-type\",\"text/plain;charset=UTF-8\"):this._bodyBlob&&this._bodyBlob.type?this.headers.set(\"content-type\",this._bodyBlob.type):g.searchParams&&URLSearchParams.prototype.isPrototypeOf(t)&&this.headers.set(\"content-type\",\"application/x-www-form-urlencoded;charset=UTF-8\"))},g.blob&&(this.blob=function(){var t=i(this);if(t)return t;if(this._bodyBlob)return Promise.resolve(this._bodyBlob);if(this._bodyArrayBuffer)return Promise.resolve(new Blob([this._bodyArrayBuffer]));if(this._bodyFormData)throw new Error(\"could not read FormData body as blob\");return Promise.resolve(new Blob([this._bodyText]))},this.arrayBuffer=function(){return this._bodyArrayBuffer?i(this)||Promise.resolve(this._bodyArrayBuffer):this.blob().then(c)}),this.text=function(){var t=i(this);if(t)return t;if(this._bodyBlob)return a(this._bodyBlob);if(this._bodyArrayBuffer)return Promise.resolve(f(this._bodyArrayBuffer));if(this._bodyFormData)throw new Error(\"could not read FormData body as text\");return Promise.resolve(this._bodyText)},g.formData&&(this.formData=function(){return this.text().then(v)}),this.json=function(){return this.text().then(JSON.parse)},this}function h(t){var n=t.toUpperCase();return _.indexOf(n)>-1?n:t}function p(t,n){n=n||{};var r=n.body;if(t instanceof p){if(t.bodyUsed)throw new TypeError(\"Already read\");this.url=t.url,this.credentials=t.credentials,n.headers||(this.headers=new o(t.headers)),this.method=t.method,this.mode=t.mode,r||null==t._bodyInit||(r=t._bodyInit,t.bodyUsed=!0)}else this.url=String(t);if(this.credentials=n.credentials||this.credentials||\"omit\",!n.headers&&this.headers||(this.headers=new o(n.headers)),this.method=h(n.method||this.method||\"GET\"),this.mode=n.mode||this.mode||null,this.referrer=null,(\"GET\"===this.method||\"HEAD\"===this.method)&&r)throw new TypeError(\"Body not allowed for GET or HEAD requests\");this._initBody(r)}function v(t){var n=new FormData;return t.trim().split(\"&\").forEach(function(t){if(t){var r=t.split(\"=\"),e=r.shift().replace(/\\+/g,\" \"),o=r.join(\"=\").replace(/\\+/g,\" \");n.append(decodeURIComponent(e),decodeURIComponent(o))}}),n}function d(t){var n=new o;return t.split(/\\r?\\n/).forEach(function(t){var r=t.split(\":\"),e=r.shift().trim();if(e){var o=r.join(\":\").trim();n.append(e,o)}}),n}function y(t,n){n||(n={}),this.type=\"default\",this.status=\"status\"in n?n.status:200,this.ok=this.status>=200&&this.status<300,this.statusText=\"statusText\"in n?n.statusText:\"OK\",this.headers=new o(n.headers),this.url=n.url||\"\",this._initBody(t)}if(!t.fetch){var g={searchParams:\"URLSearchParams\"in t,iterable:\"Symbol\"in t&&\"iterator\"in Symbol,blob:\"FileReader\"in t&&\"Blob\"in t&&function(){try{return new Blob,!0}catch(t){return!1}}(),formData:\"FormData\"in t,arrayBuffer:\"ArrayBuffer\"in t};if(g.arrayBuffer)var m=[\"[object Int8Array]\",\"[object Uint8Array]\",\"[object Uint8ClampedArray]\",\"[object Int16Array]\",\"[object Uint16Array]\",\"[object Int32Array]\",\"[object Uint32Array]\",\"[object Float32Array]\",\"[object Float64Array]\"],b=function(t){return t&&DataView.prototype.isPrototypeOf(t)},w=ArrayBuffer.isView||function(t){return t&&m.indexOf(Object.prototype.toString.call(t))>-1};o.prototype.append=function(t,e){t=n(t),e=r(e);var o=this.map[t];this.map[t]=o?o+\",\"+e:e},o.prototype.delete=function(t){delete this.map[n(t)]},o.prototype.get=function(t){return t=n(t),this.has(t)?this.map[t]:null},o.prototype.has=function(t){return this.map.hasOwnProperty(n(t))},o.prototype.set=function(t,e){this.map[n(t)]=r(e)},o.prototype.forEach=function(t,n){for(var r in this.map)this.map.hasOwnProperty(r)&&t.call(n,this.map[r],r,this)},o.prototype.keys=function(){var t=[];return this.forEach(function(n,r){t.push(r)}),e(t)},o.prototype.values=function(){var t=[];return this.forEach(function(n){t.push(n)}),e(t)},o.prototype.entries=function(){var t=[];return this.forEach(function(n,r){t.push([r,n])}),e(t)},g.iterable&&(o.prototype[Symbol.iterator]=o.prototype.entries);var _=[\"DELETE\",\"GET\",\"HEAD\",\"OPTIONS\",\"POST\",\"PUT\"];p.prototype.clone=function(){return new p(this,{body:this._bodyInit})},l.call(p.prototype),l.call(y.prototype),y.prototype.clone=function(){return new y(this._bodyInit,{status:this.status,statusText:this.statusText,headers:new o(this.headers),url:this.url})},y.error=function(){var t=new y(null,{status:0,statusText:\"\"});return t.type=\"error\",t};var x=[301,302,303,307,308];y.redirect=function(t,n){if(-1===x.indexOf(n))throw new RangeError(\"Invalid status code\");return new y(null,{status:n,headers:{location:t}})},t.Headers=o,t.Request=p,t.Response=y,t.fetch=function(t,n){return new Promise(function(r,e){var o=new p(t,n),i=new XMLHttpRequest;i.onload=function(){var t={status:i.status,statusText:i.statusText,headers:d(i.getAllResponseHeaders()||\"\")};t.url=\"responseURL\"in i?i.responseURL:t.headers.get(\"X-Request-URL\");var n=\"response\"in i?i.response:i.responseText;r(new y(n,t))},i.onerror=function(){e(new TypeError(\"Network request failed\"))},i.ontimeout=function(){e(new TypeError(\"Network request failed\"))},i.open(o.method,o.url,!0),\"include\"===o.credentials&&(i.withCredentials=!0),\"responseType\"in i&&g.blob&&(i.responseType=\"blob\"),o.headers.forEach(function(t,n){i.setRequestHeader(n,t)}),i.send(void 0===o._bodyInit?null:o._bodyInit)})},t.fetch.polyfill=!0}}(void 0!==r?r:this);var e=r.fetch;e.fetch=e,e.Response=r.Response,e.Headers=r.Headers,e.Request=r.Request,t.exports=e},function(t,n,r){\"use strict\";Object.defineProperty(n,\"__esModule\",{value:!0});n.buildQueryString=function(t){var n=[],r=!0,e=!1,o=void 0;try{for(var i,u=Object.keys(t)[Symbol.iterator]();!(r=(i=u.next()).done);r=!0){var c=i.value,a=encodeURIComponent(c),f=encodeURIComponent(t[c]);n.push(a+\"=\"+f)}}catch(t){e=!0,o=t}finally{try{!r&&u.return&&u.return()}finally{if(e)throw o}}return(n.length>0?\"?\":\"\")+n.join(\"&\")}}])});","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  return bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\nmodule.exports = bytesToUuid;\n","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\nvar rng;\n\nvar crypto = global.crypto || global.msCrypto; // for IE 11\nif (crypto && crypto.getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n  rng = function whatwgRNG() {\n    crypto.getRandomValues(rnds8);\n    return rnds8;\n  };\n}\n\nif (!rng) {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n  rng = function() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n\nmodule.exports = rng;\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options == 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === \"object\") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n","import L from 'leaflet';\nimport Clipper from 'js-clipper';\n\nexport default class Bounds {\n  loadedBounds = [];\n\n  /**\n   * Add bounds to the list of loaded bounds\n   * @param {L.Bounds} bounds\n   */\n  add(bounds) {\n    this.loadedBounds.push(bounds);\n  }\n\n  /**\n   * Return the list of the loaded bounds\n   * @return {L.Bounds[]}\n   */\n  get() {\n    return [...this.loadedBounds];\n  }\n\n  /**\n   * Clear the loaded bounds list\n   */\n  clear() {\n    this.loadedBounds = [];\n  }\n\n  /**\n   * Tells if a bounds area is already loaded\n   * @param {L.Bounds} bounds\n   * @return {boolean}\n   */\n  areFullyLoaded(bounds) {\n    if (this.loadedBounds.length === 0) {\n      return false;\n    }\n\n    const subjectClips = Bounds.buildClipsFromBoundsList([bounds]);\n    const knownClips = Bounds.buildClipsFromBoundsList(this.loadedBounds);\n    const clipper = new Clipper.Clipper();\n    const solutionPolyTree = new Clipper.PolyTree();\n\n    clipper.AddPaths(subjectClips, Clipper.PolyType.ptSubject, true);\n    clipper.AddPaths(knownClips, Clipper.PolyType.ptClip, true);\n\n    clipper.Execute(\n      Clipper.ClipType.ctDifference,\n      solutionPolyTree,\n      Clipper.PolyFillType.pftNonZero,\n      Clipper.PolyFillType.pftNonZero\n    );\n\n    const solutionExPolygons = Clipper.JS.PolyTreeToExPolygons(\n      solutionPolyTree\n    );\n\n    if (solutionExPolygons.length === 0) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Convert a bounds area into a clip\n   * @static\n   * @param {L.Bounds} bounds\n   * @return {{X: number, Y: number}[]}\n   */\n  static buildClipsFromBoundsList(bounds) {\n    return bounds.map(bound => [\n      {\n        X: bound._southWest.lng * 1000000,\n        Y: bound._southWest.lat * 1000000\n      },\n      {\n        X: bound._southWest.lng * 1000000,\n        Y: bound._northEast.lat * 1000000\n      },\n      {\n        X: bound._northEast.lng * 1000000,\n        Y: bound._northEast.lat * 1000000\n      },\n      {\n        X: bound._northEast.lng * 1000000,\n        Y: bound._southWest.lat * 1000000\n      }\n    ]);\n  }\n\n  /**\n   * Convert a clip into a bounds area\n   * @static\n   * @param {{X: number, Y: number}[]} clips\n   * @return {L.Bounds}\n   */\n  static buildBoundsListFromClips(clips) {\n    return clips.map(\n      clip =>\n        new L.LatLngBounds(\n          new L.LatLng(clip[0].Y / 1000000, clip[0].X / 1000000),\n          new L.LatLng(clip[2].Y / 1000000, clip[2].X / 1000000)\n        )\n    );\n  }\n}\n","import L from 'leaflet';\n\nexport default class Boxes {\n  boxStyle = {\n    stroke: false,\n    fillOpacity: 0.15,\n    clickable: false\n  };\n\n  map = null;\n  requestBoxes = L.featureGroup();\n  responseBoxes = L.featureGroup();\n\n  /**\n   * Store the map and add the request and response featureGroup to it\n   * @param {L.Map} map\n   */\n  setMap(map) {\n    this.map = map;\n    this.requestBoxes = L.featureGroup().addTo(map);\n    this.responseBoxes = L.featureGroup().addTo(map);\n  }\n\n  /**\n   * Create a rectangle to materialize the request area\n   * @param {L.Bounds} bounds\n   * @return {L.Rectangle}\n   */\n  buildRequestBox(bounds) {\n    return L.rectangle(bounds, {\n      ...this.boxStyle,\n      bounds: bounds,\n      color: 'tomato'\n    });\n  }\n\n  /**\n   * Create a rectangle to materialize the response area\n   * @param {L.Bounds} bounds\n   * @return {L.Rectangle}\n   */\n  buildResponseBox(bounds) {\n    return L.rectangle(bounds, {\n      ...this.boxStyle,\n      bounds: bounds,\n      color: 'black'\n    });\n  }\n\n  /**\n   * Add a request box to the map\n   * @param {L.Bounds} bounds\n   * @return {L.Rectangle}\n   */\n  addRequestBox(bounds) {\n    return this.requestBoxes\n      .addLayer(this.buildRequestBox(bounds))\n      .bringToBack();\n  }\n\n  /**\n   * Create a rectangle to materialize the response area\n   * @param {L.Bounds} bounds\n   * @return {L.Rectangle}\n   */\n  addResponseBox(bounds) {\n    return this.responseBoxes\n      .addLayer(this.buildResponseBox(bounds))\n      .bringToBack();\n  }\n\n  /**\n   * Create a bunch of rectangle to materialize some request areas\n   * @param {L.Rectangle[]} requestBoxes\n   */\n  addResponseBoxes(requestBoxes) {\n    requestBoxes.forEach(box => this.addResponseBox(box.getBounds()));\n    this.removeRequestBoxes();\n  }\n\n  /**\n   * Returns all the request boxes in an array\n   * @return {array}\n   */\n  getRequestBoxes() {\n    return this.requestBoxes.getLayers();\n  }\n\n  /**\n   * Returns all the response boxes in an array\n   * @return {array}\n   */\n  getResponseBoxes() {\n    return this.responseBoxes.getLayers();\n  }\n\n  /**\n   * Clear all the request and response boxes\n   */\n  clear() {\n    this.requestBoxes.clearLayers();\n    this.responseBoxes.clearLayers();\n  }\n\n  /**\n   * Remove a request box from its bounds\n   * @param {L.Bounds} bounds\n   * @return {boolean}\n   */\n  removeRequestBox(bounds) {\n    const requestBox = this.requestBoxes.getLayers().find(box => {\n      const boxBounds = box.getBounds();\n\n      return (\n        boxBounds._northEast.lng === bounds._northEast.lng &&\n        boxBounds._northEast.lat === bounds._northEast.lat &&\n        boxBounds._southWest.lng === bounds._southWest.lng &&\n        boxBounds._southWest.lat === bounds._southWest.lat\n      );\n    });\n\n    return this.requestBoxes.removeLayer(requestBox);\n  }\n\n  /**\n   * Remove all the request boxes from the map\n   * @return {boolean}\n   */\n  removeRequestBoxes() {\n    return this.requestBoxes.clearLayers();\n  }\n}\n","import L from 'leaflet';\n\n/**\n * Build a Leaflet marker from an icon\n * @param {L.LatLng} latLng\n * @return {L.Marker}\n */\nexport function buildIconMarker(latLng, markerIcon) {\n  return L.marker(latLng, { icon: markerIcon });\n}\n\n/**\n * Build a circular Leaflet marker\n * @param {L.LatLng} latLng\n * @return {L.Circle}\n */\nexport function buildCircleMarker(latLng) {\n  return L.circle(latLng, 20, {\n    stroke: false,\n    fillColor: 'tomato',\n    fillOpacity: 0.9\n  });\n}\n","import L from 'leaflet';\n\n/**\n * Remove the trailing slash from an URL and return it\n * @param  {string} url\n * @return {string} - The cleaned URL\n */\nexport function removeTrailingSlash(url) {\n  return url.replace(/\\/*$/, '');\n}\n\n/**\n * Increase the dimension of the bounds\n * @param  {L.Bounds} rawBounds - Leaflet bounds\n * @return {L.LatLngBounds} - Increased bounds\n */\nexport function buildLargerBounds(rawBounds) {\n  const bounds = { ...rawBounds };\n  const width = Math.abs(bounds._northEast.lng - bounds._southWest.lng);\n  const height = Math.abs(bounds._northEast.lat - bounds._southWest.lat);\n  const biggestDimension = width > height ? width : height;\n\n  bounds._southWest.lat -= biggestDimension / 2;\n  bounds._southWest.lng -= biggestDimension / 2;\n  bounds._northEast.lat += biggestDimension / 2;\n  bounds._northEast.lng += biggestDimension / 2;\n\n  return L.latLngBounds(\n    L.latLng(bounds._southWest.lat, bounds._southWest.lng),\n    L.latLng(bounds._northEast.lat, bounds._northEast.lng)\n  );\n}\n","import * as services from 'services';\n\nif (window && window.L) {\n  window.L.Nectarivore = { ...services };\n}\n\nexport default { ...services };\n","import L from 'leaflet';\nimport uuid from 'uuid/v4';\nimport Bounds from 'helpers/bounds';\nimport Boxes from 'helpers/boxes';\nimport { removeTrailingSlash } from 'helpers/utils';\n\nconst defaultOptions = {\n  debug: false,\n  minZoom: 15,\n  endpoint: '',\n  loadedBounds: [],\n  markerIcon: L.Icon(),\n  timeout: 30 * 1000, // Milliseconds\n  retryOnTimeout: false,\n  noInitialRequest: false,\n  onSuccess: () => {},\n  onError: () => {},\n  onTimeout: () => {},\n  beforeRequest: () => {},\n  afterRequest: () => {}\n};\n\nexport default L.FeatureGroup.extend({\n  options: {\n    ...defaultOptions\n  },\n\n  initialize(options = {}) {\n    this.options = {\n      ...defaultOptions,\n      ...options,\n      endpoint: removeTrailingSlash(options.endpoint || '')\n    };\n\n    this.id = uuid();\n\n    this.constructor(options);\n  },\n\n  // To overwrite by the children\n  constructor() {},\n\n  // To overwrite by the children\n  clear() {},\n\n  // To overwrite by the children\n  buildRequestBounds(bounds) {\n    return bounds;\n  },\n\n  // To overwrite by the children\n  buildRequestPromise() {\n    return Promise.resolve({});\n  },\n\n  onAdd(map) {\n    this.map = map;\n    this.bounds = new Bounds();\n    this.requestInProgress = false;\n    this.markers = L.featureGroup().addTo(this.map);\n\n    if (this.options.debug) {\n      this.boxes = new Boxes();\n      this.boxes.setMap(map);\n    }\n\n    if (!this.options.noInitialRequest) {\n      this.prepareRequest();\n    }\n\n    this.map.on('moveend', this.prepareRequest, this);\n  },\n\n  onRemove(map) {\n    L.LayerGroup.prototype.onRemove.call(this, map);\n\n    this._clear();\n    this.clear();\n\n    map.off('moveend', this.prepareRequest, this);\n\n    this.map = null;\n  },\n\n  _clear() {\n    this.bounds.clear();\n    this.markers.clearLayers();\n    this.requestInProgress = false;\n\n    if (this.options.debug) {\n      this.boxes.clear();\n    }\n  },\n\n  /**\n   * Replace the current query by a new one, clear the data and launch a request\n   * @public\n   * @param {string} query\n   */\n  setQuery(query) {\n    this.options.query = query;\n    this._clear();\n    this.clear();\n    this.prepareRequest();\n  },\n\n  prepareRequest() {\n    if (this.map.getZoom() < this.options.minZoom) {\n      return false;\n    }\n\n    const bounds = this.buildRequestBounds(this.map.getBounds());\n    const nextRequest = this.sendRequest.bind(this, bounds);\n\n    if (this.requestInProgress) {\n      this.setNextRequest(nextRequest);\n    } else {\n      this.removeNextRequest();\n      nextRequest();\n    }\n  },\n\n  hasNextRequest() {\n    return !!this.nextRequest;\n  },\n\n  getNextRequest() {\n    return this.nextRequest;\n  },\n\n  setNextRequest(nextRequest) {\n    this.nextRequest = nextRequest;\n  },\n\n  removeNextRequest() {\n    this.nextRequest = null;\n  },\n\n  sendRequest(bounds) {\n    if (this.bounds.areFullyLoaded(bounds)) {\n      this.requestInProgress = false;\n      return;\n    }\n\n    const beforeRequestResult = this.options.beforeRequest.call(this);\n\n    if (beforeRequestResult === false) {\n      this.options.afterRequest.call(this);\n      return;\n    }\n\n    if (this.options.debug) {\n      this.boxes.addRequestBox(bounds);\n    }\n\n    this.requestInProgress = true;\n\n    const controller = new window.AbortController();\n    const signal = controller.signal;\n    const request = this.buildRequestPromise(bounds, signal);\n    const timeout = setTimeout(() => {\n      controller.abort();\n      this.onRequestTimeout(request, bounds);\n    }, this.options.timeout);\n\n    request\n      .then(response => {\n        clearTimeout(timeout);\n        this.options.onSuccess.call(this, response);\n        this.onRequestLoadCallback(bounds);\n      })\n      .catch(() => {\n        clearTimeout(timeout);\n        this.onRequestErrorCallback(bounds);\n        this.options.onError.call(this, request);\n      })\n      .then(() => this.onRequestCompleteCallback(bounds));\n  },\n\n  onRequestTimeout(request, bounds) {\n    this.options.onTimeout.call(this, request);\n\n    if (this.options.retryOnTimeout) {\n      this.sendRequest(bounds);\n    } else {\n      this.onRequestErrorCallback(bounds);\n      this.onRequestCompleteCallback(bounds);\n    }\n  },\n\n  onRequestLoadCallback(bounds) {\n    this.bounds.add(bounds);\n\n    if (this.options.debug) {\n      this.boxes.addResponseBoxes(this.boxes.getRequestBoxes());\n    }\n  },\n\n  onRequestErrorCallback(bounds) {\n    if (this.options.debug) {\n      this.boxes.removeRequestBox(bounds);\n    }\n  },\n\n  onRequestCompleteCallback() {\n    this.options.afterRequest.call(this);\n\n    if (this.hasNextRequest()) {\n      const nextRequest = this.getNextRequest();\n      this.removeNextRequest();\n      nextRequest();\n    } else {\n      this.requestInProgress = false;\n    }\n  }\n});\n","export { overpass } from './overpass';\nexport { osmose } from './osmose';\n","import L from 'leaflet';\nimport OsmoseRequest from 'osmose-request';\nimport BaseService from 'services/baseService';\nimport { buildIconMarker, buildCircleMarker } from 'helpers/marker';\nimport { removeTrailingSlash, buildLargerBounds } from 'helpers/utils';\n\nconst defaultOptions = {\n  endpoint: 'https://osmose.openstreetmap.fr/api/0.2',\n  language: 'en'\n};\n\nconst Osmose = BaseService.extend({\n  osmoseIds: {},\n\n  /**\n   * @constructs\n   * @param {object} options\n   */\n  constructor(options) {\n    this.options = {\n      ...this.options, // defaultOptions from BaseService\n      ...defaultOptions, // defaultOptions from that service file\n      onSuccess: this.onSuccess, // Default onSuccess callback for that service\n      ...options, // User options\n      endpoint: removeTrailingSlash(options.endpoint || defaultOptions.endpoint)\n    };\n\n    this.osmoseRequest = new OsmoseRequest({\n      endpoint: this.options.endpoint,\n      language: this.options.language\n    });\n  },\n\n  /**\n   * Clear the known POI ids\n   */\n  clear() {\n    this.osmoseIds = {};\n  },\n\n  /**\n   * Enlarge the area covered by the bounds\n   * @param {L.Bounds} bounds\n   * @return {L.Bounds}\n   */\n  buildRequestBounds(bounds) {\n    return buildLargerBounds(bounds);\n  },\n\n  /**\n   * Method called by Nectarivore to build the request to the API\n   * @param {L.Bounds} bounds\n   * @return {Promise}\n   */\n  buildRequestPromise(bounds) {\n    const options = this.buildOsmoseOptions(this.options, bounds);\n\n    return this.osmoseRequest.fetchErrors(options);\n  },\n\n  /**\n   * Build the options to send to the Osmose API\n   * @param {object} options\n   * @param {L.Bounds} bounds\n   * @return {object}\n   */\n  buildOsmoseOptions(options, bounds) {\n    const sw = bounds._southWest;\n    const ne = bounds._northEast;\n    const bbox = [sw.lng, sw.lat, ne.lng, ne.lat].join(',');\n    const osmoseOptions = { bbox };\n\n    [\n      'item',\n      'source',\n      'class',\n      'username',\n      'level',\n      'full',\n      'zoom',\n      'limit',\n      'country',\n      'useDevItem',\n      'status',\n      'start_date',\n      'end_date',\n      'tags',\n      'fixables'\n    ].forEach(optionName => {\n      if (options[optionName]) {\n        osmoseOptions[optionName] = options[optionName];\n      }\n    });\n\n    return osmoseOptions;\n  },\n\n  /**\n   * Default onSuccess callback for the Osmose service\n   * @param {object} data Data returned by the request\n   */\n  onSuccess(data) {\n    data.forEach(element => {\n      if (element.error_id in this.osmoseIds) {\n        return;\n      }\n\n      this.osmoseIds[element.error_id] = true;\n\n      const latLng = new L.LatLng(element.lat, element.lon);\n      const marker = this.options.markerIcon\n        ? buildIconMarker(latLng, this.options.markerIcon)\n        : buildCircleMarker(latLng);\n\n      this.markers.addLayer(marker);\n    });\n  }\n});\n\nexport const osmose = options => new Osmose(options);\n\nexport default osmose;\n","import L from 'leaflet';\nimport BaseService from 'services/baseService';\nimport { buildIconMarker, buildCircleMarker } from 'helpers/marker';\nimport { removeTrailingSlash, buildLargerBounds } from 'helpers/utils';\n\nconst defaultOptions = {\n  endpoint: 'https://overpass-api.de/api',\n  query: `(\n    node({{bbox}})[organic];\n    node({{bbox}})[second_hand];\n  );\n  out qt;`\n};\n\nconst Overpass = BaseService.extend({\n  overpassIds: {},\n\n  /**\n   * @constructs\n   * @param {object} options\n   */\n  constructor(options = {}) {\n    this.options = {\n      ...this.options, // defaultOptions from BaseService\n      ...defaultOptions, // defaultOptions from that service file\n      onSuccess: this.onSuccess, // Default onSuccess callback for that service\n      ...options, // User options\n      endpoint: removeTrailingSlash(options.endpoint || defaultOptions.endpoint)\n    };\n  },\n\n  /**\n   * Clear the known POI ids\n   */\n  clear() {\n    this.overpassIds = {};\n  },\n\n  /**\n   * Enlarge the area covered by the bounds\n   * @param {L.Bounds} bounds\n   * @return {L.Bounds}\n   */\n  buildRequestBounds(bounds) {\n    return buildLargerBounds(bounds);\n  },\n\n  /**\n   * Method called by Nectarivore to build the request to the API\n   * @param {L.Bounds} bounds\n   * @return {Promise}\n   */\n  buildRequestPromise(bounds, signal) {\n    const query = this.buildOverpassQueryFromQueryAndBounds(\n      this.options.query,\n      bounds\n    );\n    const endpoint = this.options.endpoint;\n    const url = `${endpoint}/interpreter?data=${query}`;\n\n    return fetch(url, { method: 'GET', signal }).then(response =>\n      response.json()\n    );\n  },\n\n  /**\n   * Build the query to send to Overpass\n   * @param {string} query\n   * @param {L.Bounds} bounds\n   * @return {string}\n   */\n  buildOverpassQueryFromQueryAndBounds(query, bounds) {\n    const sw = bounds._southWest;\n    const ne = bounds._northEast;\n    const coordinates = [sw.lat, sw.lng, ne.lat, ne.lng].join(',');\n    return query\n      .replace(/\\s*\\/\\/.*/g, '')\n      .replace(/\\s*\\/\\*[\\s\\S]*\\*\\/\\s*/g, '')\n      .replace(/^\\s*(\\[.*\\];)?\\s*/g, '[out:json];')\n      .replace(/(\\{\\{bbox\\}\\})/g, coordinates);\n  },\n\n  /**\n   * Default onSuccess callback for the Overpass service\n   * @param {object} data Data returned by the request\n   */\n  onSuccess(data) {\n    data.elements.forEach(element => {\n      if (typeof element.lat === 'undefined' && !element.center) {\n        return;\n      }\n\n      if (element.id in this.overpassIds) {\n        return;\n      }\n\n      this.overpassIds[element.id] = true;\n\n      const latLng =\n        element.type === 'node'\n          ? new L.LatLng(element.lat, element.lon)\n          : new L.LatLng(element.center.lat, element.center.lon);\n\n      const marker = this.options.markerIcon\n        ? buildIconMarker(latLng, this.options.markerIcon)\n        : buildCircleMarker(latLng);\n\n      const popup = this.buildPopup(element.tags, element.id);\n      marker.bindPopup(popup);\n\n      this.markers.addLayer(marker);\n    });\n  },\n\n  /**\n   * Build a Leaflet popup from POI informations\n   * @param {object} tags\n   * @param {string} id\n   * @return {L.Popup}\n   */\n  buildPopup(tags, id) {\n    const anchor = document.createElement('a');\n    anchor.href = `https://www.openstreetmap.org/edit?editor=id&node=${id}`;\n    anchor.style.display = 'block';\n    anchor.style.marginBottom = '15px';\n    anchor.style.textAlign = 'center';\n    anchor.appendChild(document.createTextNode('Edit this entry in iD'));\n\n    const table = document.createElement('table');\n    table.style.border = '1px solid #ccc';\n    table.style.borderSpacing = '0';\n    table.style.borderCollapse = 'separate';\n\n    let odd = true;\n    for (const key of Object.keys(tags)) {\n      odd = !odd;\n      const row = table.insertRow(0);\n      const cell1 = row.insertCell(0);\n      const cell2 = row.insertCell(1);\n\n      row.style.background = odd ? '#efefef' : '#fff';\n      cell1.style.padding = '5px 10px';\n      cell2.style.padding = '5px 10px';\n\n      cell1.appendChild(document.createTextNode(key));\n      cell2.appendChild(document.createTextNode(tags[key]));\n    }\n\n    const div = document.createElement('div');\n    div.appendChild(anchor);\n    div.appendChild(table);\n\n    return L.popup().setContent(div);\n  }\n});\n\nexport const overpass = options => new Overpass(options);\n\nexport default overpass;\n","module.exports = __WEBPACK_EXTERNAL_MODULE_leaflet__;"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACz0NA;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACnBA;AACA;;;AAAA;AACA;;;;;;;;;AACA;;;;AACA;;;;;;;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AAAA;AAEA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAbA;AAkBA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AAAA;AAMA;;;;;;AAvGA;;;;;;;;;;;;;;;;;;;;;;ACHA;AACA;;;;;;;AACA;;;;AACA;AACA;AACA;AACA;AAHA;AAMA;AACA;AACA;;;;;;;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AAEA;AACA;AAHA;AAKA;AACA;AACA;;;;;;;;AAKA;AACA;AAEA;AACA;AAHA;AAKA;AACA;AACA;;;;;;;;AAKA;AACA;AAGA;AACA;AACA;;;;;;;;AAKA;AACA;AAGA;AACA;AACA;;;;;;;AAIA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;;;;;;AAhIA;;;;;;;;;;;;;;;;;ACKA;AASA;AACA;AAjBA;AACA;;;;;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AAHA;AAKA;;;;;;;;;;;;;;;;;;;;ACfA;AASA;AACA;AAjBA;AACA;;;;;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;;;;;;;;;;;;;;;;;;;;AC/BA;AACA;AADA;AACA;;;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACNA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA;AACA;AAeA;AACA;AACA;AAGA;AAAA;AACA;AAAA;AAGA;AAHA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhMA;;;;;;;;;;;;;;;;;;;;;;;ACtBA;;;;;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;AAAA;AACA;AAAA;AACA;;;AACA;AACA;AACA;AAFA;AACA;AAIA;AACA;AACA;AACA;;;;AAIA;AACA;AAGA;AAEA;AALA;AACA;AAOA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAAA;;;AAGA;AACA;AACA;AACA;AACA;AAAA;;;;;AAKA;AACA;AACA;AACA;AACA;AAAA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;AAIA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAzGA;AACA;AA2GA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACzHA;AACA;;;AAAA;AACA;;;AAAA;AACA;AAAA;AACA;;;AACA;AACA;AACA;AAFA;AACA;AAQA;AACA;AACA;AACA;;;;AAIA;AAAA;AACA;AAAA;AAGA;AAEA;AALA;AAOA;AACA;AACA;AAAA;;;AAGA;AACA;AACA;AACA;AACA;AAAA;;;;;AAKA;AACA;AACA;AACA;AACA;AAAA;;;;;AAKA;AACA;AAIA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;;;;;;AAMA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AAAA;;;;AAIA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA;AAAA;AAAA;AACA;AADA;AAcA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA1BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AA2BA;AACA;AACA;AACA;AACA;AACA;AA3IA;AACA;AA6IA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;AC9JA;;;;;A","sourceRoot":""}